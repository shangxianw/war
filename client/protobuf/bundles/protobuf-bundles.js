var $protobuf = window.protobuf;
$protobuf.roots.default=window;
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.Protocol = (function() {

    /**
     * Namespace Protocol.
     * @exports Protocol
     * @namespace
     */
    var Protocol = {};

    Protocol.LoginGame_Request = (function() {

        /**
         * Properties of a LoginGame_Request.
         * @memberof Protocol
         * @interface ILoginGame_Request
         * @property {string|null} [account] LoginGame_Request account
         * @property {string|null} [os] LoginGame_Request os
         * @property {string|null} [packgeId] LoginGame_Request packgeId
         * @property {string|null} [channelId] LoginGame_Request channelId
         * @property {string|null} [ua] LoginGame_Request ua
         * @property {string|null} [deviceId] LoginGame_Request deviceId
         * @property {string|null} [mainChannelId] LoginGame_Request mainChannelId
         */

        /**
         * Constructs a new LoginGame_Request.
         * @memberof Protocol
         * @classdesc Represents a LoginGame_Request.
         * @implements ILoginGame_Request
         * @constructor
         * @param {Protocol.ILoginGame_Request=} [properties] Properties to set
         */
        function LoginGame_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginGame_Request account.
         * @member {string} account
         * @memberof Protocol.LoginGame_Request
         * @instance
         */
        LoginGame_Request.prototype.account = "";

        /**
         * LoginGame_Request os.
         * @member {string} os
         * @memberof Protocol.LoginGame_Request
         * @instance
         */
        LoginGame_Request.prototype.os = "";

        /**
         * LoginGame_Request packgeId.
         * @member {string} packgeId
         * @memberof Protocol.LoginGame_Request
         * @instance
         */
        LoginGame_Request.prototype.packgeId = "";

        /**
         * LoginGame_Request channelId.
         * @member {string} channelId
         * @memberof Protocol.LoginGame_Request
         * @instance
         */
        LoginGame_Request.prototype.channelId = "";

        /**
         * LoginGame_Request ua.
         * @member {string} ua
         * @memberof Protocol.LoginGame_Request
         * @instance
         */
        LoginGame_Request.prototype.ua = "";

        /**
         * LoginGame_Request deviceId.
         * @member {string} deviceId
         * @memberof Protocol.LoginGame_Request
         * @instance
         */
        LoginGame_Request.prototype.deviceId = "";

        /**
         * LoginGame_Request mainChannelId.
         * @member {string} mainChannelId
         * @memberof Protocol.LoginGame_Request
         * @instance
         */
        LoginGame_Request.prototype.mainChannelId = "";

        /**
         * Creates a new LoginGame_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.LoginGame_Request
         * @static
         * @param {Protocol.ILoginGame_Request=} [properties] Properties to set
         * @returns {Protocol.LoginGame_Request} LoginGame_Request instance
         */
        LoginGame_Request.create = function create(properties) {
            return new LoginGame_Request(properties);
        };

        /**
         * Encodes the specified LoginGame_Request message. Does not implicitly {@link Protocol.LoginGame_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.LoginGame_Request
         * @static
         * @param {Protocol.ILoginGame_Request} message LoginGame_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginGame_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && message.hasOwnProperty("account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.os != null && message.hasOwnProperty("os"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.os);
            if (message.packgeId != null && message.hasOwnProperty("packgeId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.packgeId);
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.channelId);
            if (message.ua != null && message.hasOwnProperty("ua"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.ua);
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.deviceId);
            if (message.mainChannelId != null && message.hasOwnProperty("mainChannelId"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.mainChannelId);
            return writer;
        };

        /**
         * Encodes the specified LoginGame_Request message, length delimited. Does not implicitly {@link Protocol.LoginGame_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.LoginGame_Request
         * @static
         * @param {Protocol.ILoginGame_Request} message LoginGame_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginGame_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginGame_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.LoginGame_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.LoginGame_Request} LoginGame_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginGame_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.LoginGame_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = reader.string();
                    break;
                case 2:
                    message.os = reader.string();
                    break;
                case 3:
                    message.packgeId = reader.string();
                    break;
                case 4:
                    message.channelId = reader.string();
                    break;
                case 5:
                    message.ua = reader.string();
                    break;
                case 6:
                    message.deviceId = reader.string();
                    break;
                case 7:
                    message.mainChannelId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginGame_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.LoginGame_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.LoginGame_Request} LoginGame_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginGame_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginGame_Request message.
         * @function verify
         * @memberof Protocol.LoginGame_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginGame_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            if (message.os != null && message.hasOwnProperty("os"))
                if (!$util.isString(message.os))
                    return "os: string expected";
            if (message.packgeId != null && message.hasOwnProperty("packgeId"))
                if (!$util.isString(message.packgeId))
                    return "packgeId: string expected";
            if (message.channelId != null && message.hasOwnProperty("channelId"))
                if (!$util.isString(message.channelId))
                    return "channelId: string expected";
            if (message.ua != null && message.hasOwnProperty("ua"))
                if (!$util.isString(message.ua))
                    return "ua: string expected";
            if (message.deviceId != null && message.hasOwnProperty("deviceId"))
                if (!$util.isString(message.deviceId))
                    return "deviceId: string expected";
            if (message.mainChannelId != null && message.hasOwnProperty("mainChannelId"))
                if (!$util.isString(message.mainChannelId))
                    return "mainChannelId: string expected";
            return null;
        };

        return LoginGame_Request;
    })();

    Protocol.Property = (function() {

        /**
         * Properties of a Property.
         * @memberof Protocol
         * @interface IProperty
         * @property {number|null} [key] Property key
         * @property {number|null} [value] Property value
         */

        /**
         * Constructs a new Property.
         * @memberof Protocol
         * @classdesc Represents a Property.
         * @implements IProperty
         * @constructor
         * @param {Protocol.IProperty=} [properties] Properties to set
         */
        function Property(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Property key.
         * @member {number} key
         * @memberof Protocol.Property
         * @instance
         */
        Property.prototype.key = 0;

        /**
         * Property value.
         * @member {number} value
         * @memberof Protocol.Property
         * @instance
         */
        Property.prototype.value = 0;

        /**
         * Creates a new Property instance using the specified properties.
         * @function create
         * @memberof Protocol.Property
         * @static
         * @param {Protocol.IProperty=} [properties] Properties to set
         * @returns {Protocol.Property} Property instance
         */
        Property.create = function create(properties) {
            return new Property(properties);
        };

        /**
         * Encodes the specified Property message. Does not implicitly {@link Protocol.Property.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Property
         * @static
         * @param {Protocol.IProperty} message Property message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Property.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.key != null && message.hasOwnProperty("key"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.key);
            if (message.value != null && message.hasOwnProperty("value"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.value);
            return writer;
        };

        /**
         * Encodes the specified Property message, length delimited. Does not implicitly {@link Protocol.Property.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Property
         * @static
         * @param {Protocol.IProperty} message Property message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Property.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Property message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Property
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Property} Property
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Property.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Property();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.key = reader.int32();
                    break;
                case 2:
                    message.value = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Property message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Property
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Property} Property
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Property.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Property message.
         * @function verify
         * @memberof Protocol.Property
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Property.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.key != null && message.hasOwnProperty("key"))
                if (!$util.isInteger(message.key))
                    return "key: integer expected";
            if (message.value != null && message.hasOwnProperty("value"))
                if (!$util.isInteger(message.value))
                    return "value: integer expected";
            return null;
        };

        return Property;
    })();

    Protocol.ItemInfo = (function() {

        /**
         * Properties of an ItemInfo.
         * @memberof Protocol
         * @interface IItemInfo
         * @property {number|null} [index] ItemInfo index
         * @property {number|null} [count] ItemInfo count
         */

        /**
         * Constructs a new ItemInfo.
         * @memberof Protocol
         * @classdesc Represents an ItemInfo.
         * @implements IItemInfo
         * @constructor
         * @param {Protocol.IItemInfo=} [properties] Properties to set
         */
        function ItemInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemInfo index.
         * @member {number} index
         * @memberof Protocol.ItemInfo
         * @instance
         */
        ItemInfo.prototype.index = 0;

        /**
         * ItemInfo count.
         * @member {number} count
         * @memberof Protocol.ItemInfo
         * @instance
         */
        ItemInfo.prototype.count = 0;

        /**
         * Creates a new ItemInfo instance using the specified properties.
         * @function create
         * @memberof Protocol.ItemInfo
         * @static
         * @param {Protocol.IItemInfo=} [properties] Properties to set
         * @returns {Protocol.ItemInfo} ItemInfo instance
         */
        ItemInfo.create = function create(properties) {
            return new ItemInfo(properties);
        };

        /**
         * Encodes the specified ItemInfo message. Does not implicitly {@link Protocol.ItemInfo.verify|verify} messages.
         * @function encode
         * @memberof Protocol.ItemInfo
         * @static
         * @param {Protocol.IItemInfo} message ItemInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified ItemInfo message, length delimited. Does not implicitly {@link Protocol.ItemInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.ItemInfo
         * @static
         * @param {Protocol.IItemInfo} message ItemInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.ItemInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.ItemInfo} ItemInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.ItemInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.ItemInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.ItemInfo} ItemInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemInfo message.
         * @function verify
         * @memberof Protocol.ItemInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        return ItemInfo;
    })();

    Protocol.LoginGame_Respond = (function() {

        /**
         * Properties of a LoginGame_Respond.
         * @memberof Protocol
         * @interface ILoginGame_Respond
         * @property {string|null} [account] LoginGame_Respond account
         * @property {number|Long|null} [roleId] LoginGame_Respond roleId
         * @property {string|null} [name] LoginGame_Respond name
         * @property {number|null} [ret] LoginGame_Respond ret
         * @property {Array.<number>|null} [lineUp1] LoginGame_Respond lineUp1
         * @property {Array.<number>|null} [lineUp2] LoginGame_Respond lineUp2
         * @property {Array.<number>|null} [lineUp3] LoginGame_Respond lineUp3
         * @property {Array.<number>|null} [lineUp4] LoginGame_Respond lineUp4
         * @property {Array.<number>|null} [lineUp5] LoginGame_Respond lineUp5
         * @property {Array.<number>|null} [lineUp6] LoginGame_Respond lineUp6
         * @property {Array.<Protocol.IHero>|null} [heros] LoginGame_Respond heros
         * @property {number|null} [state] LoginGame_Respond state
         * @property {string|null} [roomId] LoginGame_Respond roomId
         * @property {Array.<Protocol.ITask>|null} [tasks] LoginGame_Respond tasks
         * @property {Array.<Protocol.IProperty>|null} [pros] LoginGame_Respond pros
         * @property {number|null} [capacity] LoginGame_Respond capacity
         * @property {Array.<Protocol.IItemInfo>|null} [items] LoginGame_Respond items
         * @property {number|null} [curLineUp] LoginGame_Respond curLineUp
         * @property {string|null} [familyId] LoginGame_Respond familyId
         * @property {number|null} [familyJob] LoginGame_Respond familyJob
         * @property {number|null} [passDay] LoginGame_Respond passDay
         * @property {boolean|null} [newRoleReward] LoginGame_Respond newRoleReward
         * @property {number|null} [serverId] LoginGame_Respond serverId
         * @property {boolean|null} [isNew] LoginGame_Respond isNew
         * @property {Array.<string>|null} [guides] LoginGame_Respond guides
         * @property {string|null} [createTime] LoginGame_Respond createTime
         * @property {string|null} [ip] LoginGame_Respond ip
         */

        /**
         * Constructs a new LoginGame_Respond.
         * @memberof Protocol
         * @classdesc Represents a LoginGame_Respond.
         * @implements ILoginGame_Respond
         * @constructor
         * @param {Protocol.ILoginGame_Respond=} [properties] Properties to set
         */
        function LoginGame_Respond(properties) {
            this.lineUp1 = [];
            this.lineUp2 = [];
            this.lineUp3 = [];
            this.lineUp4 = [];
            this.lineUp5 = [];
            this.lineUp6 = [];
            this.heros = [];
            this.tasks = [];
            this.pros = [];
            this.items = [];
            this.guides = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LoginGame_Respond account.
         * @member {string} account
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.account = "";

        /**
         * LoginGame_Respond roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LoginGame_Respond name.
         * @member {string} name
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.name = "";

        /**
         * LoginGame_Respond ret.
         * @member {number} ret
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.ret = 0;

        /**
         * LoginGame_Respond lineUp1.
         * @member {Array.<number>} lineUp1
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.lineUp1 = $util.emptyArray;

        /**
         * LoginGame_Respond lineUp2.
         * @member {Array.<number>} lineUp2
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.lineUp2 = $util.emptyArray;

        /**
         * LoginGame_Respond lineUp3.
         * @member {Array.<number>} lineUp3
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.lineUp3 = $util.emptyArray;

        /**
         * LoginGame_Respond lineUp4.
         * @member {Array.<number>} lineUp4
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.lineUp4 = $util.emptyArray;

        /**
         * LoginGame_Respond lineUp5.
         * @member {Array.<number>} lineUp5
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.lineUp5 = $util.emptyArray;

        /**
         * LoginGame_Respond lineUp6.
         * @member {Array.<number>} lineUp6
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.lineUp6 = $util.emptyArray;

        /**
         * LoginGame_Respond heros.
         * @member {Array.<Protocol.IHero>} heros
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.heros = $util.emptyArray;

        /**
         * LoginGame_Respond state.
         * @member {number} state
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.state = 0;

        /**
         * LoginGame_Respond roomId.
         * @member {string} roomId
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.roomId = "";

        /**
         * LoginGame_Respond tasks.
         * @member {Array.<Protocol.ITask>} tasks
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.tasks = $util.emptyArray;

        /**
         * LoginGame_Respond pros.
         * @member {Array.<Protocol.IProperty>} pros
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.pros = $util.emptyArray;

        /**
         * LoginGame_Respond capacity.
         * @member {number} capacity
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.capacity = 0;

        /**
         * LoginGame_Respond items.
         * @member {Array.<Protocol.IItemInfo>} items
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.items = $util.emptyArray;

        /**
         * LoginGame_Respond curLineUp.
         * @member {number} curLineUp
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.curLineUp = 0;

        /**
         * LoginGame_Respond familyId.
         * @member {string} familyId
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.familyId = "";

        /**
         * LoginGame_Respond familyJob.
         * @member {number} familyJob
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.familyJob = 0;

        /**
         * LoginGame_Respond passDay.
         * @member {number} passDay
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.passDay = 0;

        /**
         * LoginGame_Respond newRoleReward.
         * @member {boolean} newRoleReward
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.newRoleReward = false;

        /**
         * LoginGame_Respond serverId.
         * @member {number} serverId
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.serverId = 0;

        /**
         * LoginGame_Respond isNew.
         * @member {boolean} isNew
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.isNew = false;

        /**
         * LoginGame_Respond guides.
         * @member {Array.<string>} guides
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.guides = $util.emptyArray;

        /**
         * LoginGame_Respond createTime.
         * @member {string} createTime
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.createTime = "";

        /**
         * LoginGame_Respond ip.
         * @member {string} ip
         * @memberof Protocol.LoginGame_Respond
         * @instance
         */
        LoginGame_Respond.prototype.ip = "";

        /**
         * Creates a new LoginGame_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.LoginGame_Respond
         * @static
         * @param {Protocol.ILoginGame_Respond=} [properties] Properties to set
         * @returns {Protocol.LoginGame_Respond} LoginGame_Respond instance
         */
        LoginGame_Respond.create = function create(properties) {
            return new LoginGame_Respond(properties);
        };

        /**
         * Encodes the specified LoginGame_Respond message. Does not implicitly {@link Protocol.LoginGame_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.LoginGame_Respond
         * @static
         * @param {Protocol.ILoginGame_Respond} message LoginGame_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginGame_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.account != null && message.hasOwnProperty("account"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.account);
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roleId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.ret);
            if (message.lineUp1 != null && message.lineUp1.length) {
                writer.uint32(/* id 7, wireType 2 =*/58).fork();
                for (var i = 0; i < message.lineUp1.length; ++i)
                    writer.int32(message.lineUp1[i]);
                writer.ldelim();
            }
            if (message.lineUp2 != null && message.lineUp2.length) {
                writer.uint32(/* id 8, wireType 2 =*/66).fork();
                for (var i = 0; i < message.lineUp2.length; ++i)
                    writer.int32(message.lineUp2[i]);
                writer.ldelim();
            }
            if (message.lineUp3 != null && message.lineUp3.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (var i = 0; i < message.lineUp3.length; ++i)
                    writer.int32(message.lineUp3[i]);
                writer.ldelim();
            }
            if (message.heros != null && message.heros.length)
                for (var i = 0; i < message.heros.length; ++i)
                    $root.Protocol.Hero.encode(message.heros[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 11, wireType 0 =*/88).int32(message.state);
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                writer.uint32(/* id 12, wireType 2 =*/98).string(message.roomId);
            if (message.tasks != null && message.tasks.length)
                for (var i = 0; i < message.tasks.length; ++i)
                    $root.Protocol.Task.encode(message.tasks[i], writer.uint32(/* id 13, wireType 2 =*/106).fork()).ldelim();
            if (message.pros != null && message.pros.length)
                for (var i = 0; i < message.pros.length; ++i)
                    $root.Protocol.Property.encode(message.pros[i], writer.uint32(/* id 14, wireType 2 =*/114).fork()).ldelim();
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.capacity);
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.Protocol.ItemInfo.encode(message.items[i], writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
            if (message.curLineUp != null && message.hasOwnProperty("curLineUp"))
                writer.uint32(/* id 17, wireType 0 =*/136).int32(message.curLineUp);
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                writer.uint32(/* id 18, wireType 2 =*/146).string(message.familyId);
            if (message.familyJob != null && message.hasOwnProperty("familyJob"))
                writer.uint32(/* id 19, wireType 0 =*/152).int32(message.familyJob);
            if (message.passDay != null && message.hasOwnProperty("passDay"))
                writer.uint32(/* id 20, wireType 0 =*/160).int32(message.passDay);
            if (message.newRoleReward != null && message.hasOwnProperty("newRoleReward"))
                writer.uint32(/* id 21, wireType 0 =*/168).bool(message.newRoleReward);
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 22, wireType 0 =*/176).int32(message.serverId);
            if (message.isNew != null && message.hasOwnProperty("isNew"))
                writer.uint32(/* id 23, wireType 0 =*/184).bool(message.isNew);
            if (message.guides != null && message.guides.length)
                for (var i = 0; i < message.guides.length; ++i)
                    writer.uint32(/* id 24, wireType 2 =*/194).string(message.guides[i]);
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                writer.uint32(/* id 25, wireType 2 =*/202).string(message.createTime);
            if (message.ip != null && message.hasOwnProperty("ip"))
                writer.uint32(/* id 26, wireType 2 =*/210).string(message.ip);
            if (message.lineUp4 != null && message.lineUp4.length) {
                writer.uint32(/* id 30, wireType 2 =*/242).fork();
                for (var i = 0; i < message.lineUp4.length; ++i)
                    writer.int32(message.lineUp4[i]);
                writer.ldelim();
            }
            if (message.lineUp5 != null && message.lineUp5.length) {
                writer.uint32(/* id 31, wireType 2 =*/250).fork();
                for (var i = 0; i < message.lineUp5.length; ++i)
                    writer.int32(message.lineUp5[i]);
                writer.ldelim();
            }
            if (message.lineUp6 != null && message.lineUp6.length) {
                writer.uint32(/* id 32, wireType 2 =*/258).fork();
                for (var i = 0; i < message.lineUp6.length; ++i)
                    writer.int32(message.lineUp6[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified LoginGame_Respond message, length delimited. Does not implicitly {@link Protocol.LoginGame_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.LoginGame_Respond
         * @static
         * @param {Protocol.ILoginGame_Respond} message LoginGame_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LoginGame_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LoginGame_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.LoginGame_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.LoginGame_Respond} LoginGame_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginGame_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.LoginGame_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.account = reader.string();
                    break;
                case 2:
                    message.roleId = reader.int64();
                    break;
                case 3:
                    message.name = reader.string();
                    break;
                case 6:
                    message.ret = reader.int32();
                    break;
                case 7:
                    if (!(message.lineUp1 && message.lineUp1.length))
                        message.lineUp1 = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.lineUp1.push(reader.int32());
                    } else
                        message.lineUp1.push(reader.int32());
                    break;
                case 8:
                    if (!(message.lineUp2 && message.lineUp2.length))
                        message.lineUp2 = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.lineUp2.push(reader.int32());
                    } else
                        message.lineUp2.push(reader.int32());
                    break;
                case 9:
                    if (!(message.lineUp3 && message.lineUp3.length))
                        message.lineUp3 = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.lineUp3.push(reader.int32());
                    } else
                        message.lineUp3.push(reader.int32());
                    break;
                case 30:
                    if (!(message.lineUp4 && message.lineUp4.length))
                        message.lineUp4 = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.lineUp4.push(reader.int32());
                    } else
                        message.lineUp4.push(reader.int32());
                    break;
                case 31:
                    if (!(message.lineUp5 && message.lineUp5.length))
                        message.lineUp5 = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.lineUp5.push(reader.int32());
                    } else
                        message.lineUp5.push(reader.int32());
                    break;
                case 32:
                    if (!(message.lineUp6 && message.lineUp6.length))
                        message.lineUp6 = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.lineUp6.push(reader.int32());
                    } else
                        message.lineUp6.push(reader.int32());
                    break;
                case 10:
                    if (!(message.heros && message.heros.length))
                        message.heros = [];
                    message.heros.push($root.Protocol.Hero.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.state = reader.int32();
                    break;
                case 12:
                    message.roomId = reader.string();
                    break;
                case 13:
                    if (!(message.tasks && message.tasks.length))
                        message.tasks = [];
                    message.tasks.push($root.Protocol.Task.decode(reader, reader.uint32()));
                    break;
                case 14:
                    if (!(message.pros && message.pros.length))
                        message.pros = [];
                    message.pros.push($root.Protocol.Property.decode(reader, reader.uint32()));
                    break;
                case 15:
                    message.capacity = reader.int32();
                    break;
                case 16:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.Protocol.ItemInfo.decode(reader, reader.uint32()));
                    break;
                case 17:
                    message.curLineUp = reader.int32();
                    break;
                case 18:
                    message.familyId = reader.string();
                    break;
                case 19:
                    message.familyJob = reader.int32();
                    break;
                case 20:
                    message.passDay = reader.int32();
                    break;
                case 21:
                    message.newRoleReward = reader.bool();
                    break;
                case 22:
                    message.serverId = reader.int32();
                    break;
                case 23:
                    message.isNew = reader.bool();
                    break;
                case 24:
                    if (!(message.guides && message.guides.length))
                        message.guides = [];
                    message.guides.push(reader.string());
                    break;
                case 25:
                    message.createTime = reader.string();
                    break;
                case 26:
                    message.ip = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LoginGame_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.LoginGame_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.LoginGame_Respond} LoginGame_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LoginGame_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LoginGame_Respond message.
         * @function verify
         * @memberof Protocol.LoginGame_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LoginGame_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.account != null && message.hasOwnProperty("account"))
                if (!$util.isString(message.account))
                    return "account: string expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.lineUp1 != null && message.hasOwnProperty("lineUp1")) {
                if (!Array.isArray(message.lineUp1))
                    return "lineUp1: array expected";
                for (var i = 0; i < message.lineUp1.length; ++i)
                    if (!$util.isInteger(message.lineUp1[i]))
                        return "lineUp1: integer[] expected";
            }
            if (message.lineUp2 != null && message.hasOwnProperty("lineUp2")) {
                if (!Array.isArray(message.lineUp2))
                    return "lineUp2: array expected";
                for (var i = 0; i < message.lineUp2.length; ++i)
                    if (!$util.isInteger(message.lineUp2[i]))
                        return "lineUp2: integer[] expected";
            }
            if (message.lineUp3 != null && message.hasOwnProperty("lineUp3")) {
                if (!Array.isArray(message.lineUp3))
                    return "lineUp3: array expected";
                for (var i = 0; i < message.lineUp3.length; ++i)
                    if (!$util.isInteger(message.lineUp3[i]))
                        return "lineUp3: integer[] expected";
            }
            if (message.lineUp4 != null && message.hasOwnProperty("lineUp4")) {
                if (!Array.isArray(message.lineUp4))
                    return "lineUp4: array expected";
                for (var i = 0; i < message.lineUp4.length; ++i)
                    if (!$util.isInteger(message.lineUp4[i]))
                        return "lineUp4: integer[] expected";
            }
            if (message.lineUp5 != null && message.hasOwnProperty("lineUp5")) {
                if (!Array.isArray(message.lineUp5))
                    return "lineUp5: array expected";
                for (var i = 0; i < message.lineUp5.length; ++i)
                    if (!$util.isInteger(message.lineUp5[i]))
                        return "lineUp5: integer[] expected";
            }
            if (message.lineUp6 != null && message.hasOwnProperty("lineUp6")) {
                if (!Array.isArray(message.lineUp6))
                    return "lineUp6: array expected";
                for (var i = 0; i < message.lineUp6.length; ++i)
                    if (!$util.isInteger(message.lineUp6[i]))
                        return "lineUp6: integer[] expected";
            }
            if (message.heros != null && message.hasOwnProperty("heros")) {
                if (!Array.isArray(message.heros))
                    return "heros: array expected";
                for (var i = 0; i < message.heros.length; ++i) {
                    var error = $root.Protocol.Hero.verify(message.heros[i]);
                    if (error)
                        return "heros." + error;
                }
            }
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (!$util.isString(message.roomId))
                    return "roomId: string expected";
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (var i = 0; i < message.tasks.length; ++i) {
                    var error = $root.Protocol.Task.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            if (message.pros != null && message.hasOwnProperty("pros")) {
                if (!Array.isArray(message.pros))
                    return "pros: array expected";
                for (var i = 0; i < message.pros.length; ++i) {
                    var error = $root.Protocol.Property.verify(message.pros[i]);
                    if (error)
                        return "pros." + error;
                }
            }
            if (message.capacity != null && message.hasOwnProperty("capacity"))
                if (!$util.isInteger(message.capacity))
                    return "capacity: integer expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.Protocol.ItemInfo.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            if (message.curLineUp != null && message.hasOwnProperty("curLineUp"))
                if (!$util.isInteger(message.curLineUp))
                    return "curLineUp: integer expected";
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                if (!$util.isString(message.familyId))
                    return "familyId: string expected";
            if (message.familyJob != null && message.hasOwnProperty("familyJob"))
                if (!$util.isInteger(message.familyJob))
                    return "familyJob: integer expected";
            if (message.passDay != null && message.hasOwnProperty("passDay"))
                if (!$util.isInteger(message.passDay))
                    return "passDay: integer expected";
            if (message.newRoleReward != null && message.hasOwnProperty("newRoleReward"))
                if (typeof message.newRoleReward !== "boolean")
                    return "newRoleReward: boolean expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            if (message.isNew != null && message.hasOwnProperty("isNew"))
                if (typeof message.isNew !== "boolean")
                    return "isNew: boolean expected";
            if (message.guides != null && message.hasOwnProperty("guides")) {
                if (!Array.isArray(message.guides))
                    return "guides: array expected";
                for (var i = 0; i < message.guides.length; ++i)
                    if (!$util.isString(message.guides[i]))
                        return "guides: string[] expected";
            }
            if (message.createTime != null && message.hasOwnProperty("createTime"))
                if (!$util.isString(message.createTime))
                    return "createTime: string expected";
            if (message.ip != null && message.hasOwnProperty("ip"))
                if (!$util.isString(message.ip))
                    return "ip: string expected";
            return null;
        };

        return LoginGame_Respond;
    })();

    Protocol.BeginMatch_Request = (function() {

        /**
         * Properties of a BeginMatch_Request.
         * @memberof Protocol
         * @interface IBeginMatch_Request
         * @property {number|null} [type] BeginMatch_Request type
         * @property {number|null} [lineUp] BeginMatch_Request lineUp
         */

        /**
         * Constructs a new BeginMatch_Request.
         * @memberof Protocol
         * @classdesc Represents a BeginMatch_Request.
         * @implements IBeginMatch_Request
         * @constructor
         * @param {Protocol.IBeginMatch_Request=} [properties] Properties to set
         */
        function BeginMatch_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginMatch_Request type.
         * @member {number} type
         * @memberof Protocol.BeginMatch_Request
         * @instance
         */
        BeginMatch_Request.prototype.type = 0;

        /**
         * BeginMatch_Request lineUp.
         * @member {number} lineUp
         * @memberof Protocol.BeginMatch_Request
         * @instance
         */
        BeginMatch_Request.prototype.lineUp = 0;

        /**
         * Creates a new BeginMatch_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.BeginMatch_Request
         * @static
         * @param {Protocol.IBeginMatch_Request=} [properties] Properties to set
         * @returns {Protocol.BeginMatch_Request} BeginMatch_Request instance
         */
        BeginMatch_Request.create = function create(properties) {
            return new BeginMatch_Request(properties);
        };

        /**
         * Encodes the specified BeginMatch_Request message. Does not implicitly {@link Protocol.BeginMatch_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BeginMatch_Request
         * @static
         * @param {Protocol.IBeginMatch_Request} message BeginMatch_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginMatch_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.lineUp != null && message.hasOwnProperty("lineUp"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lineUp);
            return writer;
        };

        /**
         * Encodes the specified BeginMatch_Request message, length delimited. Does not implicitly {@link Protocol.BeginMatch_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BeginMatch_Request
         * @static
         * @param {Protocol.IBeginMatch_Request} message BeginMatch_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginMatch_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginMatch_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BeginMatch_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BeginMatch_Request} BeginMatch_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginMatch_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BeginMatch_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.lineUp = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginMatch_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BeginMatch_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BeginMatch_Request} BeginMatch_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginMatch_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginMatch_Request message.
         * @function verify
         * @memberof Protocol.BeginMatch_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginMatch_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.lineUp != null && message.hasOwnProperty("lineUp"))
                if (!$util.isInteger(message.lineUp))
                    return "lineUp: integer expected";
            return null;
        };

        return BeginMatch_Request;
    })();

    Protocol.BeginMatch_Respond = (function() {

        /**
         * Properties of a BeginMatch_Respond.
         * @memberof Protocol
         * @interface IBeginMatch_Respond
         * @property {number|null} [ret] BeginMatch_Respond ret
         */

        /**
         * Constructs a new BeginMatch_Respond.
         * @memberof Protocol
         * @classdesc Represents a BeginMatch_Respond.
         * @implements IBeginMatch_Respond
         * @constructor
         * @param {Protocol.IBeginMatch_Respond=} [properties] Properties to set
         */
        function BeginMatch_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BeginMatch_Respond ret.
         * @member {number} ret
         * @memberof Protocol.BeginMatch_Respond
         * @instance
         */
        BeginMatch_Respond.prototype.ret = 0;

        /**
         * Creates a new BeginMatch_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.BeginMatch_Respond
         * @static
         * @param {Protocol.IBeginMatch_Respond=} [properties] Properties to set
         * @returns {Protocol.BeginMatch_Respond} BeginMatch_Respond instance
         */
        BeginMatch_Respond.create = function create(properties) {
            return new BeginMatch_Respond(properties);
        };

        /**
         * Encodes the specified BeginMatch_Respond message. Does not implicitly {@link Protocol.BeginMatch_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BeginMatch_Respond
         * @static
         * @param {Protocol.IBeginMatch_Respond} message BeginMatch_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginMatch_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified BeginMatch_Respond message, length delimited. Does not implicitly {@link Protocol.BeginMatch_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BeginMatch_Respond
         * @static
         * @param {Protocol.IBeginMatch_Respond} message BeginMatch_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BeginMatch_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BeginMatch_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BeginMatch_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BeginMatch_Respond} BeginMatch_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginMatch_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BeginMatch_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BeginMatch_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BeginMatch_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BeginMatch_Respond} BeginMatch_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BeginMatch_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BeginMatch_Respond message.
         * @function verify
         * @memberof Protocol.BeginMatch_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BeginMatch_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return BeginMatch_Respond;
    })();

    Protocol.HearBeat_Request = (function() {

        /**
         * Properties of a HearBeat_Request.
         * @memberof Protocol
         * @interface IHearBeat_Request
         */

        /**
         * Constructs a new HearBeat_Request.
         * @memberof Protocol
         * @classdesc Represents a HearBeat_Request.
         * @implements IHearBeat_Request
         * @constructor
         * @param {Protocol.IHearBeat_Request=} [properties] Properties to set
         */
        function HearBeat_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new HearBeat_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.HearBeat_Request
         * @static
         * @param {Protocol.IHearBeat_Request=} [properties] Properties to set
         * @returns {Protocol.HearBeat_Request} HearBeat_Request instance
         */
        HearBeat_Request.create = function create(properties) {
            return new HearBeat_Request(properties);
        };

        /**
         * Encodes the specified HearBeat_Request message. Does not implicitly {@link Protocol.HearBeat_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.HearBeat_Request
         * @static
         * @param {Protocol.IHearBeat_Request} message HearBeat_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HearBeat_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified HearBeat_Request message, length delimited. Does not implicitly {@link Protocol.HearBeat_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.HearBeat_Request
         * @static
         * @param {Protocol.IHearBeat_Request} message HearBeat_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HearBeat_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HearBeat_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.HearBeat_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.HearBeat_Request} HearBeat_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HearBeat_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.HearBeat_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HearBeat_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.HearBeat_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.HearBeat_Request} HearBeat_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HearBeat_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HearBeat_Request message.
         * @function verify
         * @memberof Protocol.HearBeat_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HearBeat_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return HearBeat_Request;
    })();

    Protocol.HearBeat_Respond = (function() {

        /**
         * Properties of a HearBeat_Respond.
         * @memberof Protocol
         * @interface IHearBeat_Respond
         * @property {number|null} [state] HearBeat_Respond state
         */

        /**
         * Constructs a new HearBeat_Respond.
         * @memberof Protocol
         * @classdesc Represents a HearBeat_Respond.
         * @implements IHearBeat_Respond
         * @constructor
         * @param {Protocol.IHearBeat_Respond=} [properties] Properties to set
         */
        function HearBeat_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HearBeat_Respond state.
         * @member {number} state
         * @memberof Protocol.HearBeat_Respond
         * @instance
         */
        HearBeat_Respond.prototype.state = 0;

        /**
         * Creates a new HearBeat_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.HearBeat_Respond
         * @static
         * @param {Protocol.IHearBeat_Respond=} [properties] Properties to set
         * @returns {Protocol.HearBeat_Respond} HearBeat_Respond instance
         */
        HearBeat_Respond.create = function create(properties) {
            return new HearBeat_Respond(properties);
        };

        /**
         * Encodes the specified HearBeat_Respond message. Does not implicitly {@link Protocol.HearBeat_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.HearBeat_Respond
         * @static
         * @param {Protocol.IHearBeat_Respond} message HearBeat_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HearBeat_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.state);
            return writer;
        };

        /**
         * Encodes the specified HearBeat_Respond message, length delimited. Does not implicitly {@link Protocol.HearBeat_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.HearBeat_Respond
         * @static
         * @param {Protocol.IHearBeat_Respond} message HearBeat_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HearBeat_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HearBeat_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.HearBeat_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.HearBeat_Respond} HearBeat_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HearBeat_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.HearBeat_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HearBeat_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.HearBeat_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.HearBeat_Respond} HearBeat_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HearBeat_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HearBeat_Respond message.
         * @function verify
         * @memberof Protocol.HearBeat_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HearBeat_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            return null;
        };

        return HearBeat_Respond;
    })();

    Protocol.CancleMatch_Request = (function() {

        /**
         * Properties of a CancleMatch_Request.
         * @memberof Protocol
         * @interface ICancleMatch_Request
         */

        /**
         * Constructs a new CancleMatch_Request.
         * @memberof Protocol
         * @classdesc Represents a CancleMatch_Request.
         * @implements ICancleMatch_Request
         * @constructor
         * @param {Protocol.ICancleMatch_Request=} [properties] Properties to set
         */
        function CancleMatch_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new CancleMatch_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.CancleMatch_Request
         * @static
         * @param {Protocol.ICancleMatch_Request=} [properties] Properties to set
         * @returns {Protocol.CancleMatch_Request} CancleMatch_Request instance
         */
        CancleMatch_Request.create = function create(properties) {
            return new CancleMatch_Request(properties);
        };

        /**
         * Encodes the specified CancleMatch_Request message. Does not implicitly {@link Protocol.CancleMatch_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.CancleMatch_Request
         * @static
         * @param {Protocol.ICancleMatch_Request} message CancleMatch_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancleMatch_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified CancleMatch_Request message, length delimited. Does not implicitly {@link Protocol.CancleMatch_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.CancleMatch_Request
         * @static
         * @param {Protocol.ICancleMatch_Request} message CancleMatch_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancleMatch_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancleMatch_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.CancleMatch_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.CancleMatch_Request} CancleMatch_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancleMatch_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.CancleMatch_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancleMatch_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.CancleMatch_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.CancleMatch_Request} CancleMatch_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancleMatch_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancleMatch_Request message.
         * @function verify
         * @memberof Protocol.CancleMatch_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancleMatch_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return CancleMatch_Request;
    })();

    Protocol.CancleMatch_Respond = (function() {

        /**
         * Properties of a CancleMatch_Respond.
         * @memberof Protocol
         * @interface ICancleMatch_Respond
         * @property {number|null} [ret] CancleMatch_Respond ret
         */

        /**
         * Constructs a new CancleMatch_Respond.
         * @memberof Protocol
         * @classdesc Represents a CancleMatch_Respond.
         * @implements ICancleMatch_Respond
         * @constructor
         * @param {Protocol.ICancleMatch_Respond=} [properties] Properties to set
         */
        function CancleMatch_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CancleMatch_Respond ret.
         * @member {number} ret
         * @memberof Protocol.CancleMatch_Respond
         * @instance
         */
        CancleMatch_Respond.prototype.ret = 0;

        /**
         * Creates a new CancleMatch_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.CancleMatch_Respond
         * @static
         * @param {Protocol.ICancleMatch_Respond=} [properties] Properties to set
         * @returns {Protocol.CancleMatch_Respond} CancleMatch_Respond instance
         */
        CancleMatch_Respond.create = function create(properties) {
            return new CancleMatch_Respond(properties);
        };

        /**
         * Encodes the specified CancleMatch_Respond message. Does not implicitly {@link Protocol.CancleMatch_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.CancleMatch_Respond
         * @static
         * @param {Protocol.ICancleMatch_Respond} message CancleMatch_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancleMatch_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified CancleMatch_Respond message, length delimited. Does not implicitly {@link Protocol.CancleMatch_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.CancleMatch_Respond
         * @static
         * @param {Protocol.ICancleMatch_Respond} message CancleMatch_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CancleMatch_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CancleMatch_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.CancleMatch_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.CancleMatch_Respond} CancleMatch_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancleMatch_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.CancleMatch_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CancleMatch_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.CancleMatch_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.CancleMatch_Respond} CancleMatch_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CancleMatch_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CancleMatch_Respond message.
         * @function verify
         * @memberof Protocol.CancleMatch_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CancleMatch_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return CancleMatch_Respond;
    })();

    Protocol.GMCommand_Request = (function() {

        /**
         * Properties of a GMCommand_Request.
         * @memberof Protocol
         * @interface IGMCommand_Request
         * @property {string|null} [command] GMCommand_Request command
         */

        /**
         * Constructs a new GMCommand_Request.
         * @memberof Protocol
         * @classdesc Represents a GMCommand_Request.
         * @implements IGMCommand_Request
         * @constructor
         * @param {Protocol.IGMCommand_Request=} [properties] Properties to set
         */
        function GMCommand_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GMCommand_Request command.
         * @member {string} command
         * @memberof Protocol.GMCommand_Request
         * @instance
         */
        GMCommand_Request.prototype.command = "";

        /**
         * Creates a new GMCommand_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.GMCommand_Request
         * @static
         * @param {Protocol.IGMCommand_Request=} [properties] Properties to set
         * @returns {Protocol.GMCommand_Request} GMCommand_Request instance
         */
        GMCommand_Request.create = function create(properties) {
            return new GMCommand_Request(properties);
        };

        /**
         * Encodes the specified GMCommand_Request message. Does not implicitly {@link Protocol.GMCommand_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GMCommand_Request
         * @static
         * @param {Protocol.IGMCommand_Request} message GMCommand_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GMCommand_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.command != null && message.hasOwnProperty("command"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.command);
            return writer;
        };

        /**
         * Encodes the specified GMCommand_Request message, length delimited. Does not implicitly {@link Protocol.GMCommand_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GMCommand_Request
         * @static
         * @param {Protocol.IGMCommand_Request} message GMCommand_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GMCommand_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GMCommand_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GMCommand_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GMCommand_Request} GMCommand_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GMCommand_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GMCommand_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.command = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GMCommand_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GMCommand_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GMCommand_Request} GMCommand_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GMCommand_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GMCommand_Request message.
         * @function verify
         * @memberof Protocol.GMCommand_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GMCommand_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.command != null && message.hasOwnProperty("command"))
                if (!$util.isString(message.command))
                    return "command: string expected";
            return null;
        };

        return GMCommand_Request;
    })();

    Protocol.GMCommand_Respond = (function() {

        /**
         * Properties of a GMCommand_Respond.
         * @memberof Protocol
         * @interface IGMCommand_Respond
         * @property {boolean|null} [ret] GMCommand_Respond ret
         */

        /**
         * Constructs a new GMCommand_Respond.
         * @memberof Protocol
         * @classdesc Represents a GMCommand_Respond.
         * @implements IGMCommand_Respond
         * @constructor
         * @param {Protocol.IGMCommand_Respond=} [properties] Properties to set
         */
        function GMCommand_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GMCommand_Respond ret.
         * @member {boolean} ret
         * @memberof Protocol.GMCommand_Respond
         * @instance
         */
        GMCommand_Respond.prototype.ret = false;

        /**
         * Creates a new GMCommand_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.GMCommand_Respond
         * @static
         * @param {Protocol.IGMCommand_Respond=} [properties] Properties to set
         * @returns {Protocol.GMCommand_Respond} GMCommand_Respond instance
         */
        GMCommand_Respond.create = function create(properties) {
            return new GMCommand_Respond(properties);
        };

        /**
         * Encodes the specified GMCommand_Respond message. Does not implicitly {@link Protocol.GMCommand_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GMCommand_Respond
         * @static
         * @param {Protocol.IGMCommand_Respond} message GMCommand_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GMCommand_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.ret);
            return writer;
        };

        /**
         * Encodes the specified GMCommand_Respond message, length delimited. Does not implicitly {@link Protocol.GMCommand_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GMCommand_Respond
         * @static
         * @param {Protocol.IGMCommand_Respond} message GMCommand_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GMCommand_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GMCommand_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GMCommand_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GMCommand_Respond} GMCommand_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GMCommand_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GMCommand_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GMCommand_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GMCommand_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GMCommand_Respond} GMCommand_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GMCommand_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GMCommand_Respond message.
         * @function verify
         * @memberof Protocol.GMCommand_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GMCommand_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (typeof message.ret !== "boolean")
                    return "ret: boolean expected";
            return null;
        };

        return GMCommand_Respond;
    })();

    Protocol.SetFightLineUp_Request = (function() {

        /**
         * Properties of a SetFightLineUp_Request.
         * @memberof Protocol
         * @interface ISetFightLineUp_Request
         * @property {number|null} [lineUpNum] SetFightLineUp_Request lineUpNum
         */

        /**
         * Constructs a new SetFightLineUp_Request.
         * @memberof Protocol
         * @classdesc Represents a SetFightLineUp_Request.
         * @implements ISetFightLineUp_Request
         * @constructor
         * @param {Protocol.ISetFightLineUp_Request=} [properties] Properties to set
         */
        function SetFightLineUp_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetFightLineUp_Request lineUpNum.
         * @member {number} lineUpNum
         * @memberof Protocol.SetFightLineUp_Request
         * @instance
         */
        SetFightLineUp_Request.prototype.lineUpNum = 0;

        /**
         * Creates a new SetFightLineUp_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.SetFightLineUp_Request
         * @static
         * @param {Protocol.ISetFightLineUp_Request=} [properties] Properties to set
         * @returns {Protocol.SetFightLineUp_Request} SetFightLineUp_Request instance
         */
        SetFightLineUp_Request.create = function create(properties) {
            return new SetFightLineUp_Request(properties);
        };

        /**
         * Encodes the specified SetFightLineUp_Request message. Does not implicitly {@link Protocol.SetFightLineUp_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SetFightLineUp_Request
         * @static
         * @param {Protocol.ISetFightLineUp_Request} message SetFightLineUp_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFightLineUp_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lineUpNum != null && message.hasOwnProperty("lineUpNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lineUpNum);
            return writer;
        };

        /**
         * Encodes the specified SetFightLineUp_Request message, length delimited. Does not implicitly {@link Protocol.SetFightLineUp_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SetFightLineUp_Request
         * @static
         * @param {Protocol.ISetFightLineUp_Request} message SetFightLineUp_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFightLineUp_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetFightLineUp_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SetFightLineUp_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SetFightLineUp_Request} SetFightLineUp_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFightLineUp_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SetFightLineUp_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lineUpNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetFightLineUp_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SetFightLineUp_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SetFightLineUp_Request} SetFightLineUp_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFightLineUp_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetFightLineUp_Request message.
         * @function verify
         * @memberof Protocol.SetFightLineUp_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetFightLineUp_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lineUpNum != null && message.hasOwnProperty("lineUpNum"))
                if (!$util.isInteger(message.lineUpNum))
                    return "lineUpNum: integer expected";
            return null;
        };

        return SetFightLineUp_Request;
    })();

    Protocol.SetFightLineUp_Respond = (function() {

        /**
         * Properties of a SetFightLineUp_Respond.
         * @memberof Protocol
         * @interface ISetFightLineUp_Respond
         * @property {number|null} [lineUpNum] SetFightLineUp_Respond lineUpNum
         */

        /**
         * Constructs a new SetFightLineUp_Respond.
         * @memberof Protocol
         * @classdesc Represents a SetFightLineUp_Respond.
         * @implements ISetFightLineUp_Respond
         * @constructor
         * @param {Protocol.ISetFightLineUp_Respond=} [properties] Properties to set
         */
        function SetFightLineUp_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetFightLineUp_Respond lineUpNum.
         * @member {number} lineUpNum
         * @memberof Protocol.SetFightLineUp_Respond
         * @instance
         */
        SetFightLineUp_Respond.prototype.lineUpNum = 0;

        /**
         * Creates a new SetFightLineUp_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.SetFightLineUp_Respond
         * @static
         * @param {Protocol.ISetFightLineUp_Respond=} [properties] Properties to set
         * @returns {Protocol.SetFightLineUp_Respond} SetFightLineUp_Respond instance
         */
        SetFightLineUp_Respond.create = function create(properties) {
            return new SetFightLineUp_Respond(properties);
        };

        /**
         * Encodes the specified SetFightLineUp_Respond message. Does not implicitly {@link Protocol.SetFightLineUp_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SetFightLineUp_Respond
         * @static
         * @param {Protocol.ISetFightLineUp_Respond} message SetFightLineUp_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFightLineUp_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lineUpNum != null && message.hasOwnProperty("lineUpNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lineUpNum);
            return writer;
        };

        /**
         * Encodes the specified SetFightLineUp_Respond message, length delimited. Does not implicitly {@link Protocol.SetFightLineUp_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SetFightLineUp_Respond
         * @static
         * @param {Protocol.ISetFightLineUp_Respond} message SetFightLineUp_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFightLineUp_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetFightLineUp_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SetFightLineUp_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SetFightLineUp_Respond} SetFightLineUp_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFightLineUp_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SetFightLineUp_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lineUpNum = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetFightLineUp_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SetFightLineUp_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SetFightLineUp_Respond} SetFightLineUp_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFightLineUp_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetFightLineUp_Respond message.
         * @function verify
         * @memberof Protocol.SetFightLineUp_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetFightLineUp_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lineUpNum != null && message.hasOwnProperty("lineUpNum"))
                if (!$util.isInteger(message.lineUpNum))
                    return "lineUpNum: integer expected";
            return null;
        };

        return SetFightLineUp_Respond;
    })();

    Protocol.SetLineUp_Request = (function() {

        /**
         * Properties of a SetLineUp_Request.
         * @memberof Protocol
         * @interface ISetLineUp_Request
         * @property {number|null} [lineUpNum] SetLineUp_Request lineUpNum
         * @property {Array.<number>|null} [heroIds] SetLineUp_Request heroIds
         */

        /**
         * Constructs a new SetLineUp_Request.
         * @memberof Protocol
         * @classdesc Represents a SetLineUp_Request.
         * @implements ISetLineUp_Request
         * @constructor
         * @param {Protocol.ISetLineUp_Request=} [properties] Properties to set
         */
        function SetLineUp_Request(properties) {
            this.heroIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetLineUp_Request lineUpNum.
         * @member {number} lineUpNum
         * @memberof Protocol.SetLineUp_Request
         * @instance
         */
        SetLineUp_Request.prototype.lineUpNum = 0;

        /**
         * SetLineUp_Request heroIds.
         * @member {Array.<number>} heroIds
         * @memberof Protocol.SetLineUp_Request
         * @instance
         */
        SetLineUp_Request.prototype.heroIds = $util.emptyArray;

        /**
         * Creates a new SetLineUp_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.SetLineUp_Request
         * @static
         * @param {Protocol.ISetLineUp_Request=} [properties] Properties to set
         * @returns {Protocol.SetLineUp_Request} SetLineUp_Request instance
         */
        SetLineUp_Request.create = function create(properties) {
            return new SetLineUp_Request(properties);
        };

        /**
         * Encodes the specified SetLineUp_Request message. Does not implicitly {@link Protocol.SetLineUp_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SetLineUp_Request
         * @static
         * @param {Protocol.ISetLineUp_Request} message SetLineUp_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetLineUp_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.lineUpNum != null && message.hasOwnProperty("lineUpNum"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.lineUpNum);
            if (message.heroIds != null && message.heroIds.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.heroIds.length; ++i)
                    writer.int32(message.heroIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified SetLineUp_Request message, length delimited. Does not implicitly {@link Protocol.SetLineUp_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SetLineUp_Request
         * @static
         * @param {Protocol.ISetLineUp_Request} message SetLineUp_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetLineUp_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetLineUp_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SetLineUp_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SetLineUp_Request} SetLineUp_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetLineUp_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SetLineUp_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.lineUpNum = reader.int32();
                    break;
                case 2:
                    if (!(message.heroIds && message.heroIds.length))
                        message.heroIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.heroIds.push(reader.int32());
                    } else
                        message.heroIds.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetLineUp_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SetLineUp_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SetLineUp_Request} SetLineUp_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetLineUp_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetLineUp_Request message.
         * @function verify
         * @memberof Protocol.SetLineUp_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetLineUp_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.lineUpNum != null && message.hasOwnProperty("lineUpNum"))
                if (!$util.isInteger(message.lineUpNum))
                    return "lineUpNum: integer expected";
            if (message.heroIds != null && message.hasOwnProperty("heroIds")) {
                if (!Array.isArray(message.heroIds))
                    return "heroIds: array expected";
                for (var i = 0; i < message.heroIds.length; ++i)
                    if (!$util.isInteger(message.heroIds[i]))
                        return "heroIds: integer[] expected";
            }
            return null;
        };

        return SetLineUp_Request;
    })();

    Protocol.SetLineUp_Respond = (function() {

        /**
         * Properties of a SetLineUp_Respond.
         * @memberof Protocol
         * @interface ISetLineUp_Respond
         * @property {number|null} [ret] SetLineUp_Respond ret
         * @property {number|null} [lineUpNum] SetLineUp_Respond lineUpNum
         * @property {Array.<number>|null} [heroIds] SetLineUp_Respond heroIds
         */

        /**
         * Constructs a new SetLineUp_Respond.
         * @memberof Protocol
         * @classdesc Represents a SetLineUp_Respond.
         * @implements ISetLineUp_Respond
         * @constructor
         * @param {Protocol.ISetLineUp_Respond=} [properties] Properties to set
         */
        function SetLineUp_Respond(properties) {
            this.heroIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetLineUp_Respond ret.
         * @member {number} ret
         * @memberof Protocol.SetLineUp_Respond
         * @instance
         */
        SetLineUp_Respond.prototype.ret = 0;

        /**
         * SetLineUp_Respond lineUpNum.
         * @member {number} lineUpNum
         * @memberof Protocol.SetLineUp_Respond
         * @instance
         */
        SetLineUp_Respond.prototype.lineUpNum = 0;

        /**
         * SetLineUp_Respond heroIds.
         * @member {Array.<number>} heroIds
         * @memberof Protocol.SetLineUp_Respond
         * @instance
         */
        SetLineUp_Respond.prototype.heroIds = $util.emptyArray;

        /**
         * Creates a new SetLineUp_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.SetLineUp_Respond
         * @static
         * @param {Protocol.ISetLineUp_Respond=} [properties] Properties to set
         * @returns {Protocol.SetLineUp_Respond} SetLineUp_Respond instance
         */
        SetLineUp_Respond.create = function create(properties) {
            return new SetLineUp_Respond(properties);
        };

        /**
         * Encodes the specified SetLineUp_Respond message. Does not implicitly {@link Protocol.SetLineUp_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SetLineUp_Respond
         * @static
         * @param {Protocol.ISetLineUp_Respond} message SetLineUp_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetLineUp_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            if (message.lineUpNum != null && message.hasOwnProperty("lineUpNum"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lineUpNum);
            if (message.heroIds != null && message.heroIds.length) {
                writer.uint32(/* id 3, wireType 2 =*/26).fork();
                for (var i = 0; i < message.heroIds.length; ++i)
                    writer.int32(message.heroIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified SetLineUp_Respond message, length delimited. Does not implicitly {@link Protocol.SetLineUp_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SetLineUp_Respond
         * @static
         * @param {Protocol.ISetLineUp_Respond} message SetLineUp_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetLineUp_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetLineUp_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SetLineUp_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SetLineUp_Respond} SetLineUp_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetLineUp_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SetLineUp_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                case 2:
                    message.lineUpNum = reader.int32();
                    break;
                case 3:
                    if (!(message.heroIds && message.heroIds.length))
                        message.heroIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.heroIds.push(reader.int32());
                    } else
                        message.heroIds.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetLineUp_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SetLineUp_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SetLineUp_Respond} SetLineUp_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetLineUp_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetLineUp_Respond message.
         * @function verify
         * @memberof Protocol.SetLineUp_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetLineUp_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.lineUpNum != null && message.hasOwnProperty("lineUpNum"))
                if (!$util.isInteger(message.lineUpNum))
                    return "lineUpNum: integer expected";
            if (message.heroIds != null && message.hasOwnProperty("heroIds")) {
                if (!Array.isArray(message.heroIds))
                    return "heroIds: array expected";
                for (var i = 0; i < message.heroIds.length; ++i)
                    if (!$util.isInteger(message.heroIds[i]))
                        return "heroIds: integer[] expected";
            }
            return null;
        };

        return SetLineUp_Respond;
    })();

    Protocol.GetRankRange_Request = (function() {

        /**
         * Properties of a GetRankRange_Request.
         * @memberof Protocol
         * @interface IGetRankRange_Request
         * @property {number|null} [begin] GetRankRange_Request begin
         * @property {number|null} [end] GetRankRange_Request end
         * @property {number|null} [type] GetRankRange_Request type
         */

        /**
         * Constructs a new GetRankRange_Request.
         * @memberof Protocol
         * @classdesc Represents a GetRankRange_Request.
         * @implements IGetRankRange_Request
         * @constructor
         * @param {Protocol.IGetRankRange_Request=} [properties] Properties to set
         */
        function GetRankRange_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRankRange_Request begin.
         * @member {number} begin
         * @memberof Protocol.GetRankRange_Request
         * @instance
         */
        GetRankRange_Request.prototype.begin = 0;

        /**
         * GetRankRange_Request end.
         * @member {number} end
         * @memberof Protocol.GetRankRange_Request
         * @instance
         */
        GetRankRange_Request.prototype.end = 0;

        /**
         * GetRankRange_Request type.
         * @member {number} type
         * @memberof Protocol.GetRankRange_Request
         * @instance
         */
        GetRankRange_Request.prototype.type = 0;

        /**
         * Creates a new GetRankRange_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.GetRankRange_Request
         * @static
         * @param {Protocol.IGetRankRange_Request=} [properties] Properties to set
         * @returns {Protocol.GetRankRange_Request} GetRankRange_Request instance
         */
        GetRankRange_Request.create = function create(properties) {
            return new GetRankRange_Request(properties);
        };

        /**
         * Encodes the specified GetRankRange_Request message. Does not implicitly {@link Protocol.GetRankRange_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetRankRange_Request
         * @static
         * @param {Protocol.IGetRankRange_Request} message GetRankRange_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankRange_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.begin != null && message.hasOwnProperty("begin"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.begin);
            if (message.end != null && message.hasOwnProperty("end"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified GetRankRange_Request message, length delimited. Does not implicitly {@link Protocol.GetRankRange_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetRankRange_Request
         * @static
         * @param {Protocol.IGetRankRange_Request} message GetRankRange_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankRange_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRankRange_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetRankRange_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetRankRange_Request} GetRankRange_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankRange_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetRankRange_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.begin = reader.int32();
                    break;
                case 2:
                    message.end = reader.int32();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRankRange_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetRankRange_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetRankRange_Request} GetRankRange_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankRange_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRankRange_Request message.
         * @function verify
         * @memberof Protocol.GetRankRange_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRankRange_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.begin != null && message.hasOwnProperty("begin"))
                if (!$util.isInteger(message.begin))
                    return "begin: integer expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (!$util.isInteger(message.end))
                    return "end: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        return GetRankRange_Request;
    })();

    Protocol.GetRankRange_Respond = (function() {

        /**
         * Properties of a GetRankRange_Respond.
         * @memberof Protocol
         * @interface IGetRankRange_Respond
         * @property {number|null} [type] GetRankRange_Respond type
         * @property {Array.<Protocol.IRankInfo>|null} [infos] GetRankRange_Respond infos
         * @property {number|null} [begin] GetRankRange_Respond begin
         * @property {number|null} [end] GetRankRange_Respond end
         */

        /**
         * Constructs a new GetRankRange_Respond.
         * @memberof Protocol
         * @classdesc Represents a GetRankRange_Respond.
         * @implements IGetRankRange_Respond
         * @constructor
         * @param {Protocol.IGetRankRange_Respond=} [properties] Properties to set
         */
        function GetRankRange_Respond(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetRankRange_Respond type.
         * @member {number} type
         * @memberof Protocol.GetRankRange_Respond
         * @instance
         */
        GetRankRange_Respond.prototype.type = 0;

        /**
         * GetRankRange_Respond infos.
         * @member {Array.<Protocol.IRankInfo>} infos
         * @memberof Protocol.GetRankRange_Respond
         * @instance
         */
        GetRankRange_Respond.prototype.infos = $util.emptyArray;

        /**
         * GetRankRange_Respond begin.
         * @member {number} begin
         * @memberof Protocol.GetRankRange_Respond
         * @instance
         */
        GetRankRange_Respond.prototype.begin = 0;

        /**
         * GetRankRange_Respond end.
         * @member {number} end
         * @memberof Protocol.GetRankRange_Respond
         * @instance
         */
        GetRankRange_Respond.prototype.end = 0;

        /**
         * Creates a new GetRankRange_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.GetRankRange_Respond
         * @static
         * @param {Protocol.IGetRankRange_Respond=} [properties] Properties to set
         * @returns {Protocol.GetRankRange_Respond} GetRankRange_Respond instance
         */
        GetRankRange_Respond.create = function create(properties) {
            return new GetRankRange_Respond(properties);
        };

        /**
         * Encodes the specified GetRankRange_Respond message. Does not implicitly {@link Protocol.GetRankRange_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetRankRange_Respond
         * @static
         * @param {Protocol.IGetRankRange_Respond} message GetRankRange_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankRange_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.Protocol.RankInfo.encode(message.infos[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.begin != null && message.hasOwnProperty("begin"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
            if (message.end != null && message.hasOwnProperty("end"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
            return writer;
        };

        /**
         * Encodes the specified GetRankRange_Respond message, length delimited. Does not implicitly {@link Protocol.GetRankRange_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetRankRange_Respond
         * @static
         * @param {Protocol.IGetRankRange_Respond} message GetRankRange_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetRankRange_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetRankRange_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetRankRange_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetRankRange_Respond} GetRankRange_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankRange_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetRankRange_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.Protocol.RankInfo.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.begin = reader.int32();
                    break;
                case 4:
                    message.end = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetRankRange_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetRankRange_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetRankRange_Respond} GetRankRange_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetRankRange_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetRankRange_Respond message.
         * @function verify
         * @memberof Protocol.GetRankRange_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetRankRange_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.Protocol.RankInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.begin != null && message.hasOwnProperty("begin"))
                if (!$util.isInteger(message.begin))
                    return "begin: integer expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (!$util.isInteger(message.end))
                    return "end: integer expected";
            return null;
        };

        return GetRankRange_Respond;
    })();

    Protocol.TaskChange_Respond = (function() {

        /**
         * Properties of a TaskChange_Respond.
         * @memberof Protocol
         * @interface ITaskChange_Respond
         * @property {Array.<Protocol.ITask>|null} [tasks] TaskChange_Respond tasks
         */

        /**
         * Constructs a new TaskChange_Respond.
         * @memberof Protocol
         * @classdesc Represents a TaskChange_Respond.
         * @implements ITaskChange_Respond
         * @constructor
         * @param {Protocol.ITaskChange_Respond=} [properties] Properties to set
         */
        function TaskChange_Respond(properties) {
            this.tasks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TaskChange_Respond tasks.
         * @member {Array.<Protocol.ITask>} tasks
         * @memberof Protocol.TaskChange_Respond
         * @instance
         */
        TaskChange_Respond.prototype.tasks = $util.emptyArray;

        /**
         * Creates a new TaskChange_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.TaskChange_Respond
         * @static
         * @param {Protocol.ITaskChange_Respond=} [properties] Properties to set
         * @returns {Protocol.TaskChange_Respond} TaskChange_Respond instance
         */
        TaskChange_Respond.create = function create(properties) {
            return new TaskChange_Respond(properties);
        };

        /**
         * Encodes the specified TaskChange_Respond message. Does not implicitly {@link Protocol.TaskChange_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.TaskChange_Respond
         * @static
         * @param {Protocol.ITaskChange_Respond} message TaskChange_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskChange_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.tasks != null && message.tasks.length)
                for (var i = 0; i < message.tasks.length; ++i)
                    $root.Protocol.Task.encode(message.tasks[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TaskChange_Respond message, length delimited. Does not implicitly {@link Protocol.TaskChange_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.TaskChange_Respond
         * @static
         * @param {Protocol.ITaskChange_Respond} message TaskChange_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskChange_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskChange_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.TaskChange_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.TaskChange_Respond} TaskChange_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskChange_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.TaskChange_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.tasks && message.tasks.length))
                        message.tasks = [];
                    message.tasks.push($root.Protocol.Task.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskChange_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.TaskChange_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.TaskChange_Respond} TaskChange_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskChange_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskChange_Respond message.
         * @function verify
         * @memberof Protocol.TaskChange_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskChange_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.tasks != null && message.hasOwnProperty("tasks")) {
                if (!Array.isArray(message.tasks))
                    return "tasks: array expected";
                for (var i = 0; i < message.tasks.length; ++i) {
                    var error = $root.Protocol.Task.verify(message.tasks[i]);
                    if (error)
                        return "tasks." + error;
                }
            }
            return null;
        };

        return TaskChange_Respond;
    })();

    Protocol.FinishTask_Request = (function() {

        /**
         * Properties of a FinishTask_Request.
         * @memberof Protocol
         * @interface IFinishTask_Request
         * @property {number|null} [taskIndex] FinishTask_Request taskIndex
         */

        /**
         * Constructs a new FinishTask_Request.
         * @memberof Protocol
         * @classdesc Represents a FinishTask_Request.
         * @implements IFinishTask_Request
         * @constructor
         * @param {Protocol.IFinishTask_Request=} [properties] Properties to set
         */
        function FinishTask_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FinishTask_Request taskIndex.
         * @member {number} taskIndex
         * @memberof Protocol.FinishTask_Request
         * @instance
         */
        FinishTask_Request.prototype.taskIndex = 0;

        /**
         * Creates a new FinishTask_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.FinishTask_Request
         * @static
         * @param {Protocol.IFinishTask_Request=} [properties] Properties to set
         * @returns {Protocol.FinishTask_Request} FinishTask_Request instance
         */
        FinishTask_Request.create = function create(properties) {
            return new FinishTask_Request(properties);
        };

        /**
         * Encodes the specified FinishTask_Request message. Does not implicitly {@link Protocol.FinishTask_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FinishTask_Request
         * @static
         * @param {Protocol.IFinishTask_Request} message FinishTask_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinishTask_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskIndex != null && message.hasOwnProperty("taskIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskIndex);
            return writer;
        };

        /**
         * Encodes the specified FinishTask_Request message, length delimited. Does not implicitly {@link Protocol.FinishTask_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FinishTask_Request
         * @static
         * @param {Protocol.IFinishTask_Request} message FinishTask_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinishTask_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FinishTask_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FinishTask_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FinishTask_Request} FinishTask_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinishTask_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FinishTask_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FinishTask_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FinishTask_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FinishTask_Request} FinishTask_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinishTask_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FinishTask_Request message.
         * @function verify
         * @memberof Protocol.FinishTask_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FinishTask_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskIndex != null && message.hasOwnProperty("taskIndex"))
                if (!$util.isInteger(message.taskIndex))
                    return "taskIndex: integer expected";
            return null;
        };

        return FinishTask_Request;
    })();

    Protocol.RefreshTask_Request = (function() {

        /**
         * Properties of a RefreshTask_Request.
         * @memberof Protocol
         * @interface IRefreshTask_Request
         * @property {number|null} [taskIndex] RefreshTask_Request taskIndex
         */

        /**
         * Constructs a new RefreshTask_Request.
         * @memberof Protocol
         * @classdesc Represents a RefreshTask_Request.
         * @implements IRefreshTask_Request
         * @constructor
         * @param {Protocol.IRefreshTask_Request=} [properties] Properties to set
         */
        function RefreshTask_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RefreshTask_Request taskIndex.
         * @member {number} taskIndex
         * @memberof Protocol.RefreshTask_Request
         * @instance
         */
        RefreshTask_Request.prototype.taskIndex = 0;

        /**
         * Creates a new RefreshTask_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.RefreshTask_Request
         * @static
         * @param {Protocol.IRefreshTask_Request=} [properties] Properties to set
         * @returns {Protocol.RefreshTask_Request} RefreshTask_Request instance
         */
        RefreshTask_Request.create = function create(properties) {
            return new RefreshTask_Request(properties);
        };

        /**
         * Encodes the specified RefreshTask_Request message. Does not implicitly {@link Protocol.RefreshTask_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.RefreshTask_Request
         * @static
         * @param {Protocol.IRefreshTask_Request} message RefreshTask_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshTask_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskIndex != null && message.hasOwnProperty("taskIndex"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskIndex);
            return writer;
        };

        /**
         * Encodes the specified RefreshTask_Request message, length delimited. Does not implicitly {@link Protocol.RefreshTask_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.RefreshTask_Request
         * @static
         * @param {Protocol.IRefreshTask_Request} message RefreshTask_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RefreshTask_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RefreshTask_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.RefreshTask_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.RefreshTask_Request} RefreshTask_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshTask_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.RefreshTask_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskIndex = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RefreshTask_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.RefreshTask_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.RefreshTask_Request} RefreshTask_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RefreshTask_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RefreshTask_Request message.
         * @function verify
         * @memberof Protocol.RefreshTask_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RefreshTask_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskIndex != null && message.hasOwnProperty("taskIndex"))
                if (!$util.isInteger(message.taskIndex))
                    return "taskIndex: integer expected";
            return null;
        };

        return RefreshTask_Request;
    })();

    Protocol.GetLogicTime_Request = (function() {

        /**
         * Properties of a GetLogicTime_Request.
         * @memberof Protocol
         * @interface IGetLogicTime_Request
         */

        /**
         * Constructs a new GetLogicTime_Request.
         * @memberof Protocol
         * @classdesc Represents a GetLogicTime_Request.
         * @implements IGetLogicTime_Request
         * @constructor
         * @param {Protocol.IGetLogicTime_Request=} [properties] Properties to set
         */
        function GetLogicTime_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetLogicTime_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.GetLogicTime_Request
         * @static
         * @param {Protocol.IGetLogicTime_Request=} [properties] Properties to set
         * @returns {Protocol.GetLogicTime_Request} GetLogicTime_Request instance
         */
        GetLogicTime_Request.create = function create(properties) {
            return new GetLogicTime_Request(properties);
        };

        /**
         * Encodes the specified GetLogicTime_Request message. Does not implicitly {@link Protocol.GetLogicTime_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetLogicTime_Request
         * @static
         * @param {Protocol.IGetLogicTime_Request} message GetLogicTime_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLogicTime_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetLogicTime_Request message, length delimited. Does not implicitly {@link Protocol.GetLogicTime_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetLogicTime_Request
         * @static
         * @param {Protocol.IGetLogicTime_Request} message GetLogicTime_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLogicTime_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetLogicTime_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetLogicTime_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetLogicTime_Request} GetLogicTime_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLogicTime_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetLogicTime_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetLogicTime_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetLogicTime_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetLogicTime_Request} GetLogicTime_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLogicTime_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetLogicTime_Request message.
         * @function verify
         * @memberof Protocol.GetLogicTime_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetLogicTime_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GetLogicTime_Request;
    })();

    Protocol.GetLogicTime_Respond = (function() {

        /**
         * Properties of a GetLogicTime_Respond.
         * @memberof Protocol
         * @interface IGetLogicTime_Respond
         * @property {number|Long|null} [time] GetLogicTime_Respond time
         */

        /**
         * Constructs a new GetLogicTime_Respond.
         * @memberof Protocol
         * @classdesc Represents a GetLogicTime_Respond.
         * @implements IGetLogicTime_Respond
         * @constructor
         * @param {Protocol.IGetLogicTime_Respond=} [properties] Properties to set
         */
        function GetLogicTime_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetLogicTime_Respond time.
         * @member {number|Long} time
         * @memberof Protocol.GetLogicTime_Respond
         * @instance
         */
        GetLogicTime_Respond.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new GetLogicTime_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.GetLogicTime_Respond
         * @static
         * @param {Protocol.IGetLogicTime_Respond=} [properties] Properties to set
         * @returns {Protocol.GetLogicTime_Respond} GetLogicTime_Respond instance
         */
        GetLogicTime_Respond.create = function create(properties) {
            return new GetLogicTime_Respond(properties);
        };

        /**
         * Encodes the specified GetLogicTime_Respond message. Does not implicitly {@link Protocol.GetLogicTime_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetLogicTime_Respond
         * @static
         * @param {Protocol.IGetLogicTime_Respond} message GetLogicTime_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLogicTime_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.time);
            return writer;
        };

        /**
         * Encodes the specified GetLogicTime_Respond message, length delimited. Does not implicitly {@link Protocol.GetLogicTime_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetLogicTime_Respond
         * @static
         * @param {Protocol.IGetLogicTime_Respond} message GetLogicTime_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLogicTime_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetLogicTime_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetLogicTime_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetLogicTime_Respond} GetLogicTime_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLogicTime_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetLogicTime_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetLogicTime_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetLogicTime_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetLogicTime_Respond} GetLogicTime_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLogicTime_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetLogicTime_Respond message.
         * @function verify
         * @memberof Protocol.GetLogicTime_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetLogicTime_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            return null;
        };

        return GetLogicTime_Respond;
    })();

    Protocol.PropertyChange_Respond = (function() {

        /**
         * Properties of a PropertyChange_Respond.
         * @memberof Protocol
         * @interface IPropertyChange_Respond
         * @property {Array.<Protocol.IProperty>|null} [pros] PropertyChange_Respond pros
         */

        /**
         * Constructs a new PropertyChange_Respond.
         * @memberof Protocol
         * @classdesc Represents a PropertyChange_Respond.
         * @implements IPropertyChange_Respond
         * @constructor
         * @param {Protocol.IPropertyChange_Respond=} [properties] Properties to set
         */
        function PropertyChange_Respond(properties) {
            this.pros = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * PropertyChange_Respond pros.
         * @member {Array.<Protocol.IProperty>} pros
         * @memberof Protocol.PropertyChange_Respond
         * @instance
         */
        PropertyChange_Respond.prototype.pros = $util.emptyArray;

        /**
         * Creates a new PropertyChange_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.PropertyChange_Respond
         * @static
         * @param {Protocol.IPropertyChange_Respond=} [properties] Properties to set
         * @returns {Protocol.PropertyChange_Respond} PropertyChange_Respond instance
         */
        PropertyChange_Respond.create = function create(properties) {
            return new PropertyChange_Respond(properties);
        };

        /**
         * Encodes the specified PropertyChange_Respond message. Does not implicitly {@link Protocol.PropertyChange_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.PropertyChange_Respond
         * @static
         * @param {Protocol.IPropertyChange_Respond} message PropertyChange_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PropertyChange_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pros != null && message.pros.length)
                for (var i = 0; i < message.pros.length; ++i)
                    $root.Protocol.Property.encode(message.pros[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified PropertyChange_Respond message, length delimited. Does not implicitly {@link Protocol.PropertyChange_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.PropertyChange_Respond
         * @static
         * @param {Protocol.IPropertyChange_Respond} message PropertyChange_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PropertyChange_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PropertyChange_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.PropertyChange_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.PropertyChange_Respond} PropertyChange_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PropertyChange_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.PropertyChange_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.pros && message.pros.length))
                        message.pros = [];
                    message.pros.push($root.Protocol.Property.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PropertyChange_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.PropertyChange_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.PropertyChange_Respond} PropertyChange_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PropertyChange_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PropertyChange_Respond message.
         * @function verify
         * @memberof Protocol.PropertyChange_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PropertyChange_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pros != null && message.hasOwnProperty("pros")) {
                if (!Array.isArray(message.pros))
                    return "pros: array expected";
                for (var i = 0; i < message.pros.length; ++i) {
                    var error = $root.Protocol.Property.verify(message.pros[i]);
                    if (error)
                        return "pros." + error;
                }
            }
            return null;
        };

        return PropertyChange_Respond;
    })();

    Protocol.TaskScopeBoxOpen_Request = (function() {

        /**
         * Properties of a TaskScopeBoxOpen_Request.
         * @memberof Protocol
         * @interface ITaskScopeBoxOpen_Request
         */

        /**
         * Constructs a new TaskScopeBoxOpen_Request.
         * @memberof Protocol
         * @classdesc Represents a TaskScopeBoxOpen_Request.
         * @implements ITaskScopeBoxOpen_Request
         * @constructor
         * @param {Protocol.ITaskScopeBoxOpen_Request=} [properties] Properties to set
         */
        function TaskScopeBoxOpen_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new TaskScopeBoxOpen_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.TaskScopeBoxOpen_Request
         * @static
         * @param {Protocol.ITaskScopeBoxOpen_Request=} [properties] Properties to set
         * @returns {Protocol.TaskScopeBoxOpen_Request} TaskScopeBoxOpen_Request instance
         */
        TaskScopeBoxOpen_Request.create = function create(properties) {
            return new TaskScopeBoxOpen_Request(properties);
        };

        /**
         * Encodes the specified TaskScopeBoxOpen_Request message. Does not implicitly {@link Protocol.TaskScopeBoxOpen_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.TaskScopeBoxOpen_Request
         * @static
         * @param {Protocol.ITaskScopeBoxOpen_Request} message TaskScopeBoxOpen_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskScopeBoxOpen_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified TaskScopeBoxOpen_Request message, length delimited. Does not implicitly {@link Protocol.TaskScopeBoxOpen_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.TaskScopeBoxOpen_Request
         * @static
         * @param {Protocol.ITaskScopeBoxOpen_Request} message TaskScopeBoxOpen_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TaskScopeBoxOpen_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TaskScopeBoxOpen_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.TaskScopeBoxOpen_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.TaskScopeBoxOpen_Request} TaskScopeBoxOpen_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskScopeBoxOpen_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.TaskScopeBoxOpen_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TaskScopeBoxOpen_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.TaskScopeBoxOpen_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.TaskScopeBoxOpen_Request} TaskScopeBoxOpen_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TaskScopeBoxOpen_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TaskScopeBoxOpen_Request message.
         * @function verify
         * @memberof Protocol.TaskScopeBoxOpen_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TaskScopeBoxOpen_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return TaskScopeBoxOpen_Request;
    })();

    Protocol.Reward_Respond = (function() {

        /**
         * Properties of a Reward_Respond.
         * @memberof Protocol
         * @interface IReward_Respond
         * @property {Array.<Protocol.IReward>|null} [rewards] Reward_Respond rewards
         */

        /**
         * Constructs a new Reward_Respond.
         * @memberof Protocol
         * @classdesc Represents a Reward_Respond.
         * @implements IReward_Respond
         * @constructor
         * @param {Protocol.IReward_Respond=} [properties] Properties to set
         */
        function Reward_Respond(properties) {
            this.rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Reward_Respond rewards.
         * @member {Array.<Protocol.IReward>} rewards
         * @memberof Protocol.Reward_Respond
         * @instance
         */
        Reward_Respond.prototype.rewards = $util.emptyArray;

        /**
         * Creates a new Reward_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.Reward_Respond
         * @static
         * @param {Protocol.IReward_Respond=} [properties] Properties to set
         * @returns {Protocol.Reward_Respond} Reward_Respond instance
         */
        Reward_Respond.create = function create(properties) {
            return new Reward_Respond(properties);
        };

        /**
         * Encodes the specified Reward_Respond message. Does not implicitly {@link Protocol.Reward_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Reward_Respond
         * @static
         * @param {Protocol.IReward_Respond} message Reward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Reward_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rewards != null && message.rewards.length)
                for (var i = 0; i < message.rewards.length; ++i)
                    $root.Protocol.Reward.encode(message.rewards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Reward_Respond message, length delimited. Does not implicitly {@link Protocol.Reward_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Reward_Respond
         * @static
         * @param {Protocol.IReward_Respond} message Reward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Reward_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Reward_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Reward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Reward_Respond} Reward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Reward_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Reward_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.rewards && message.rewards.length))
                        message.rewards = [];
                    message.rewards.push($root.Protocol.Reward.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Reward_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Reward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Reward_Respond} Reward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Reward_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Reward_Respond message.
         * @function verify
         * @memberof Protocol.Reward_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Reward_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                if (!Array.isArray(message.rewards))
                    return "rewards: array expected";
                for (var i = 0; i < message.rewards.length; ++i) {
                    var error = $root.Protocol.Reward.verify(message.rewards[i]);
                    if (error)
                        return "rewards." + error;
                }
            }
            return null;
        };

        return Reward_Respond;
    })();

    Protocol.ItemChange_Respond = (function() {

        /**
         * Properties of an ItemChange_Respond.
         * @memberof Protocol
         * @interface IItemChange_Respond
         * @property {Array.<Protocol.IItemInfo>|null} [items] ItemChange_Respond items
         */

        /**
         * Constructs a new ItemChange_Respond.
         * @memberof Protocol
         * @classdesc Represents an ItemChange_Respond.
         * @implements IItemChange_Respond
         * @constructor
         * @param {Protocol.IItemChange_Respond=} [properties] Properties to set
         */
        function ItemChange_Respond(properties) {
            this.items = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ItemChange_Respond items.
         * @member {Array.<Protocol.IItemInfo>} items
         * @memberof Protocol.ItemChange_Respond
         * @instance
         */
        ItemChange_Respond.prototype.items = $util.emptyArray;

        /**
         * Creates a new ItemChange_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.ItemChange_Respond
         * @static
         * @param {Protocol.IItemChange_Respond=} [properties] Properties to set
         * @returns {Protocol.ItemChange_Respond} ItemChange_Respond instance
         */
        ItemChange_Respond.create = function create(properties) {
            return new ItemChange_Respond(properties);
        };

        /**
         * Encodes the specified ItemChange_Respond message. Does not implicitly {@link Protocol.ItemChange_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.ItemChange_Respond
         * @static
         * @param {Protocol.IItemChange_Respond} message ItemChange_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemChange_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.items != null && message.items.length)
                for (var i = 0; i < message.items.length; ++i)
                    $root.Protocol.ItemInfo.encode(message.items[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ItemChange_Respond message, length delimited. Does not implicitly {@link Protocol.ItemChange_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.ItemChange_Respond
         * @static
         * @param {Protocol.IItemChange_Respond} message ItemChange_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ItemChange_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ItemChange_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.ItemChange_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.ItemChange_Respond} ItemChange_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemChange_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.ItemChange_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.items && message.items.length))
                        message.items = [];
                    message.items.push($root.Protocol.ItemInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ItemChange_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.ItemChange_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.ItemChange_Respond} ItemChange_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ItemChange_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ItemChange_Respond message.
         * @function verify
         * @memberof Protocol.ItemChange_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ItemChange_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                if (!Array.isArray(message.items))
                    return "items: array expected";
                for (var i = 0; i < message.items.length; ++i) {
                    var error = $root.Protocol.ItemInfo.verify(message.items[i]);
                    if (error)
                        return "items." + error;
                }
            }
            return null;
        };

        return ItemChange_Respond;
    })();

    Protocol.HeroLevelUp_Request = (function() {

        /**
         * Properties of a HeroLevelUp_Request.
         * @memberof Protocol
         * @interface IHeroLevelUp_Request
         * @property {number|null} [index] HeroLevelUp_Request index
         */

        /**
         * Constructs a new HeroLevelUp_Request.
         * @memberof Protocol
         * @classdesc Represents a HeroLevelUp_Request.
         * @implements IHeroLevelUp_Request
         * @constructor
         * @param {Protocol.IHeroLevelUp_Request=} [properties] Properties to set
         */
        function HeroLevelUp_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroLevelUp_Request index.
         * @member {number} index
         * @memberof Protocol.HeroLevelUp_Request
         * @instance
         */
        HeroLevelUp_Request.prototype.index = 0;

        /**
         * Creates a new HeroLevelUp_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.HeroLevelUp_Request
         * @static
         * @param {Protocol.IHeroLevelUp_Request=} [properties] Properties to set
         * @returns {Protocol.HeroLevelUp_Request} HeroLevelUp_Request instance
         */
        HeroLevelUp_Request.create = function create(properties) {
            return new HeroLevelUp_Request(properties);
        };

        /**
         * Encodes the specified HeroLevelUp_Request message. Does not implicitly {@link Protocol.HeroLevelUp_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.HeroLevelUp_Request
         * @static
         * @param {Protocol.IHeroLevelUp_Request} message HeroLevelUp_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroLevelUp_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified HeroLevelUp_Request message, length delimited. Does not implicitly {@link Protocol.HeroLevelUp_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.HeroLevelUp_Request
         * @static
         * @param {Protocol.IHeroLevelUp_Request} message HeroLevelUp_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroLevelUp_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroLevelUp_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.HeroLevelUp_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.HeroLevelUp_Request} HeroLevelUp_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroLevelUp_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.HeroLevelUp_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroLevelUp_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.HeroLevelUp_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.HeroLevelUp_Request} HeroLevelUp_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroLevelUp_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroLevelUp_Request message.
         * @function verify
         * @memberof Protocol.HeroLevelUp_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroLevelUp_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return HeroLevelUp_Request;
    })();

    Protocol.HeroLevelUp_Respond = (function() {

        /**
         * Properties of a HeroLevelUp_Respond.
         * @memberof Protocol
         * @interface IHeroLevelUp_Respond
         * @property {number|null} [index] HeroLevelUp_Respond index
         * @property {number|null} [level] HeroLevelUp_Respond level
         * @property {number|null} [ret] HeroLevelUp_Respond ret
         * @property {number|null} [count] HeroLevelUp_Respond count
         */

        /**
         * Constructs a new HeroLevelUp_Respond.
         * @memberof Protocol
         * @classdesc Represents a HeroLevelUp_Respond.
         * @implements IHeroLevelUp_Respond
         * @constructor
         * @param {Protocol.IHeroLevelUp_Respond=} [properties] Properties to set
         */
        function HeroLevelUp_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * HeroLevelUp_Respond index.
         * @member {number} index
         * @memberof Protocol.HeroLevelUp_Respond
         * @instance
         */
        HeroLevelUp_Respond.prototype.index = 0;

        /**
         * HeroLevelUp_Respond level.
         * @member {number} level
         * @memberof Protocol.HeroLevelUp_Respond
         * @instance
         */
        HeroLevelUp_Respond.prototype.level = 0;

        /**
         * HeroLevelUp_Respond ret.
         * @member {number} ret
         * @memberof Protocol.HeroLevelUp_Respond
         * @instance
         */
        HeroLevelUp_Respond.prototype.ret = 0;

        /**
         * HeroLevelUp_Respond count.
         * @member {number} count
         * @memberof Protocol.HeroLevelUp_Respond
         * @instance
         */
        HeroLevelUp_Respond.prototype.count = 0;

        /**
         * Creates a new HeroLevelUp_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.HeroLevelUp_Respond
         * @static
         * @param {Protocol.IHeroLevelUp_Respond=} [properties] Properties to set
         * @returns {Protocol.HeroLevelUp_Respond} HeroLevelUp_Respond instance
         */
        HeroLevelUp_Respond.create = function create(properties) {
            return new HeroLevelUp_Respond(properties);
        };

        /**
         * Encodes the specified HeroLevelUp_Respond message. Does not implicitly {@link Protocol.HeroLevelUp_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.HeroLevelUp_Respond
         * @static
         * @param {Protocol.IHeroLevelUp_Respond} message HeroLevelUp_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroLevelUp_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.ret);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified HeroLevelUp_Respond message, length delimited. Does not implicitly {@link Protocol.HeroLevelUp_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.HeroLevelUp_Respond
         * @static
         * @param {Protocol.IHeroLevelUp_Respond} message HeroLevelUp_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        HeroLevelUp_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a HeroLevelUp_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.HeroLevelUp_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.HeroLevelUp_Respond} HeroLevelUp_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroLevelUp_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.HeroLevelUp_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.level = reader.int32();
                    break;
                case 3:
                    message.ret = reader.int32();
                    break;
                case 4:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a HeroLevelUp_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.HeroLevelUp_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.HeroLevelUp_Respond} HeroLevelUp_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        HeroLevelUp_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a HeroLevelUp_Respond message.
         * @function verify
         * @memberof Protocol.HeroLevelUp_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        HeroLevelUp_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        return HeroLevelUp_Respond;
    })();

    Protocol.ErrorNotice_Respond = (function() {

        /**
         * Properties of an ErrorNotice_Respond.
         * @memberof Protocol
         * @interface IErrorNotice_Respond
         * @property {number|null} [errorCode] ErrorNotice_Respond errorCode
         */

        /**
         * Constructs a new ErrorNotice_Respond.
         * @memberof Protocol
         * @classdesc Represents an ErrorNotice_Respond.
         * @implements IErrorNotice_Respond
         * @constructor
         * @param {Protocol.IErrorNotice_Respond=} [properties] Properties to set
         */
        function ErrorNotice_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ErrorNotice_Respond errorCode.
         * @member {number} errorCode
         * @memberof Protocol.ErrorNotice_Respond
         * @instance
         */
        ErrorNotice_Respond.prototype.errorCode = 0;

        /**
         * Creates a new ErrorNotice_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.ErrorNotice_Respond
         * @static
         * @param {Protocol.IErrorNotice_Respond=} [properties] Properties to set
         * @returns {Protocol.ErrorNotice_Respond} ErrorNotice_Respond instance
         */
        ErrorNotice_Respond.create = function create(properties) {
            return new ErrorNotice_Respond(properties);
        };

        /**
         * Encodes the specified ErrorNotice_Respond message. Does not implicitly {@link Protocol.ErrorNotice_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.ErrorNotice_Respond
         * @static
         * @param {Protocol.IErrorNotice_Respond} message ErrorNotice_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ErrorNotice_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errorCode);
            return writer;
        };

        /**
         * Encodes the specified ErrorNotice_Respond message, length delimited. Does not implicitly {@link Protocol.ErrorNotice_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.ErrorNotice_Respond
         * @static
         * @param {Protocol.IErrorNotice_Respond} message ErrorNotice_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ErrorNotice_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ErrorNotice_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.ErrorNotice_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.ErrorNotice_Respond} ErrorNotice_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ErrorNotice_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.ErrorNotice_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.errorCode = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ErrorNotice_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.ErrorNotice_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.ErrorNotice_Respond} ErrorNotice_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ErrorNotice_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ErrorNotice_Respond message.
         * @function verify
         * @memberof Protocol.ErrorNotice_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ErrorNotice_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errorCode != null && message.hasOwnProperty("errorCode"))
                if (!$util.isInteger(message.errorCode))
                    return "errorCode: integer expected";
            return null;
        };

        return ErrorNotice_Respond;
    })();

    Protocol.SkillLevelUp_Request = (function() {

        /**
         * Properties of a SkillLevelUp_Request.
         * @memberof Protocol
         * @interface ISkillLevelUp_Request
         * @property {string|null} [heroId] SkillLevelUp_Request heroId
         * @property {number|null} [index] SkillLevelUp_Request index
         */

        /**
         * Constructs a new SkillLevelUp_Request.
         * @memberof Protocol
         * @classdesc Represents a SkillLevelUp_Request.
         * @implements ISkillLevelUp_Request
         * @constructor
         * @param {Protocol.ISkillLevelUp_Request=} [properties] Properties to set
         */
        function SkillLevelUp_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SkillLevelUp_Request heroId.
         * @member {string} heroId
         * @memberof Protocol.SkillLevelUp_Request
         * @instance
         */
        SkillLevelUp_Request.prototype.heroId = "";

        /**
         * SkillLevelUp_Request index.
         * @member {number} index
         * @memberof Protocol.SkillLevelUp_Request
         * @instance
         */
        SkillLevelUp_Request.prototype.index = 0;

        /**
         * Creates a new SkillLevelUp_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.SkillLevelUp_Request
         * @static
         * @param {Protocol.ISkillLevelUp_Request=} [properties] Properties to set
         * @returns {Protocol.SkillLevelUp_Request} SkillLevelUp_Request instance
         */
        SkillLevelUp_Request.create = function create(properties) {
            return new SkillLevelUp_Request(properties);
        };

        /**
         * Encodes the specified SkillLevelUp_Request message. Does not implicitly {@link Protocol.SkillLevelUp_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SkillLevelUp_Request
         * @static
         * @param {Protocol.ISkillLevelUp_Request} message SkillLevelUp_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkillLevelUp_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.heroId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified SkillLevelUp_Request message, length delimited. Does not implicitly {@link Protocol.SkillLevelUp_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SkillLevelUp_Request
         * @static
         * @param {Protocol.ISkillLevelUp_Request} message SkillLevelUp_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkillLevelUp_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SkillLevelUp_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SkillLevelUp_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SkillLevelUp_Request} SkillLevelUp_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillLevelUp_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SkillLevelUp_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroId = reader.string();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SkillLevelUp_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SkillLevelUp_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SkillLevelUp_Request} SkillLevelUp_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillLevelUp_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SkillLevelUp_Request message.
         * @function verify
         * @memberof Protocol.SkillLevelUp_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SkillLevelUp_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isString(message.heroId))
                    return "heroId: string expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return SkillLevelUp_Request;
    })();

    Protocol.SkillLevelUp_Respond = (function() {

        /**
         * Properties of a SkillLevelUp_Respond.
         * @memberof Protocol
         * @interface ISkillLevelUp_Respond
         * @property {string|null} [heroId] SkillLevelUp_Respond heroId
         * @property {number|null} [index] SkillLevelUp_Respond index
         * @property {number|null} [level] SkillLevelUp_Respond level
         * @property {number|null} [ret] SkillLevelUp_Respond ret
         */

        /**
         * Constructs a new SkillLevelUp_Respond.
         * @memberof Protocol
         * @classdesc Represents a SkillLevelUp_Respond.
         * @implements ISkillLevelUp_Respond
         * @constructor
         * @param {Protocol.ISkillLevelUp_Respond=} [properties] Properties to set
         */
        function SkillLevelUp_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SkillLevelUp_Respond heroId.
         * @member {string} heroId
         * @memberof Protocol.SkillLevelUp_Respond
         * @instance
         */
        SkillLevelUp_Respond.prototype.heroId = "";

        /**
         * SkillLevelUp_Respond index.
         * @member {number} index
         * @memberof Protocol.SkillLevelUp_Respond
         * @instance
         */
        SkillLevelUp_Respond.prototype.index = 0;

        /**
         * SkillLevelUp_Respond level.
         * @member {number} level
         * @memberof Protocol.SkillLevelUp_Respond
         * @instance
         */
        SkillLevelUp_Respond.prototype.level = 0;

        /**
         * SkillLevelUp_Respond ret.
         * @member {number} ret
         * @memberof Protocol.SkillLevelUp_Respond
         * @instance
         */
        SkillLevelUp_Respond.prototype.ret = 0;

        /**
         * Creates a new SkillLevelUp_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.SkillLevelUp_Respond
         * @static
         * @param {Protocol.ISkillLevelUp_Respond=} [properties] Properties to set
         * @returns {Protocol.SkillLevelUp_Respond} SkillLevelUp_Respond instance
         */
        SkillLevelUp_Respond.create = function create(properties) {
            return new SkillLevelUp_Respond(properties);
        };

        /**
         * Encodes the specified SkillLevelUp_Respond message. Does not implicitly {@link Protocol.SkillLevelUp_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SkillLevelUp_Respond
         * @static
         * @param {Protocol.ISkillLevelUp_Respond} message SkillLevelUp_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkillLevelUp_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.heroId);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified SkillLevelUp_Respond message, length delimited. Does not implicitly {@link Protocol.SkillLevelUp_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SkillLevelUp_Respond
         * @static
         * @param {Protocol.ISkillLevelUp_Respond} message SkillLevelUp_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SkillLevelUp_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SkillLevelUp_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SkillLevelUp_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SkillLevelUp_Respond} SkillLevelUp_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillLevelUp_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SkillLevelUp_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.heroId = reader.string();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                case 3:
                    message.level = reader.int32();
                    break;
                case 4:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SkillLevelUp_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SkillLevelUp_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SkillLevelUp_Respond} SkillLevelUp_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SkillLevelUp_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SkillLevelUp_Respond message.
         * @function verify
         * @memberof Protocol.SkillLevelUp_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SkillLevelUp_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.heroId != null && message.hasOwnProperty("heroId"))
                if (!$util.isString(message.heroId))
                    return "heroId: string expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return SkillLevelUp_Respond;
    })();

    Protocol.AddHero_Respond = (function() {

        /**
         * Properties of an AddHero_Respond.
         * @memberof Protocol
         * @interface IAddHero_Respond
         * @property {Protocol.IHero|null} [hero] AddHero_Respond hero
         */

        /**
         * Constructs a new AddHero_Respond.
         * @memberof Protocol
         * @classdesc Represents an AddHero_Respond.
         * @implements IAddHero_Respond
         * @constructor
         * @param {Protocol.IAddHero_Respond=} [properties] Properties to set
         */
        function AddHero_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddHero_Respond hero.
         * @member {Protocol.IHero|null|undefined} hero
         * @memberof Protocol.AddHero_Respond
         * @instance
         */
        AddHero_Respond.prototype.hero = null;

        /**
         * Creates a new AddHero_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AddHero_Respond
         * @static
         * @param {Protocol.IAddHero_Respond=} [properties] Properties to set
         * @returns {Protocol.AddHero_Respond} AddHero_Respond instance
         */
        AddHero_Respond.create = function create(properties) {
            return new AddHero_Respond(properties);
        };

        /**
         * Encodes the specified AddHero_Respond message. Does not implicitly {@link Protocol.AddHero_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AddHero_Respond
         * @static
         * @param {Protocol.IAddHero_Respond} message AddHero_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddHero_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hero != null && message.hasOwnProperty("hero"))
                $root.Protocol.Hero.encode(message.hero, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AddHero_Respond message, length delimited. Does not implicitly {@link Protocol.AddHero_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AddHero_Respond
         * @static
         * @param {Protocol.IAddHero_Respond} message AddHero_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddHero_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddHero_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AddHero_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AddHero_Respond} AddHero_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddHero_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AddHero_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hero = $root.Protocol.Hero.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddHero_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AddHero_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AddHero_Respond} AddHero_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddHero_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddHero_Respond message.
         * @function verify
         * @memberof Protocol.AddHero_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddHero_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hero != null && message.hasOwnProperty("hero")) {
                var error = $root.Protocol.Hero.verify(message.hero);
                if (error)
                    return "hero." + error;
            }
            return null;
        };

        return AddHero_Respond;
    })();

    Protocol.FriendChat_Request = (function() {

        /**
         * Properties of a FriendChat_Request.
         * @memberof Protocol
         * @interface IFriendChat_Request
         * @property {string|null} [content] FriendChat_Request content
         * @property {number|Long|null} [roleId] FriendChat_Request roleId
         * @property {number|null} [type] FriendChat_Request type
         */

        /**
         * Constructs a new FriendChat_Request.
         * @memberof Protocol
         * @classdesc Represents a FriendChat_Request.
         * @implements IFriendChat_Request
         * @constructor
         * @param {Protocol.IFriendChat_Request=} [properties] Properties to set
         */
        function FriendChat_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendChat_Request content.
         * @member {string} content
         * @memberof Protocol.FriendChat_Request
         * @instance
         */
        FriendChat_Request.prototype.content = "";

        /**
         * FriendChat_Request roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.FriendChat_Request
         * @instance
         */
        FriendChat_Request.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FriendChat_Request type.
         * @member {number} type
         * @memberof Protocol.FriendChat_Request
         * @instance
         */
        FriendChat_Request.prototype.type = 0;

        /**
         * Creates a new FriendChat_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.FriendChat_Request
         * @static
         * @param {Protocol.IFriendChat_Request=} [properties] Properties to set
         * @returns {Protocol.FriendChat_Request} FriendChat_Request instance
         */
        FriendChat_Request.create = function create(properties) {
            return new FriendChat_Request(properties);
        };

        /**
         * Encodes the specified FriendChat_Request message. Does not implicitly {@link Protocol.FriendChat_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FriendChat_Request
         * @static
         * @param {Protocol.IFriendChat_Request} message FriendChat_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendChat_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roleId);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified FriendChat_Request message, length delimited. Does not implicitly {@link Protocol.FriendChat_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FriendChat_Request
         * @static
         * @param {Protocol.IFriendChat_Request} message FriendChat_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendChat_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendChat_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FriendChat_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FriendChat_Request} FriendChat_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendChat_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FriendChat_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.content = reader.string();
                    break;
                case 2:
                    message.roleId = reader.int64();
                    break;
                case 3:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendChat_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FriendChat_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FriendChat_Request} FriendChat_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendChat_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendChat_Request message.
         * @function verify
         * @memberof Protocol.FriendChat_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendChat_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        return FriendChat_Request;
    })();

    Protocol.FriendChat_Respond = (function() {

        /**
         * Properties of a FriendChat_Respond.
         * @memberof Protocol
         * @interface IFriendChat_Respond
         * @property {Protocol.IChat|null} [msg] FriendChat_Respond msg
         */

        /**
         * Constructs a new FriendChat_Respond.
         * @memberof Protocol
         * @classdesc Represents a FriendChat_Respond.
         * @implements IFriendChat_Respond
         * @constructor
         * @param {Protocol.IFriendChat_Respond=} [properties] Properties to set
         */
        function FriendChat_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendChat_Respond msg.
         * @member {Protocol.IChat|null|undefined} msg
         * @memberof Protocol.FriendChat_Respond
         * @instance
         */
        FriendChat_Respond.prototype.msg = null;

        /**
         * Creates a new FriendChat_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.FriendChat_Respond
         * @static
         * @param {Protocol.IFriendChat_Respond=} [properties] Properties to set
         * @returns {Protocol.FriendChat_Respond} FriendChat_Respond instance
         */
        FriendChat_Respond.create = function create(properties) {
            return new FriendChat_Respond(properties);
        };

        /**
         * Encodes the specified FriendChat_Respond message. Does not implicitly {@link Protocol.FriendChat_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FriendChat_Respond
         * @static
         * @param {Protocol.IFriendChat_Respond} message FriendChat_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendChat_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.msg != null && message.hasOwnProperty("msg"))
                $root.Protocol.Chat.encode(message.msg, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FriendChat_Respond message, length delimited. Does not implicitly {@link Protocol.FriendChat_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FriendChat_Respond
         * @static
         * @param {Protocol.IFriendChat_Respond} message FriendChat_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendChat_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendChat_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FriendChat_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FriendChat_Respond} FriendChat_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendChat_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FriendChat_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.msg = $root.Protocol.Chat.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendChat_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FriendChat_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FriendChat_Respond} FriendChat_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendChat_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendChat_Respond message.
         * @function verify
         * @memberof Protocol.FriendChat_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendChat_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.msg != null && message.hasOwnProperty("msg")) {
                var error = $root.Protocol.Chat.verify(message.msg);
                if (error)
                    return "msg." + error;
            }
            return null;
        };

        return FriendChat_Respond;
    })();

    Protocol.InviteFriend_Request = (function() {

        /**
         * Properties of an InviteFriend_Request.
         * @memberof Protocol
         * @interface IInviteFriend_Request
         * @property {number|Long|null} [roleId] InviteFriend_Request roleId
         * @property {number|null} [serverId] InviteFriend_Request serverId
         */

        /**
         * Constructs a new InviteFriend_Request.
         * @memberof Protocol
         * @classdesc Represents an InviteFriend_Request.
         * @implements IInviteFriend_Request
         * @constructor
         * @param {Protocol.IInviteFriend_Request=} [properties] Properties to set
         */
        function InviteFriend_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InviteFriend_Request roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.InviteFriend_Request
         * @instance
         */
        InviteFriend_Request.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * InviteFriend_Request serverId.
         * @member {number} serverId
         * @memberof Protocol.InviteFriend_Request
         * @instance
         */
        InviteFriend_Request.prototype.serverId = 0;

        /**
         * Creates a new InviteFriend_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.InviteFriend_Request
         * @static
         * @param {Protocol.IInviteFriend_Request=} [properties] Properties to set
         * @returns {Protocol.InviteFriend_Request} InviteFriend_Request instance
         */
        InviteFriend_Request.create = function create(properties) {
            return new InviteFriend_Request(properties);
        };

        /**
         * Encodes the specified InviteFriend_Request message. Does not implicitly {@link Protocol.InviteFriend_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.InviteFriend_Request
         * @static
         * @param {Protocol.IInviteFriend_Request} message InviteFriend_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteFriend_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.serverId);
            return writer;
        };

        /**
         * Encodes the specified InviteFriend_Request message, length delimited. Does not implicitly {@link Protocol.InviteFriend_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.InviteFriend_Request
         * @static
         * @param {Protocol.IInviteFriend_Request} message InviteFriend_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteFriend_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InviteFriend_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.InviteFriend_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.InviteFriend_Request} InviteFriend_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteFriend_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.InviteFriend_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.serverId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InviteFriend_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.InviteFriend_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.InviteFriend_Request} InviteFriend_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteFriend_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InviteFriend_Request message.
         * @function verify
         * @memberof Protocol.InviteFriend_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InviteFriend_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            return null;
        };

        return InviteFriend_Request;
    })();

    Protocol.InviteFriend_Respond = (function() {

        /**
         * Properties of an InviteFriend_Respond.
         * @memberof Protocol
         * @interface IInviteFriend_Respond
         * @property {Protocol.IInvite|null} [from] InviteFriend_Respond from
         */

        /**
         * Constructs a new InviteFriend_Respond.
         * @memberof Protocol
         * @classdesc Represents an InviteFriend_Respond.
         * @implements IInviteFriend_Respond
         * @constructor
         * @param {Protocol.IInviteFriend_Respond=} [properties] Properties to set
         */
        function InviteFriend_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * InviteFriend_Respond from.
         * @member {Protocol.IInvite|null|undefined} from
         * @memberof Protocol.InviteFriend_Respond
         * @instance
         */
        InviteFriend_Respond.prototype.from = null;

        /**
         * Creates a new InviteFriend_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.InviteFriend_Respond
         * @static
         * @param {Protocol.IInviteFriend_Respond=} [properties] Properties to set
         * @returns {Protocol.InviteFriend_Respond} InviteFriend_Respond instance
         */
        InviteFriend_Respond.create = function create(properties) {
            return new InviteFriend_Respond(properties);
        };

        /**
         * Encodes the specified InviteFriend_Respond message. Does not implicitly {@link Protocol.InviteFriend_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.InviteFriend_Respond
         * @static
         * @param {Protocol.IInviteFriend_Respond} message InviteFriend_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteFriend_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && message.hasOwnProperty("from"))
                $root.Protocol.Invite.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified InviteFriend_Respond message, length delimited. Does not implicitly {@link Protocol.InviteFriend_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.InviteFriend_Respond
         * @static
         * @param {Protocol.IInviteFriend_Respond} message InviteFriend_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        InviteFriend_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an InviteFriend_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.InviteFriend_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.InviteFriend_Respond} InviteFriend_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteFriend_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.InviteFriend_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.Protocol.Invite.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an InviteFriend_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.InviteFriend_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.InviteFriend_Respond} InviteFriend_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        InviteFriend_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an InviteFriend_Respond message.
         * @function verify
         * @memberof Protocol.InviteFriend_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        InviteFriend_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.Protocol.Invite.verify(message.from);
                if (error)
                    return "from." + error;
            }
            return null;
        };

        return InviteFriend_Respond;
    })();

    Protocol.AcceptFriend_Request = (function() {

        /**
         * Properties of an AcceptFriend_Request.
         * @memberof Protocol
         * @interface IAcceptFriend_Request
         * @property {number|Long|null} [roleId] AcceptFriend_Request roleId
         * @property {boolean|null} [isAccept] AcceptFriend_Request isAccept
         */

        /**
         * Constructs a new AcceptFriend_Request.
         * @memberof Protocol
         * @classdesc Represents an AcceptFriend_Request.
         * @implements IAcceptFriend_Request
         * @constructor
         * @param {Protocol.IAcceptFriend_Request=} [properties] Properties to set
         */
        function AcceptFriend_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AcceptFriend_Request roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.AcceptFriend_Request
         * @instance
         */
        AcceptFriend_Request.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AcceptFriend_Request isAccept.
         * @member {boolean} isAccept
         * @memberof Protocol.AcceptFriend_Request
         * @instance
         */
        AcceptFriend_Request.prototype.isAccept = false;

        /**
         * Creates a new AcceptFriend_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.AcceptFriend_Request
         * @static
         * @param {Protocol.IAcceptFriend_Request=} [properties] Properties to set
         * @returns {Protocol.AcceptFriend_Request} AcceptFriend_Request instance
         */
        AcceptFriend_Request.create = function create(properties) {
            return new AcceptFriend_Request(properties);
        };

        /**
         * Encodes the specified AcceptFriend_Request message. Does not implicitly {@link Protocol.AcceptFriend_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AcceptFriend_Request
         * @static
         * @param {Protocol.IAcceptFriend_Request} message AcceptFriend_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptFriend_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.isAccept != null && message.hasOwnProperty("isAccept"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isAccept);
            return writer;
        };

        /**
         * Encodes the specified AcceptFriend_Request message, length delimited. Does not implicitly {@link Protocol.AcceptFriend_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AcceptFriend_Request
         * @static
         * @param {Protocol.IAcceptFriend_Request} message AcceptFriend_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptFriend_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AcceptFriend_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AcceptFriend_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AcceptFriend_Request} AcceptFriend_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptFriend_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AcceptFriend_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.isAccept = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AcceptFriend_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AcceptFriend_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AcceptFriend_Request} AcceptFriend_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptFriend_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AcceptFriend_Request message.
         * @function verify
         * @memberof Protocol.AcceptFriend_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AcceptFriend_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.isAccept != null && message.hasOwnProperty("isAccept"))
                if (typeof message.isAccept !== "boolean")
                    return "isAccept: boolean expected";
            return null;
        };

        return AcceptFriend_Request;
    })();

    Protocol.AddFriend_Respond = (function() {

        /**
         * Properties of an AddFriend_Respond.
         * @memberof Protocol
         * @interface IAddFriend_Respond
         * @property {Protocol.IFriend|null} [newFd] AddFriend_Respond newFd
         */

        /**
         * Constructs a new AddFriend_Respond.
         * @memberof Protocol
         * @classdesc Represents an AddFriend_Respond.
         * @implements IAddFriend_Respond
         * @constructor
         * @param {Protocol.IAddFriend_Respond=} [properties] Properties to set
         */
        function AddFriend_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AddFriend_Respond newFd.
         * @member {Protocol.IFriend|null|undefined} newFd
         * @memberof Protocol.AddFriend_Respond
         * @instance
         */
        AddFriend_Respond.prototype.newFd = null;

        /**
         * Creates a new AddFriend_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AddFriend_Respond
         * @static
         * @param {Protocol.IAddFriend_Respond=} [properties] Properties to set
         * @returns {Protocol.AddFriend_Respond} AddFriend_Respond instance
         */
        AddFriend_Respond.create = function create(properties) {
            return new AddFriend_Respond(properties);
        };

        /**
         * Encodes the specified AddFriend_Respond message. Does not implicitly {@link Protocol.AddFriend_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AddFriend_Respond
         * @static
         * @param {Protocol.IAddFriend_Respond} message AddFriend_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddFriend_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.newFd != null && message.hasOwnProperty("newFd"))
                $root.Protocol.Friend.encode(message.newFd, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AddFriend_Respond message, length delimited. Does not implicitly {@link Protocol.AddFriend_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AddFriend_Respond
         * @static
         * @param {Protocol.IAddFriend_Respond} message AddFriend_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AddFriend_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AddFriend_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AddFriend_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AddFriend_Respond} AddFriend_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddFriend_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AddFriend_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.newFd = $root.Protocol.Friend.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AddFriend_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AddFriend_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AddFriend_Respond} AddFriend_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AddFriend_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AddFriend_Respond message.
         * @function verify
         * @memberof Protocol.AddFriend_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AddFriend_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.newFd != null && message.hasOwnProperty("newFd")) {
                var error = $root.Protocol.Friend.verify(message.newFd);
                if (error)
                    return "newFd." + error;
            }
            return null;
        };

        return AddFriend_Respond;
    })();

    Protocol.AskFrinedList_Request = (function() {

        /**
         * Properties of an AskFrinedList_Request.
         * @memberof Protocol
         * @interface IAskFrinedList_Request
         */

        /**
         * Constructs a new AskFrinedList_Request.
         * @memberof Protocol
         * @classdesc Represents an AskFrinedList_Request.
         * @implements IAskFrinedList_Request
         * @constructor
         * @param {Protocol.IAskFrinedList_Request=} [properties] Properties to set
         */
        function AskFrinedList_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AskFrinedList_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.AskFrinedList_Request
         * @static
         * @param {Protocol.IAskFrinedList_Request=} [properties] Properties to set
         * @returns {Protocol.AskFrinedList_Request} AskFrinedList_Request instance
         */
        AskFrinedList_Request.create = function create(properties) {
            return new AskFrinedList_Request(properties);
        };

        /**
         * Encodes the specified AskFrinedList_Request message. Does not implicitly {@link Protocol.AskFrinedList_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AskFrinedList_Request
         * @static
         * @param {Protocol.IAskFrinedList_Request} message AskFrinedList_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFrinedList_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AskFrinedList_Request message, length delimited. Does not implicitly {@link Protocol.AskFrinedList_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AskFrinedList_Request
         * @static
         * @param {Protocol.IAskFrinedList_Request} message AskFrinedList_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFrinedList_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AskFrinedList_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AskFrinedList_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AskFrinedList_Request} AskFrinedList_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFrinedList_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AskFrinedList_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AskFrinedList_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AskFrinedList_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AskFrinedList_Request} AskFrinedList_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFrinedList_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AskFrinedList_Request message.
         * @function verify
         * @memberof Protocol.AskFrinedList_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AskFrinedList_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AskFrinedList_Request;
    })();

    Protocol.AskFriendList_Respond = (function() {

        /**
         * Properties of an AskFriendList_Respond.
         * @memberof Protocol
         * @interface IAskFriendList_Respond
         * @property {Array.<Protocol.IFriend>|null} [friends] AskFriendList_Respond friends
         */

        /**
         * Constructs a new AskFriendList_Respond.
         * @memberof Protocol
         * @classdesc Represents an AskFriendList_Respond.
         * @implements IAskFriendList_Respond
         * @constructor
         * @param {Protocol.IAskFriendList_Respond=} [properties] Properties to set
         */
        function AskFriendList_Respond(properties) {
            this.friends = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AskFriendList_Respond friends.
         * @member {Array.<Protocol.IFriend>} friends
         * @memberof Protocol.AskFriendList_Respond
         * @instance
         */
        AskFriendList_Respond.prototype.friends = $util.emptyArray;

        /**
         * Creates a new AskFriendList_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AskFriendList_Respond
         * @static
         * @param {Protocol.IAskFriendList_Respond=} [properties] Properties to set
         * @returns {Protocol.AskFriendList_Respond} AskFriendList_Respond instance
         */
        AskFriendList_Respond.create = function create(properties) {
            return new AskFriendList_Respond(properties);
        };

        /**
         * Encodes the specified AskFriendList_Respond message. Does not implicitly {@link Protocol.AskFriendList_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AskFriendList_Respond
         * @static
         * @param {Protocol.IAskFriendList_Respond} message AskFriendList_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFriendList_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.friends != null && message.friends.length)
                for (var i = 0; i < message.friends.length; ++i)
                    $root.Protocol.Friend.encode(message.friends[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AskFriendList_Respond message, length delimited. Does not implicitly {@link Protocol.AskFriendList_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AskFriendList_Respond
         * @static
         * @param {Protocol.IAskFriendList_Respond} message AskFriendList_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFriendList_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AskFriendList_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AskFriendList_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AskFriendList_Respond} AskFriendList_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFriendList_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AskFriendList_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.friends && message.friends.length))
                        message.friends = [];
                    message.friends.push($root.Protocol.Friend.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AskFriendList_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AskFriendList_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AskFriendList_Respond} AskFriendList_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFriendList_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AskFriendList_Respond message.
         * @function verify
         * @memberof Protocol.AskFriendList_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AskFriendList_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.friends != null && message.hasOwnProperty("friends")) {
                if (!Array.isArray(message.friends))
                    return "friends: array expected";
                for (var i = 0; i < message.friends.length; ++i) {
                    var error = $root.Protocol.Friend.verify(message.friends[i]);
                    if (error)
                        return "friends." + error;
                }
            }
            return null;
        };

        return AskFriendList_Respond;
    })();

    Protocol.AllFriends_Request = (function() {

        /**
         * Properties of an AllFriends_Request.
         * @memberof Protocol
         * @interface IAllFriends_Request
         */

        /**
         * Constructs a new AllFriends_Request.
         * @memberof Protocol
         * @classdesc Represents an AllFriends_Request.
         * @implements IAllFriends_Request
         * @constructor
         * @param {Protocol.IAllFriends_Request=} [properties] Properties to set
         */
        function AllFriends_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AllFriends_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.AllFriends_Request
         * @static
         * @param {Protocol.IAllFriends_Request=} [properties] Properties to set
         * @returns {Protocol.AllFriends_Request} AllFriends_Request instance
         */
        AllFriends_Request.create = function create(properties) {
            return new AllFriends_Request(properties);
        };

        /**
         * Encodes the specified AllFriends_Request message. Does not implicitly {@link Protocol.AllFriends_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AllFriends_Request
         * @static
         * @param {Protocol.IAllFriends_Request} message AllFriends_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllFriends_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AllFriends_Request message, length delimited. Does not implicitly {@link Protocol.AllFriends_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AllFriends_Request
         * @static
         * @param {Protocol.IAllFriends_Request} message AllFriends_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllFriends_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllFriends_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AllFriends_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AllFriends_Request} AllFriends_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllFriends_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AllFriends_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllFriends_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AllFriends_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AllFriends_Request} AllFriends_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllFriends_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllFriends_Request message.
         * @function verify
         * @memberof Protocol.AllFriends_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllFriends_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AllFriends_Request;
    })();

    Protocol.AllFriends_Respond = (function() {

        /**
         * Properties of an AllFriends_Respond.
         * @memberof Protocol
         * @interface IAllFriends_Respond
         * @property {Array.<Protocol.IFriend>|null} [friends] AllFriends_Respond friends
         */

        /**
         * Constructs a new AllFriends_Respond.
         * @memberof Protocol
         * @classdesc Represents an AllFriends_Respond.
         * @implements IAllFriends_Respond
         * @constructor
         * @param {Protocol.IAllFriends_Respond=} [properties] Properties to set
         */
        function AllFriends_Respond(properties) {
            this.friends = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AllFriends_Respond friends.
         * @member {Array.<Protocol.IFriend>} friends
         * @memberof Protocol.AllFriends_Respond
         * @instance
         */
        AllFriends_Respond.prototype.friends = $util.emptyArray;

        /**
         * Creates a new AllFriends_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AllFriends_Respond
         * @static
         * @param {Protocol.IAllFriends_Respond=} [properties] Properties to set
         * @returns {Protocol.AllFriends_Respond} AllFriends_Respond instance
         */
        AllFriends_Respond.create = function create(properties) {
            return new AllFriends_Respond(properties);
        };

        /**
         * Encodes the specified AllFriends_Respond message. Does not implicitly {@link Protocol.AllFriends_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AllFriends_Respond
         * @static
         * @param {Protocol.IAllFriends_Respond} message AllFriends_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllFriends_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.friends != null && message.friends.length)
                for (var i = 0; i < message.friends.length; ++i)
                    $root.Protocol.Friend.encode(message.friends[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AllFriends_Respond message, length delimited. Does not implicitly {@link Protocol.AllFriends_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AllFriends_Respond
         * @static
         * @param {Protocol.IAllFriends_Respond} message AllFriends_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllFriends_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllFriends_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AllFriends_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AllFriends_Respond} AllFriends_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllFriends_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AllFriends_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.friends && message.friends.length))
                        message.friends = [];
                    message.friends.push($root.Protocol.Friend.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllFriends_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AllFriends_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AllFriends_Respond} AllFriends_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllFriends_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllFriends_Respond message.
         * @function verify
         * @memberof Protocol.AllFriends_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllFriends_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.friends != null && message.hasOwnProperty("friends")) {
                if (!Array.isArray(message.friends))
                    return "friends: array expected";
                for (var i = 0; i < message.friends.length; ++i) {
                    var error = $root.Protocol.Friend.verify(message.friends[i]);
                    if (error)
                        return "friends." + error;
                }
            }
            return null;
        };

        return AllFriends_Respond;
    })();

    Protocol.AllInvite_Request = (function() {

        /**
         * Properties of an AllInvite_Request.
         * @memberof Protocol
         * @interface IAllInvite_Request
         */

        /**
         * Constructs a new AllInvite_Request.
         * @memberof Protocol
         * @classdesc Represents an AllInvite_Request.
         * @implements IAllInvite_Request
         * @constructor
         * @param {Protocol.IAllInvite_Request=} [properties] Properties to set
         */
        function AllInvite_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AllInvite_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.AllInvite_Request
         * @static
         * @param {Protocol.IAllInvite_Request=} [properties] Properties to set
         * @returns {Protocol.AllInvite_Request} AllInvite_Request instance
         */
        AllInvite_Request.create = function create(properties) {
            return new AllInvite_Request(properties);
        };

        /**
         * Encodes the specified AllInvite_Request message. Does not implicitly {@link Protocol.AllInvite_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AllInvite_Request
         * @static
         * @param {Protocol.IAllInvite_Request} message AllInvite_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllInvite_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AllInvite_Request message, length delimited. Does not implicitly {@link Protocol.AllInvite_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AllInvite_Request
         * @static
         * @param {Protocol.IAllInvite_Request} message AllInvite_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllInvite_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllInvite_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AllInvite_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AllInvite_Request} AllInvite_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllInvite_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AllInvite_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllInvite_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AllInvite_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AllInvite_Request} AllInvite_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllInvite_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllInvite_Request message.
         * @function verify
         * @memberof Protocol.AllInvite_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllInvite_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AllInvite_Request;
    })();

    Protocol.AllInvites_Respond = (function() {

        /**
         * Properties of an AllInvites_Respond.
         * @memberof Protocol
         * @interface IAllInvites_Respond
         * @property {Array.<Protocol.IInvite>|null} [invites] AllInvites_Respond invites
         */

        /**
         * Constructs a new AllInvites_Respond.
         * @memberof Protocol
         * @classdesc Represents an AllInvites_Respond.
         * @implements IAllInvites_Respond
         * @constructor
         * @param {Protocol.IAllInvites_Respond=} [properties] Properties to set
         */
        function AllInvites_Respond(properties) {
            this.invites = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AllInvites_Respond invites.
         * @member {Array.<Protocol.IInvite>} invites
         * @memberof Protocol.AllInvites_Respond
         * @instance
         */
        AllInvites_Respond.prototype.invites = $util.emptyArray;

        /**
         * Creates a new AllInvites_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AllInvites_Respond
         * @static
         * @param {Protocol.IAllInvites_Respond=} [properties] Properties to set
         * @returns {Protocol.AllInvites_Respond} AllInvites_Respond instance
         */
        AllInvites_Respond.create = function create(properties) {
            return new AllInvites_Respond(properties);
        };

        /**
         * Encodes the specified AllInvites_Respond message. Does not implicitly {@link Protocol.AllInvites_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AllInvites_Respond
         * @static
         * @param {Protocol.IAllInvites_Respond} message AllInvites_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllInvites_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.invites != null && message.invites.length)
                for (var i = 0; i < message.invites.length; ++i)
                    $root.Protocol.Invite.encode(message.invites[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AllInvites_Respond message, length delimited. Does not implicitly {@link Protocol.AllInvites_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AllInvites_Respond
         * @static
         * @param {Protocol.IAllInvites_Respond} message AllInvites_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllInvites_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllInvites_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AllInvites_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AllInvites_Respond} AllInvites_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllInvites_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AllInvites_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.invites && message.invites.length))
                        message.invites = [];
                    message.invites.push($root.Protocol.Invite.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllInvites_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AllInvites_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AllInvites_Respond} AllInvites_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllInvites_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllInvites_Respond message.
         * @function verify
         * @memberof Protocol.AllInvites_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllInvites_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.invites != null && message.hasOwnProperty("invites")) {
                if (!Array.isArray(message.invites))
                    return "invites: array expected";
                for (var i = 0; i < message.invites.length; ++i) {
                    var error = $root.Protocol.Invite.verify(message.invites[i]);
                    if (error)
                        return "invites." + error;
                }
            }
            return null;
        };

        return AllInvites_Respond;
    })();

    Protocol.AllChat_Request = (function() {

        /**
         * Properties of an AllChat_Request.
         * @memberof Protocol
         * @interface IAllChat_Request
         * @property {number|Long|null} [roleId] AllChat_Request roleId
         */

        /**
         * Constructs a new AllChat_Request.
         * @memberof Protocol
         * @classdesc Represents an AllChat_Request.
         * @implements IAllChat_Request
         * @constructor
         * @param {Protocol.IAllChat_Request=} [properties] Properties to set
         */
        function AllChat_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AllChat_Request roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.AllChat_Request
         * @instance
         */
        AllChat_Request.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AllChat_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.AllChat_Request
         * @static
         * @param {Protocol.IAllChat_Request=} [properties] Properties to set
         * @returns {Protocol.AllChat_Request} AllChat_Request instance
         */
        AllChat_Request.create = function create(properties) {
            return new AllChat_Request(properties);
        };

        /**
         * Encodes the specified AllChat_Request message. Does not implicitly {@link Protocol.AllChat_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AllChat_Request
         * @static
         * @param {Protocol.IAllChat_Request} message AllChat_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllChat_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            return writer;
        };

        /**
         * Encodes the specified AllChat_Request message, length delimited. Does not implicitly {@link Protocol.AllChat_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AllChat_Request
         * @static
         * @param {Protocol.IAllChat_Request} message AllChat_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllChat_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllChat_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AllChat_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AllChat_Request} AllChat_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllChat_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AllChat_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllChat_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AllChat_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AllChat_Request} AllChat_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllChat_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllChat_Request message.
         * @function verify
         * @memberof Protocol.AllChat_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllChat_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            return null;
        };

        return AllChat_Request;
    })();

    Protocol.AllChat_Respond = (function() {

        /**
         * Properties of an AllChat_Respond.
         * @memberof Protocol
         * @interface IAllChat_Respond
         * @property {Array.<Protocol.IChat>|null} [chats] AllChat_Respond chats
         * @property {number|Long|null} [roleId] AllChat_Respond roleId
         * @property {number|Long|null} [lastReadTime] AllChat_Respond lastReadTime
         */

        /**
         * Constructs a new AllChat_Respond.
         * @memberof Protocol
         * @classdesc Represents an AllChat_Respond.
         * @implements IAllChat_Respond
         * @constructor
         * @param {Protocol.IAllChat_Respond=} [properties] Properties to set
         */
        function AllChat_Respond(properties) {
            this.chats = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AllChat_Respond chats.
         * @member {Array.<Protocol.IChat>} chats
         * @memberof Protocol.AllChat_Respond
         * @instance
         */
        AllChat_Respond.prototype.chats = $util.emptyArray;

        /**
         * AllChat_Respond roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.AllChat_Respond
         * @instance
         */
        AllChat_Respond.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AllChat_Respond lastReadTime.
         * @member {number|Long} lastReadTime
         * @memberof Protocol.AllChat_Respond
         * @instance
         */
        AllChat_Respond.prototype.lastReadTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new AllChat_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AllChat_Respond
         * @static
         * @param {Protocol.IAllChat_Respond=} [properties] Properties to set
         * @returns {Protocol.AllChat_Respond} AllChat_Respond instance
         */
        AllChat_Respond.create = function create(properties) {
            return new AllChat_Respond(properties);
        };

        /**
         * Encodes the specified AllChat_Respond message. Does not implicitly {@link Protocol.AllChat_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AllChat_Respond
         * @static
         * @param {Protocol.IAllChat_Respond} message AllChat_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllChat_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chats != null && message.chats.length)
                for (var i = 0; i < message.chats.length; ++i)
                    $root.Protocol.Chat.encode(message.chats[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roleId);
            if (message.lastReadTime != null && message.hasOwnProperty("lastReadTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.lastReadTime);
            return writer;
        };

        /**
         * Encodes the specified AllChat_Respond message, length delimited. Does not implicitly {@link Protocol.AllChat_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AllChat_Respond
         * @static
         * @param {Protocol.IAllChat_Respond} message AllChat_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllChat_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllChat_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AllChat_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AllChat_Respond} AllChat_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllChat_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AllChat_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chats && message.chats.length))
                        message.chats = [];
                    message.chats.push($root.Protocol.Chat.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.roleId = reader.int64();
                    break;
                case 3:
                    message.lastReadTime = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllChat_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AllChat_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AllChat_Respond} AllChat_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllChat_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllChat_Respond message.
         * @function verify
         * @memberof Protocol.AllChat_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllChat_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chats != null && message.hasOwnProperty("chats")) {
                if (!Array.isArray(message.chats))
                    return "chats: array expected";
                for (var i = 0; i < message.chats.length; ++i) {
                    var error = $root.Protocol.Chat.verify(message.chats[i]);
                    if (error)
                        return "chats." + error;
                }
            }
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.lastReadTime != null && message.hasOwnProperty("lastReadTime"))
                if (!$util.isInteger(message.lastReadTime) && !(message.lastReadTime && $util.isInteger(message.lastReadTime.low) && $util.isInteger(message.lastReadTime.high)))
                    return "lastReadTime: integer|Long expected";
            return null;
        };

        return AllChat_Respond;
    })();

    Protocol.FriendState_Respond = (function() {

        /**
         * Properties of a FriendState_Respond.
         * @memberof Protocol
         * @interface IFriendState_Respond
         * @property {number|Long|null} [roleId] FriendState_Respond roleId
         * @property {boolean|null} [state] FriendState_Respond state
         */

        /**
         * Constructs a new FriendState_Respond.
         * @memberof Protocol
         * @classdesc Represents a FriendState_Respond.
         * @implements IFriendState_Respond
         * @constructor
         * @param {Protocol.IFriendState_Respond=} [properties] Properties to set
         */
        function FriendState_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FriendState_Respond roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.FriendState_Respond
         * @instance
         */
        FriendState_Respond.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FriendState_Respond state.
         * @member {boolean} state
         * @memberof Protocol.FriendState_Respond
         * @instance
         */
        FriendState_Respond.prototype.state = false;

        /**
         * Creates a new FriendState_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.FriendState_Respond
         * @static
         * @param {Protocol.IFriendState_Respond=} [properties] Properties to set
         * @returns {Protocol.FriendState_Respond} FriendState_Respond instance
         */
        FriendState_Respond.create = function create(properties) {
            return new FriendState_Respond(properties);
        };

        /**
         * Encodes the specified FriendState_Respond message. Does not implicitly {@link Protocol.FriendState_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FriendState_Respond
         * @static
         * @param {Protocol.IFriendState_Respond} message FriendState_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendState_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.state);
            return writer;
        };

        /**
         * Encodes the specified FriendState_Respond message, length delimited. Does not implicitly {@link Protocol.FriendState_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FriendState_Respond
         * @static
         * @param {Protocol.IFriendState_Respond} message FriendState_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FriendState_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FriendState_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FriendState_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FriendState_Respond} FriendState_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendState_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FriendState_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.state = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FriendState_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FriendState_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FriendState_Respond} FriendState_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FriendState_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FriendState_Respond message.
         * @function verify
         * @memberof Protocol.FriendState_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FriendState_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (typeof message.state !== "boolean")
                    return "state: boolean expected";
            return null;
        };

        return FriendState_Respond;
    })();

    Protocol.DeleteInvite_Respond = (function() {

        /**
         * Properties of a DeleteInvite_Respond.
         * @memberof Protocol
         * @interface IDeleteInvite_Respond
         * @property {number|Long|null} [roleId] DeleteInvite_Respond roleId
         */

        /**
         * Constructs a new DeleteInvite_Respond.
         * @memberof Protocol
         * @classdesc Represents a DeleteInvite_Respond.
         * @implements IDeleteInvite_Respond
         * @constructor
         * @param {Protocol.IDeleteInvite_Respond=} [properties] Properties to set
         */
        function DeleteInvite_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteInvite_Respond roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.DeleteInvite_Respond
         * @instance
         */
        DeleteInvite_Respond.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DeleteInvite_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.DeleteInvite_Respond
         * @static
         * @param {Protocol.IDeleteInvite_Respond=} [properties] Properties to set
         * @returns {Protocol.DeleteInvite_Respond} DeleteInvite_Respond instance
         */
        DeleteInvite_Respond.create = function create(properties) {
            return new DeleteInvite_Respond(properties);
        };

        /**
         * Encodes the specified DeleteInvite_Respond message. Does not implicitly {@link Protocol.DeleteInvite_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.DeleteInvite_Respond
         * @static
         * @param {Protocol.IDeleteInvite_Respond} message DeleteInvite_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteInvite_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            return writer;
        };

        /**
         * Encodes the specified DeleteInvite_Respond message, length delimited. Does not implicitly {@link Protocol.DeleteInvite_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.DeleteInvite_Respond
         * @static
         * @param {Protocol.IDeleteInvite_Respond} message DeleteInvite_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteInvite_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteInvite_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.DeleteInvite_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.DeleteInvite_Respond} DeleteInvite_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteInvite_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.DeleteInvite_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteInvite_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.DeleteInvite_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.DeleteInvite_Respond} DeleteInvite_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteInvite_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteInvite_Respond message.
         * @function verify
         * @memberof Protocol.DeleteInvite_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteInvite_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            return null;
        };

        return DeleteInvite_Respond;
    })();

    Protocol.NoticeLastReadTime_Request = (function() {

        /**
         * Properties of a NoticeLastReadTime_Request.
         * @memberof Protocol
         * @interface INoticeLastReadTime_Request
         * @property {number|Long|null} [FrinedId] NoticeLastReadTime_Request FrinedId
         */

        /**
         * Constructs a new NoticeLastReadTime_Request.
         * @memberof Protocol
         * @classdesc Represents a NoticeLastReadTime_Request.
         * @implements INoticeLastReadTime_Request
         * @constructor
         * @param {Protocol.INoticeLastReadTime_Request=} [properties] Properties to set
         */
        function NoticeLastReadTime_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NoticeLastReadTime_Request FrinedId.
         * @member {number|Long} FrinedId
         * @memberof Protocol.NoticeLastReadTime_Request
         * @instance
         */
        NoticeLastReadTime_Request.prototype.FrinedId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new NoticeLastReadTime_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.NoticeLastReadTime_Request
         * @static
         * @param {Protocol.INoticeLastReadTime_Request=} [properties] Properties to set
         * @returns {Protocol.NoticeLastReadTime_Request} NoticeLastReadTime_Request instance
         */
        NoticeLastReadTime_Request.create = function create(properties) {
            return new NoticeLastReadTime_Request(properties);
        };

        /**
         * Encodes the specified NoticeLastReadTime_Request message. Does not implicitly {@link Protocol.NoticeLastReadTime_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.NoticeLastReadTime_Request
         * @static
         * @param {Protocol.INoticeLastReadTime_Request} message NoticeLastReadTime_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeLastReadTime_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.FrinedId != null && message.hasOwnProperty("FrinedId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.FrinedId);
            return writer;
        };

        /**
         * Encodes the specified NoticeLastReadTime_Request message, length delimited. Does not implicitly {@link Protocol.NoticeLastReadTime_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.NoticeLastReadTime_Request
         * @static
         * @param {Protocol.INoticeLastReadTime_Request} message NoticeLastReadTime_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeLastReadTime_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoticeLastReadTime_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.NoticeLastReadTime_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.NoticeLastReadTime_Request} NoticeLastReadTime_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeLastReadTime_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.NoticeLastReadTime_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.FrinedId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoticeLastReadTime_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.NoticeLastReadTime_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.NoticeLastReadTime_Request} NoticeLastReadTime_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeLastReadTime_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoticeLastReadTime_Request message.
         * @function verify
         * @memberof Protocol.NoticeLastReadTime_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoticeLastReadTime_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.FrinedId != null && message.hasOwnProperty("FrinedId"))
                if (!$util.isInteger(message.FrinedId) && !(message.FrinedId && $util.isInteger(message.FrinedId.low) && $util.isInteger(message.FrinedId.high)))
                    return "FrinedId: integer|Long expected";
            return null;
        };

        return NoticeLastReadTime_Request;
    })();

    Protocol.DeleteFriend_Request = (function() {

        /**
         * Properties of a DeleteFriend_Request.
         * @memberof Protocol
         * @interface IDeleteFriend_Request
         * @property {number|Long|null} [roleId] DeleteFriend_Request roleId
         */

        /**
         * Constructs a new DeleteFriend_Request.
         * @memberof Protocol
         * @classdesc Represents a DeleteFriend_Request.
         * @implements IDeleteFriend_Request
         * @constructor
         * @param {Protocol.IDeleteFriend_Request=} [properties] Properties to set
         */
        function DeleteFriend_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteFriend_Request roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.DeleteFriend_Request
         * @instance
         */
        DeleteFriend_Request.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DeleteFriend_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.DeleteFriend_Request
         * @static
         * @param {Protocol.IDeleteFriend_Request=} [properties] Properties to set
         * @returns {Protocol.DeleteFriend_Request} DeleteFriend_Request instance
         */
        DeleteFriend_Request.create = function create(properties) {
            return new DeleteFriend_Request(properties);
        };

        /**
         * Encodes the specified DeleteFriend_Request message. Does not implicitly {@link Protocol.DeleteFriend_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.DeleteFriend_Request
         * @static
         * @param {Protocol.IDeleteFriend_Request} message DeleteFriend_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteFriend_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            return writer;
        };

        /**
         * Encodes the specified DeleteFriend_Request message, length delimited. Does not implicitly {@link Protocol.DeleteFriend_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.DeleteFriend_Request
         * @static
         * @param {Protocol.IDeleteFriend_Request} message DeleteFriend_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteFriend_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteFriend_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.DeleteFriend_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.DeleteFriend_Request} DeleteFriend_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteFriend_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.DeleteFriend_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteFriend_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.DeleteFriend_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.DeleteFriend_Request} DeleteFriend_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteFriend_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteFriend_Request message.
         * @function verify
         * @memberof Protocol.DeleteFriend_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteFriend_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            return null;
        };

        return DeleteFriend_Request;
    })();

    Protocol.DeleteFriend_Respond = (function() {

        /**
         * Properties of a DeleteFriend_Respond.
         * @memberof Protocol
         * @interface IDeleteFriend_Respond
         * @property {number|Long|null} [roleId] DeleteFriend_Respond roleId
         */

        /**
         * Constructs a new DeleteFriend_Respond.
         * @memberof Protocol
         * @classdesc Represents a DeleteFriend_Respond.
         * @implements IDeleteFriend_Respond
         * @constructor
         * @param {Protocol.IDeleteFriend_Respond=} [properties] Properties to set
         */
        function DeleteFriend_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteFriend_Respond roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.DeleteFriend_Respond
         * @instance
         */
        DeleteFriend_Respond.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new DeleteFriend_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.DeleteFriend_Respond
         * @static
         * @param {Protocol.IDeleteFriend_Respond=} [properties] Properties to set
         * @returns {Protocol.DeleteFriend_Respond} DeleteFriend_Respond instance
         */
        DeleteFriend_Respond.create = function create(properties) {
            return new DeleteFriend_Respond(properties);
        };

        /**
         * Encodes the specified DeleteFriend_Respond message. Does not implicitly {@link Protocol.DeleteFriend_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.DeleteFriend_Respond
         * @static
         * @param {Protocol.IDeleteFriend_Respond} message DeleteFriend_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteFriend_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            return writer;
        };

        /**
         * Encodes the specified DeleteFriend_Respond message, length delimited. Does not implicitly {@link Protocol.DeleteFriend_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.DeleteFriend_Respond
         * @static
         * @param {Protocol.IDeleteFriend_Respond} message DeleteFriend_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteFriend_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteFriend_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.DeleteFriend_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.DeleteFriend_Respond} DeleteFriend_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteFriend_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.DeleteFriend_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteFriend_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.DeleteFriend_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.DeleteFriend_Respond} DeleteFriend_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteFriend_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteFriend_Respond message.
         * @function verify
         * @memberof Protocol.DeleteFriend_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteFriend_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            return null;
        };

        return DeleteFriend_Respond;
    })();

    Protocol.AskFamily_Request = (function() {

        /**
         * Properties of an AskFamily_Request.
         * @memberof Protocol
         * @interface IAskFamily_Request
         */

        /**
         * Constructs a new AskFamily_Request.
         * @memberof Protocol
         * @classdesc Represents an AskFamily_Request.
         * @implements IAskFamily_Request
         * @constructor
         * @param {Protocol.IAskFamily_Request=} [properties] Properties to set
         */
        function AskFamily_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AskFamily_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.AskFamily_Request
         * @static
         * @param {Protocol.IAskFamily_Request=} [properties] Properties to set
         * @returns {Protocol.AskFamily_Request} AskFamily_Request instance
         */
        AskFamily_Request.create = function create(properties) {
            return new AskFamily_Request(properties);
        };

        /**
         * Encodes the specified AskFamily_Request message. Does not implicitly {@link Protocol.AskFamily_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AskFamily_Request
         * @static
         * @param {Protocol.IAskFamily_Request} message AskFamily_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFamily_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AskFamily_Request message, length delimited. Does not implicitly {@link Protocol.AskFamily_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AskFamily_Request
         * @static
         * @param {Protocol.IAskFamily_Request} message AskFamily_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFamily_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AskFamily_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AskFamily_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AskFamily_Request} AskFamily_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFamily_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AskFamily_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AskFamily_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AskFamily_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AskFamily_Request} AskFamily_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFamily_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AskFamily_Request message.
         * @function verify
         * @memberof Protocol.AskFamily_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AskFamily_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AskFamily_Request;
    })();

    Protocol.AskFamily_Respond = (function() {

        /**
         * Properties of an AskFamily_Respond.
         * @memberof Protocol
         * @interface IAskFamily_Respond
         * @property {Array.<Protocol.IFamilyInfo>|null} [familys] AskFamily_Respond familys
         */

        /**
         * Constructs a new AskFamily_Respond.
         * @memberof Protocol
         * @classdesc Represents an AskFamily_Respond.
         * @implements IAskFamily_Respond
         * @constructor
         * @param {Protocol.IAskFamily_Respond=} [properties] Properties to set
         */
        function AskFamily_Respond(properties) {
            this.familys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AskFamily_Respond familys.
         * @member {Array.<Protocol.IFamilyInfo>} familys
         * @memberof Protocol.AskFamily_Respond
         * @instance
         */
        AskFamily_Respond.prototype.familys = $util.emptyArray;

        /**
         * Creates a new AskFamily_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AskFamily_Respond
         * @static
         * @param {Protocol.IAskFamily_Respond=} [properties] Properties to set
         * @returns {Protocol.AskFamily_Respond} AskFamily_Respond instance
         */
        AskFamily_Respond.create = function create(properties) {
            return new AskFamily_Respond(properties);
        };

        /**
         * Encodes the specified AskFamily_Respond message. Does not implicitly {@link Protocol.AskFamily_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AskFamily_Respond
         * @static
         * @param {Protocol.IAskFamily_Respond} message AskFamily_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFamily_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.familys != null && message.familys.length)
                for (var i = 0; i < message.familys.length; ++i)
                    $root.Protocol.FamilyInfo.encode(message.familys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AskFamily_Respond message, length delimited. Does not implicitly {@link Protocol.AskFamily_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AskFamily_Respond
         * @static
         * @param {Protocol.IAskFamily_Respond} message AskFamily_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFamily_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AskFamily_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AskFamily_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AskFamily_Respond} AskFamily_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFamily_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AskFamily_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.familys && message.familys.length))
                        message.familys = [];
                    message.familys.push($root.Protocol.FamilyInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AskFamily_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AskFamily_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AskFamily_Respond} AskFamily_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFamily_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AskFamily_Respond message.
         * @function verify
         * @memberof Protocol.AskFamily_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AskFamily_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.familys != null && message.hasOwnProperty("familys")) {
                if (!Array.isArray(message.familys))
                    return "familys: array expected";
                for (var i = 0; i < message.familys.length; ++i) {
                    var error = $root.Protocol.FamilyInfo.verify(message.familys[i]);
                    if (error)
                        return "familys." + error;
                }
            }
            return null;
        };

        return AskFamily_Respond;
    })();

    Protocol.CreateFamily_Request = (function() {

        /**
         * Properties of a CreateFamily_Request.
         * @memberof Protocol
         * @interface ICreateFamily_Request
         * @property {number|Long|null} [roleId] CreateFamily_Request roleId
         * @property {string|null} [name] CreateFamily_Request name
         * @property {number|null} [pic] CreateFamily_Request pic
         * @property {string|null} [introduce] CreateFamily_Request introduce
         * @property {number|null} [autoCup] CreateFamily_Request autoCup
         * @property {number|null} [backGroup] CreateFamily_Request backGroup
         */

        /**
         * Constructs a new CreateFamily_Request.
         * @memberof Protocol
         * @classdesc Represents a CreateFamily_Request.
         * @implements ICreateFamily_Request
         * @constructor
         * @param {Protocol.ICreateFamily_Request=} [properties] Properties to set
         */
        function CreateFamily_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateFamily_Request roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.CreateFamily_Request
         * @instance
         */
        CreateFamily_Request.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CreateFamily_Request name.
         * @member {string} name
         * @memberof Protocol.CreateFamily_Request
         * @instance
         */
        CreateFamily_Request.prototype.name = "";

        /**
         * CreateFamily_Request pic.
         * @member {number} pic
         * @memberof Protocol.CreateFamily_Request
         * @instance
         */
        CreateFamily_Request.prototype.pic = 0;

        /**
         * CreateFamily_Request introduce.
         * @member {string} introduce
         * @memberof Protocol.CreateFamily_Request
         * @instance
         */
        CreateFamily_Request.prototype.introduce = "";

        /**
         * CreateFamily_Request autoCup.
         * @member {number} autoCup
         * @memberof Protocol.CreateFamily_Request
         * @instance
         */
        CreateFamily_Request.prototype.autoCup = 0;

        /**
         * CreateFamily_Request backGroup.
         * @member {number} backGroup
         * @memberof Protocol.CreateFamily_Request
         * @instance
         */
        CreateFamily_Request.prototype.backGroup = 0;

        /**
         * Creates a new CreateFamily_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.CreateFamily_Request
         * @static
         * @param {Protocol.ICreateFamily_Request=} [properties] Properties to set
         * @returns {Protocol.CreateFamily_Request} CreateFamily_Request instance
         */
        CreateFamily_Request.create = function create(properties) {
            return new CreateFamily_Request(properties);
        };

        /**
         * Encodes the specified CreateFamily_Request message. Does not implicitly {@link Protocol.CreateFamily_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.CreateFamily_Request
         * @static
         * @param {Protocol.ICreateFamily_Request} message CreateFamily_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateFamily_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.pic != null && message.hasOwnProperty("pic"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.pic);
            if (message.introduce != null && message.hasOwnProperty("introduce"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.introduce);
            if (message.autoCup != null && message.hasOwnProperty("autoCup"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.autoCup);
            if (message.backGroup != null && message.hasOwnProperty("backGroup"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.backGroup);
            return writer;
        };

        /**
         * Encodes the specified CreateFamily_Request message, length delimited. Does not implicitly {@link Protocol.CreateFamily_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.CreateFamily_Request
         * @static
         * @param {Protocol.ICreateFamily_Request} message CreateFamily_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateFamily_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateFamily_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.CreateFamily_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.CreateFamily_Request} CreateFamily_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateFamily_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.CreateFamily_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.pic = reader.int32();
                    break;
                case 4:
                    message.introduce = reader.string();
                    break;
                case 5:
                    message.autoCup = reader.int32();
                    break;
                case 6:
                    message.backGroup = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateFamily_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.CreateFamily_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.CreateFamily_Request} CreateFamily_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateFamily_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateFamily_Request message.
         * @function verify
         * @memberof Protocol.CreateFamily_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateFamily_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.pic != null && message.hasOwnProperty("pic"))
                if (!$util.isInteger(message.pic))
                    return "pic: integer expected";
            if (message.introduce != null && message.hasOwnProperty("introduce"))
                if (!$util.isString(message.introduce))
                    return "introduce: string expected";
            if (message.autoCup != null && message.hasOwnProperty("autoCup"))
                if (!$util.isInteger(message.autoCup))
                    return "autoCup: integer expected";
            if (message.backGroup != null && message.hasOwnProperty("backGroup"))
                if (!$util.isInteger(message.backGroup))
                    return "backGroup: integer expected";
            return null;
        };

        return CreateFamily_Request;
    })();

    Protocol.CreateFamily_Respond = (function() {

        /**
         * Properties of a CreateFamily_Respond.
         * @memberof Protocol
         * @interface ICreateFamily_Respond
         * @property {number|null} [ret] CreateFamily_Respond ret
         * @property {Protocol.IFamilyInfo|null} [info] CreateFamily_Respond info
         * @property {Protocol.IFamilyMember|null} [self] CreateFamily_Respond self
         */

        /**
         * Constructs a new CreateFamily_Respond.
         * @memberof Protocol
         * @classdesc Represents a CreateFamily_Respond.
         * @implements ICreateFamily_Respond
         * @constructor
         * @param {Protocol.ICreateFamily_Respond=} [properties] Properties to set
         */
        function CreateFamily_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CreateFamily_Respond ret.
         * @member {number} ret
         * @memberof Protocol.CreateFamily_Respond
         * @instance
         */
        CreateFamily_Respond.prototype.ret = 0;

        /**
         * CreateFamily_Respond info.
         * @member {Protocol.IFamilyInfo|null|undefined} info
         * @memberof Protocol.CreateFamily_Respond
         * @instance
         */
        CreateFamily_Respond.prototype.info = null;

        /**
         * CreateFamily_Respond self.
         * @member {Protocol.IFamilyMember|null|undefined} self
         * @memberof Protocol.CreateFamily_Respond
         * @instance
         */
        CreateFamily_Respond.prototype.self = null;

        /**
         * Creates a new CreateFamily_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.CreateFamily_Respond
         * @static
         * @param {Protocol.ICreateFamily_Respond=} [properties] Properties to set
         * @returns {Protocol.CreateFamily_Respond} CreateFamily_Respond instance
         */
        CreateFamily_Respond.create = function create(properties) {
            return new CreateFamily_Respond(properties);
        };

        /**
         * Encodes the specified CreateFamily_Respond message. Does not implicitly {@link Protocol.CreateFamily_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.CreateFamily_Respond
         * @static
         * @param {Protocol.ICreateFamily_Respond} message CreateFamily_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateFamily_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            if (message.info != null && message.hasOwnProperty("info"))
                $root.Protocol.FamilyInfo.encode(message.info, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.self != null && message.hasOwnProperty("self"))
                $root.Protocol.FamilyMember.encode(message.self, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified CreateFamily_Respond message, length delimited. Does not implicitly {@link Protocol.CreateFamily_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.CreateFamily_Respond
         * @static
         * @param {Protocol.ICreateFamily_Respond} message CreateFamily_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CreateFamily_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CreateFamily_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.CreateFamily_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.CreateFamily_Respond} CreateFamily_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateFamily_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.CreateFamily_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                case 2:
                    message.info = $root.Protocol.FamilyInfo.decode(reader, reader.uint32());
                    break;
                case 3:
                    message.self = $root.Protocol.FamilyMember.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CreateFamily_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.CreateFamily_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.CreateFamily_Respond} CreateFamily_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CreateFamily_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CreateFamily_Respond message.
         * @function verify
         * @memberof Protocol.CreateFamily_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CreateFamily_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.Protocol.FamilyInfo.verify(message.info);
                if (error)
                    return "info." + error;
            }
            if (message.self != null && message.hasOwnProperty("self")) {
                var error = $root.Protocol.FamilyMember.verify(message.self);
                if (error)
                    return "self." + error;
            }
            return null;
        };

        return CreateFamily_Respond;
    })();

    Protocol.JoinFamily_Request = (function() {

        /**
         * Properties of a JoinFamily_Request.
         * @memberof Protocol
         * @interface IJoinFamily_Request
         * @property {string|null} [familyId] JoinFamily_Request familyId
         */

        /**
         * Constructs a new JoinFamily_Request.
         * @memberof Protocol
         * @classdesc Represents a JoinFamily_Request.
         * @implements IJoinFamily_Request
         * @constructor
         * @param {Protocol.IJoinFamily_Request=} [properties] Properties to set
         */
        function JoinFamily_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JoinFamily_Request familyId.
         * @member {string} familyId
         * @memberof Protocol.JoinFamily_Request
         * @instance
         */
        JoinFamily_Request.prototype.familyId = "";

        /**
         * Creates a new JoinFamily_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.JoinFamily_Request
         * @static
         * @param {Protocol.IJoinFamily_Request=} [properties] Properties to set
         * @returns {Protocol.JoinFamily_Request} JoinFamily_Request instance
         */
        JoinFamily_Request.create = function create(properties) {
            return new JoinFamily_Request(properties);
        };

        /**
         * Encodes the specified JoinFamily_Request message. Does not implicitly {@link Protocol.JoinFamily_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.JoinFamily_Request
         * @static
         * @param {Protocol.IJoinFamily_Request} message JoinFamily_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinFamily_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.familyId);
            return writer;
        };

        /**
         * Encodes the specified JoinFamily_Request message, length delimited. Does not implicitly {@link Protocol.JoinFamily_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.JoinFamily_Request
         * @static
         * @param {Protocol.IJoinFamily_Request} message JoinFamily_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinFamily_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JoinFamily_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.JoinFamily_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.JoinFamily_Request} JoinFamily_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinFamily_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.JoinFamily_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.familyId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JoinFamily_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.JoinFamily_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.JoinFamily_Request} JoinFamily_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinFamily_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JoinFamily_Request message.
         * @function verify
         * @memberof Protocol.JoinFamily_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JoinFamily_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                if (!$util.isString(message.familyId))
                    return "familyId: string expected";
            return null;
        };

        return JoinFamily_Request;
    })();

    Protocol.JoinFamily_Respond = (function() {

        /**
         * Properties of a JoinFamily_Respond.
         * @memberof Protocol
         * @interface IJoinFamily_Respond
         * @property {number|null} [ret] JoinFamily_Respond ret
         */

        /**
         * Constructs a new JoinFamily_Respond.
         * @memberof Protocol
         * @classdesc Represents a JoinFamily_Respond.
         * @implements IJoinFamily_Respond
         * @constructor
         * @param {Protocol.IJoinFamily_Respond=} [properties] Properties to set
         */
        function JoinFamily_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JoinFamily_Respond ret.
         * @member {number} ret
         * @memberof Protocol.JoinFamily_Respond
         * @instance
         */
        JoinFamily_Respond.prototype.ret = 0;

        /**
         * Creates a new JoinFamily_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.JoinFamily_Respond
         * @static
         * @param {Protocol.IJoinFamily_Respond=} [properties] Properties to set
         * @returns {Protocol.JoinFamily_Respond} JoinFamily_Respond instance
         */
        JoinFamily_Respond.create = function create(properties) {
            return new JoinFamily_Respond(properties);
        };

        /**
         * Encodes the specified JoinFamily_Respond message. Does not implicitly {@link Protocol.JoinFamily_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.JoinFamily_Respond
         * @static
         * @param {Protocol.IJoinFamily_Respond} message JoinFamily_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinFamily_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified JoinFamily_Respond message, length delimited. Does not implicitly {@link Protocol.JoinFamily_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.JoinFamily_Respond
         * @static
         * @param {Protocol.IJoinFamily_Respond} message JoinFamily_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinFamily_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JoinFamily_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.JoinFamily_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.JoinFamily_Respond} JoinFamily_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinFamily_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.JoinFamily_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JoinFamily_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.JoinFamily_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.JoinFamily_Respond} JoinFamily_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinFamily_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JoinFamily_Respond message.
         * @function verify
         * @memberof Protocol.JoinFamily_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JoinFamily_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return JoinFamily_Respond;
    })();

    Protocol.JoInFamilySuceed_Respond = (function() {

        /**
         * Properties of a JoInFamilySuceed_Respond.
         * @memberof Protocol
         * @interface IJoInFamilySuceed_Respond
         * @property {Protocol.IFamilyInfo|null} [info] JoInFamilySuceed_Respond info
         * @property {Array.<Protocol.IFamilyMember>|null} [members] JoInFamilySuceed_Respond members
         */

        /**
         * Constructs a new JoInFamilySuceed_Respond.
         * @memberof Protocol
         * @classdesc Represents a JoInFamilySuceed_Respond.
         * @implements IJoInFamilySuceed_Respond
         * @constructor
         * @param {Protocol.IJoInFamilySuceed_Respond=} [properties] Properties to set
         */
        function JoInFamilySuceed_Respond(properties) {
            this.members = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JoInFamilySuceed_Respond info.
         * @member {Protocol.IFamilyInfo|null|undefined} info
         * @memberof Protocol.JoInFamilySuceed_Respond
         * @instance
         */
        JoInFamilySuceed_Respond.prototype.info = null;

        /**
         * JoInFamilySuceed_Respond members.
         * @member {Array.<Protocol.IFamilyMember>} members
         * @memberof Protocol.JoInFamilySuceed_Respond
         * @instance
         */
        JoInFamilySuceed_Respond.prototype.members = $util.emptyArray;

        /**
         * Creates a new JoInFamilySuceed_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.JoInFamilySuceed_Respond
         * @static
         * @param {Protocol.IJoInFamilySuceed_Respond=} [properties] Properties to set
         * @returns {Protocol.JoInFamilySuceed_Respond} JoInFamilySuceed_Respond instance
         */
        JoInFamilySuceed_Respond.create = function create(properties) {
            return new JoInFamilySuceed_Respond(properties);
        };

        /**
         * Encodes the specified JoInFamilySuceed_Respond message. Does not implicitly {@link Protocol.JoInFamilySuceed_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.JoInFamilySuceed_Respond
         * @static
         * @param {Protocol.IJoInFamilySuceed_Respond} message JoInFamilySuceed_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoInFamilySuceed_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.info != null && message.hasOwnProperty("info"))
                $root.Protocol.FamilyInfo.encode(message.info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.members != null && message.members.length)
                for (var i = 0; i < message.members.length; ++i)
                    $root.Protocol.FamilyMember.encode(message.members[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified JoInFamilySuceed_Respond message, length delimited. Does not implicitly {@link Protocol.JoInFamilySuceed_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.JoInFamilySuceed_Respond
         * @static
         * @param {Protocol.IJoInFamilySuceed_Respond} message JoInFamilySuceed_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoInFamilySuceed_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JoInFamilySuceed_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.JoInFamilySuceed_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.JoInFamilySuceed_Respond} JoInFamilySuceed_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoInFamilySuceed_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.JoInFamilySuceed_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.info = $root.Protocol.FamilyInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.Protocol.FamilyMember.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JoInFamilySuceed_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.JoInFamilySuceed_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.JoInFamilySuceed_Respond} JoInFamilySuceed_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoInFamilySuceed_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JoInFamilySuceed_Respond message.
         * @function verify
         * @memberof Protocol.JoInFamilySuceed_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JoInFamilySuceed_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.Protocol.FamilyInfo.verify(message.info);
                if (error)
                    return "info." + error;
            }
            if (message.members != null && message.hasOwnProperty("members")) {
                if (!Array.isArray(message.members))
                    return "members: array expected";
                for (var i = 0; i < message.members.length; ++i) {
                    var error = $root.Protocol.FamilyMember.verify(message.members[i]);
                    if (error)
                        return "members." + error;
                }
            }
            return null;
        };

        return JoInFamilySuceed_Respond;
    })();

    Protocol.JoinApplys_Request = (function() {

        /**
         * Properties of a JoinApplys_Request.
         * @memberof Protocol
         * @interface IJoinApplys_Request
         */

        /**
         * Constructs a new JoinApplys_Request.
         * @memberof Protocol
         * @classdesc Represents a JoinApplys_Request.
         * @implements IJoinApplys_Request
         * @constructor
         * @param {Protocol.IJoinApplys_Request=} [properties] Properties to set
         */
        function JoinApplys_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new JoinApplys_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.JoinApplys_Request
         * @static
         * @param {Protocol.IJoinApplys_Request=} [properties] Properties to set
         * @returns {Protocol.JoinApplys_Request} JoinApplys_Request instance
         */
        JoinApplys_Request.create = function create(properties) {
            return new JoinApplys_Request(properties);
        };

        /**
         * Encodes the specified JoinApplys_Request message. Does not implicitly {@link Protocol.JoinApplys_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.JoinApplys_Request
         * @static
         * @param {Protocol.IJoinApplys_Request} message JoinApplys_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinApplys_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified JoinApplys_Request message, length delimited. Does not implicitly {@link Protocol.JoinApplys_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.JoinApplys_Request
         * @static
         * @param {Protocol.IJoinApplys_Request} message JoinApplys_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinApplys_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JoinApplys_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.JoinApplys_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.JoinApplys_Request} JoinApplys_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinApplys_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.JoinApplys_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JoinApplys_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.JoinApplys_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.JoinApplys_Request} JoinApplys_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinApplys_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JoinApplys_Request message.
         * @function verify
         * @memberof Protocol.JoinApplys_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JoinApplys_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return JoinApplys_Request;
    })();

    Protocol.JoinApplys_Respond = (function() {

        /**
         * Properties of a JoinApplys_Respond.
         * @memberof Protocol
         * @interface IJoinApplys_Respond
         * @property {Array.<string>|null} [familyIds] JoinApplys_Respond familyIds
         */

        /**
         * Constructs a new JoinApplys_Respond.
         * @memberof Protocol
         * @classdesc Represents a JoinApplys_Respond.
         * @implements IJoinApplys_Respond
         * @constructor
         * @param {Protocol.IJoinApplys_Respond=} [properties] Properties to set
         */
        function JoinApplys_Respond(properties) {
            this.familyIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * JoinApplys_Respond familyIds.
         * @member {Array.<string>} familyIds
         * @memberof Protocol.JoinApplys_Respond
         * @instance
         */
        JoinApplys_Respond.prototype.familyIds = $util.emptyArray;

        /**
         * Creates a new JoinApplys_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.JoinApplys_Respond
         * @static
         * @param {Protocol.IJoinApplys_Respond=} [properties] Properties to set
         * @returns {Protocol.JoinApplys_Respond} JoinApplys_Respond instance
         */
        JoinApplys_Respond.create = function create(properties) {
            return new JoinApplys_Respond(properties);
        };

        /**
         * Encodes the specified JoinApplys_Respond message. Does not implicitly {@link Protocol.JoinApplys_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.JoinApplys_Respond
         * @static
         * @param {Protocol.IJoinApplys_Respond} message JoinApplys_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinApplys_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.familyIds != null && message.familyIds.length)
                for (var i = 0; i < message.familyIds.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.familyIds[i]);
            return writer;
        };

        /**
         * Encodes the specified JoinApplys_Respond message, length delimited. Does not implicitly {@link Protocol.JoinApplys_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.JoinApplys_Respond
         * @static
         * @param {Protocol.IJoinApplys_Respond} message JoinApplys_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        JoinApplys_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a JoinApplys_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.JoinApplys_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.JoinApplys_Respond} JoinApplys_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinApplys_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.JoinApplys_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.familyIds && message.familyIds.length))
                        message.familyIds = [];
                    message.familyIds.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a JoinApplys_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.JoinApplys_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.JoinApplys_Respond} JoinApplys_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        JoinApplys_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a JoinApplys_Respond message.
         * @function verify
         * @memberof Protocol.JoinApplys_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        JoinApplys_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.familyIds != null && message.hasOwnProperty("familyIds")) {
                if (!Array.isArray(message.familyIds))
                    return "familyIds: array expected";
                for (var i = 0; i < message.familyIds.length; ++i)
                    if (!$util.isString(message.familyIds[i]))
                        return "familyIds: string[] expected";
            }
            return null;
        };

        return JoinApplys_Respond;
    })();

    Protocol.LeaveFamily_Request = (function() {

        /**
         * Properties of a LeaveFamily_Request.
         * @memberof Protocol
         * @interface ILeaveFamily_Request
         * @property {string|null} [familyId] LeaveFamily_Request familyId
         */

        /**
         * Constructs a new LeaveFamily_Request.
         * @memberof Protocol
         * @classdesc Represents a LeaveFamily_Request.
         * @implements ILeaveFamily_Request
         * @constructor
         * @param {Protocol.ILeaveFamily_Request=} [properties] Properties to set
         */
        function LeaveFamily_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LeaveFamily_Request familyId.
         * @member {string} familyId
         * @memberof Protocol.LeaveFamily_Request
         * @instance
         */
        LeaveFamily_Request.prototype.familyId = "";

        /**
         * Creates a new LeaveFamily_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.LeaveFamily_Request
         * @static
         * @param {Protocol.ILeaveFamily_Request=} [properties] Properties to set
         * @returns {Protocol.LeaveFamily_Request} LeaveFamily_Request instance
         */
        LeaveFamily_Request.create = function create(properties) {
            return new LeaveFamily_Request(properties);
        };

        /**
         * Encodes the specified LeaveFamily_Request message. Does not implicitly {@link Protocol.LeaveFamily_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.LeaveFamily_Request
         * @static
         * @param {Protocol.ILeaveFamily_Request} message LeaveFamily_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaveFamily_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.familyId);
            return writer;
        };

        /**
         * Encodes the specified LeaveFamily_Request message, length delimited. Does not implicitly {@link Protocol.LeaveFamily_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.LeaveFamily_Request
         * @static
         * @param {Protocol.ILeaveFamily_Request} message LeaveFamily_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LeaveFamily_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LeaveFamily_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.LeaveFamily_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.LeaveFamily_Request} LeaveFamily_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaveFamily_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.LeaveFamily_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.familyId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LeaveFamily_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.LeaveFamily_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.LeaveFamily_Request} LeaveFamily_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LeaveFamily_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LeaveFamily_Request message.
         * @function verify
         * @memberof Protocol.LeaveFamily_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LeaveFamily_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                if (!$util.isString(message.familyId))
                    return "familyId: string expected";
            return null;
        };

        return LeaveFamily_Request;
    })();

    Protocol.leaveFamily_Respond = (function() {

        /**
         * Properties of a leaveFamily_Respond.
         * @memberof Protocol
         * @interface IleaveFamily_Respond
         * @property {number|null} [ret] leaveFamily_Respond ret
         */

        /**
         * Constructs a new leaveFamily_Respond.
         * @memberof Protocol
         * @classdesc Represents a leaveFamily_Respond.
         * @implements IleaveFamily_Respond
         * @constructor
         * @param {Protocol.IleaveFamily_Respond=} [properties] Properties to set
         */
        function leaveFamily_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * leaveFamily_Respond ret.
         * @member {number} ret
         * @memberof Protocol.leaveFamily_Respond
         * @instance
         */
        leaveFamily_Respond.prototype.ret = 0;

        /**
         * Creates a new leaveFamily_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.leaveFamily_Respond
         * @static
         * @param {Protocol.IleaveFamily_Respond=} [properties] Properties to set
         * @returns {Protocol.leaveFamily_Respond} leaveFamily_Respond instance
         */
        leaveFamily_Respond.create = function create(properties) {
            return new leaveFamily_Respond(properties);
        };

        /**
         * Encodes the specified leaveFamily_Respond message. Does not implicitly {@link Protocol.leaveFamily_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.leaveFamily_Respond
         * @static
         * @param {Protocol.IleaveFamily_Respond} message leaveFamily_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        leaveFamily_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified leaveFamily_Respond message, length delimited. Does not implicitly {@link Protocol.leaveFamily_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.leaveFamily_Respond
         * @static
         * @param {Protocol.IleaveFamily_Respond} message leaveFamily_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        leaveFamily_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a leaveFamily_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.leaveFamily_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.leaveFamily_Respond} leaveFamily_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        leaveFamily_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.leaveFamily_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a leaveFamily_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.leaveFamily_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.leaveFamily_Respond} leaveFamily_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        leaveFamily_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a leaveFamily_Respond message.
         * @function verify
         * @memberof Protocol.leaveFamily_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        leaveFamily_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return leaveFamily_Respond;
    })();

    Protocol.AskFamilyApply_Request = (function() {

        /**
         * Properties of an AskFamilyApply_Request.
         * @memberof Protocol
         * @interface IAskFamilyApply_Request
         */

        /**
         * Constructs a new AskFamilyApply_Request.
         * @memberof Protocol
         * @classdesc Represents an AskFamilyApply_Request.
         * @implements IAskFamilyApply_Request
         * @constructor
         * @param {Protocol.IAskFamilyApply_Request=} [properties] Properties to set
         */
        function AskFamilyApply_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AskFamilyApply_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.AskFamilyApply_Request
         * @static
         * @param {Protocol.IAskFamilyApply_Request=} [properties] Properties to set
         * @returns {Protocol.AskFamilyApply_Request} AskFamilyApply_Request instance
         */
        AskFamilyApply_Request.create = function create(properties) {
            return new AskFamilyApply_Request(properties);
        };

        /**
         * Encodes the specified AskFamilyApply_Request message. Does not implicitly {@link Protocol.AskFamilyApply_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AskFamilyApply_Request
         * @static
         * @param {Protocol.IAskFamilyApply_Request} message AskFamilyApply_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFamilyApply_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AskFamilyApply_Request message, length delimited. Does not implicitly {@link Protocol.AskFamilyApply_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AskFamilyApply_Request
         * @static
         * @param {Protocol.IAskFamilyApply_Request} message AskFamilyApply_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFamilyApply_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AskFamilyApply_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AskFamilyApply_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AskFamilyApply_Request} AskFamilyApply_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFamilyApply_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AskFamilyApply_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AskFamilyApply_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AskFamilyApply_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AskFamilyApply_Request} AskFamilyApply_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFamilyApply_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AskFamilyApply_Request message.
         * @function verify
         * @memberof Protocol.AskFamilyApply_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AskFamilyApply_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AskFamilyApply_Request;
    })();

    Protocol.AskFamilyApply_Respond = (function() {

        /**
         * Properties of an AskFamilyApply_Respond.
         * @memberof Protocol
         * @interface IAskFamilyApply_Respond
         * @property {Array.<Protocol.IFamilyMember>|null} [applys] AskFamilyApply_Respond applys
         */

        /**
         * Constructs a new AskFamilyApply_Respond.
         * @memberof Protocol
         * @classdesc Represents an AskFamilyApply_Respond.
         * @implements IAskFamilyApply_Respond
         * @constructor
         * @param {Protocol.IAskFamilyApply_Respond=} [properties] Properties to set
         */
        function AskFamilyApply_Respond(properties) {
            this.applys = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AskFamilyApply_Respond applys.
         * @member {Array.<Protocol.IFamilyMember>} applys
         * @memberof Protocol.AskFamilyApply_Respond
         * @instance
         */
        AskFamilyApply_Respond.prototype.applys = $util.emptyArray;

        /**
         * Creates a new AskFamilyApply_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AskFamilyApply_Respond
         * @static
         * @param {Protocol.IAskFamilyApply_Respond=} [properties] Properties to set
         * @returns {Protocol.AskFamilyApply_Respond} AskFamilyApply_Respond instance
         */
        AskFamilyApply_Respond.create = function create(properties) {
            return new AskFamilyApply_Respond(properties);
        };

        /**
         * Encodes the specified AskFamilyApply_Respond message. Does not implicitly {@link Protocol.AskFamilyApply_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AskFamilyApply_Respond
         * @static
         * @param {Protocol.IAskFamilyApply_Respond} message AskFamilyApply_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFamilyApply_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.applys != null && message.applys.length)
                for (var i = 0; i < message.applys.length; ++i)
                    $root.Protocol.FamilyMember.encode(message.applys[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AskFamilyApply_Respond message, length delimited. Does not implicitly {@link Protocol.AskFamilyApply_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AskFamilyApply_Respond
         * @static
         * @param {Protocol.IAskFamilyApply_Respond} message AskFamilyApply_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskFamilyApply_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AskFamilyApply_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AskFamilyApply_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AskFamilyApply_Respond} AskFamilyApply_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFamilyApply_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AskFamilyApply_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.applys && message.applys.length))
                        message.applys = [];
                    message.applys.push($root.Protocol.FamilyMember.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AskFamilyApply_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AskFamilyApply_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AskFamilyApply_Respond} AskFamilyApply_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskFamilyApply_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AskFamilyApply_Respond message.
         * @function verify
         * @memberof Protocol.AskFamilyApply_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AskFamilyApply_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.applys != null && message.hasOwnProperty("applys")) {
                if (!Array.isArray(message.applys))
                    return "applys: array expected";
                for (var i = 0; i < message.applys.length; ++i) {
                    var error = $root.Protocol.FamilyMember.verify(message.applys[i]);
                    if (error)
                        return "applys." + error;
                }
            }
            return null;
        };

        return AskFamilyApply_Respond;
    })();

    Protocol.AcceptFamilyApply_Request = (function() {

        /**
         * Properties of an AcceptFamilyApply_Request.
         * @memberof Protocol
         * @interface IAcceptFamilyApply_Request
         * @property {number|Long|null} [roleId] AcceptFamilyApply_Request roleId
         * @property {boolean|null} [accept] AcceptFamilyApply_Request accept
         */

        /**
         * Constructs a new AcceptFamilyApply_Request.
         * @memberof Protocol
         * @classdesc Represents an AcceptFamilyApply_Request.
         * @implements IAcceptFamilyApply_Request
         * @constructor
         * @param {Protocol.IAcceptFamilyApply_Request=} [properties] Properties to set
         */
        function AcceptFamilyApply_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AcceptFamilyApply_Request roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.AcceptFamilyApply_Request
         * @instance
         */
        AcceptFamilyApply_Request.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * AcceptFamilyApply_Request accept.
         * @member {boolean} accept
         * @memberof Protocol.AcceptFamilyApply_Request
         * @instance
         */
        AcceptFamilyApply_Request.prototype.accept = false;

        /**
         * Creates a new AcceptFamilyApply_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.AcceptFamilyApply_Request
         * @static
         * @param {Protocol.IAcceptFamilyApply_Request=} [properties] Properties to set
         * @returns {Protocol.AcceptFamilyApply_Request} AcceptFamilyApply_Request instance
         */
        AcceptFamilyApply_Request.create = function create(properties) {
            return new AcceptFamilyApply_Request(properties);
        };

        /**
         * Encodes the specified AcceptFamilyApply_Request message. Does not implicitly {@link Protocol.AcceptFamilyApply_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AcceptFamilyApply_Request
         * @static
         * @param {Protocol.IAcceptFamilyApply_Request} message AcceptFamilyApply_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptFamilyApply_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.accept != null && message.hasOwnProperty("accept"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.accept);
            return writer;
        };

        /**
         * Encodes the specified AcceptFamilyApply_Request message, length delimited. Does not implicitly {@link Protocol.AcceptFamilyApply_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AcceptFamilyApply_Request
         * @static
         * @param {Protocol.IAcceptFamilyApply_Request} message AcceptFamilyApply_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptFamilyApply_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AcceptFamilyApply_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AcceptFamilyApply_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AcceptFamilyApply_Request} AcceptFamilyApply_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptFamilyApply_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AcceptFamilyApply_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.accept = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AcceptFamilyApply_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AcceptFamilyApply_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AcceptFamilyApply_Request} AcceptFamilyApply_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptFamilyApply_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AcceptFamilyApply_Request message.
         * @function verify
         * @memberof Protocol.AcceptFamilyApply_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AcceptFamilyApply_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.accept != null && message.hasOwnProperty("accept"))
                if (typeof message.accept !== "boolean")
                    return "accept: boolean expected";
            return null;
        };

        return AcceptFamilyApply_Request;
    })();

    Protocol.AcceptFamilyApply_Respond = (function() {

        /**
         * Properties of an AcceptFamilyApply_Respond.
         * @memberof Protocol
         * @interface IAcceptFamilyApply_Respond
         * @property {number|null} [ret] AcceptFamilyApply_Respond ret
         */

        /**
         * Constructs a new AcceptFamilyApply_Respond.
         * @memberof Protocol
         * @classdesc Represents an AcceptFamilyApply_Respond.
         * @implements IAcceptFamilyApply_Respond
         * @constructor
         * @param {Protocol.IAcceptFamilyApply_Respond=} [properties] Properties to set
         */
        function AcceptFamilyApply_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AcceptFamilyApply_Respond ret.
         * @member {number} ret
         * @memberof Protocol.AcceptFamilyApply_Respond
         * @instance
         */
        AcceptFamilyApply_Respond.prototype.ret = 0;

        /**
         * Creates a new AcceptFamilyApply_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AcceptFamilyApply_Respond
         * @static
         * @param {Protocol.IAcceptFamilyApply_Respond=} [properties] Properties to set
         * @returns {Protocol.AcceptFamilyApply_Respond} AcceptFamilyApply_Respond instance
         */
        AcceptFamilyApply_Respond.create = function create(properties) {
            return new AcceptFamilyApply_Respond(properties);
        };

        /**
         * Encodes the specified AcceptFamilyApply_Respond message. Does not implicitly {@link Protocol.AcceptFamilyApply_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AcceptFamilyApply_Respond
         * @static
         * @param {Protocol.IAcceptFamilyApply_Respond} message AcceptFamilyApply_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptFamilyApply_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified AcceptFamilyApply_Respond message, length delimited. Does not implicitly {@link Protocol.AcceptFamilyApply_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AcceptFamilyApply_Respond
         * @static
         * @param {Protocol.IAcceptFamilyApply_Respond} message AcceptFamilyApply_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AcceptFamilyApply_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AcceptFamilyApply_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AcceptFamilyApply_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AcceptFamilyApply_Respond} AcceptFamilyApply_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptFamilyApply_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AcceptFamilyApply_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AcceptFamilyApply_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AcceptFamilyApply_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AcceptFamilyApply_Respond} AcceptFamilyApply_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AcceptFamilyApply_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AcceptFamilyApply_Respond message.
         * @function verify
         * @memberof Protocol.AcceptFamilyApply_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AcceptFamilyApply_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return AcceptFamilyApply_Respond;
    })();

    Protocol.FamilyInfo_Request = (function() {

        /**
         * Properties of a FamilyInfo_Request.
         * @memberof Protocol
         * @interface IFamilyInfo_Request
         * @property {string|null} [familyId] FamilyInfo_Request familyId
         */

        /**
         * Constructs a new FamilyInfo_Request.
         * @memberof Protocol
         * @classdesc Represents a FamilyInfo_Request.
         * @implements IFamilyInfo_Request
         * @constructor
         * @param {Protocol.IFamilyInfo_Request=} [properties] Properties to set
         */
        function FamilyInfo_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FamilyInfo_Request familyId.
         * @member {string} familyId
         * @memberof Protocol.FamilyInfo_Request
         * @instance
         */
        FamilyInfo_Request.prototype.familyId = "";

        /**
         * Creates a new FamilyInfo_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.FamilyInfo_Request
         * @static
         * @param {Protocol.IFamilyInfo_Request=} [properties] Properties to set
         * @returns {Protocol.FamilyInfo_Request} FamilyInfo_Request instance
         */
        FamilyInfo_Request.create = function create(properties) {
            return new FamilyInfo_Request(properties);
        };

        /**
         * Encodes the specified FamilyInfo_Request message. Does not implicitly {@link Protocol.FamilyInfo_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FamilyInfo_Request
         * @static
         * @param {Protocol.IFamilyInfo_Request} message FamilyInfo_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyInfo_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.familyId);
            return writer;
        };

        /**
         * Encodes the specified FamilyInfo_Request message, length delimited. Does not implicitly {@link Protocol.FamilyInfo_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FamilyInfo_Request
         * @static
         * @param {Protocol.IFamilyInfo_Request} message FamilyInfo_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyInfo_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FamilyInfo_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FamilyInfo_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FamilyInfo_Request} FamilyInfo_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyInfo_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FamilyInfo_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.familyId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FamilyInfo_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FamilyInfo_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FamilyInfo_Request} FamilyInfo_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyInfo_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FamilyInfo_Request message.
         * @function verify
         * @memberof Protocol.FamilyInfo_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FamilyInfo_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                if (!$util.isString(message.familyId))
                    return "familyId: string expected";
            return null;
        };

        return FamilyInfo_Request;
    })();

    Protocol.FamilyInfo_Respond = (function() {

        /**
         * Properties of a FamilyInfo_Respond.
         * @memberof Protocol
         * @interface IFamilyInfo_Respond
         * @property {Protocol.IFamilyInfo|null} [info] FamilyInfo_Respond info
         * @property {Array.<Protocol.IFamilyMember>|null} [members] FamilyInfo_Respond members
         */

        /**
         * Constructs a new FamilyInfo_Respond.
         * @memberof Protocol
         * @classdesc Represents a FamilyInfo_Respond.
         * @implements IFamilyInfo_Respond
         * @constructor
         * @param {Protocol.IFamilyInfo_Respond=} [properties] Properties to set
         */
        function FamilyInfo_Respond(properties) {
            this.members = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FamilyInfo_Respond info.
         * @member {Protocol.IFamilyInfo|null|undefined} info
         * @memberof Protocol.FamilyInfo_Respond
         * @instance
         */
        FamilyInfo_Respond.prototype.info = null;

        /**
         * FamilyInfo_Respond members.
         * @member {Array.<Protocol.IFamilyMember>} members
         * @memberof Protocol.FamilyInfo_Respond
         * @instance
         */
        FamilyInfo_Respond.prototype.members = $util.emptyArray;

        /**
         * Creates a new FamilyInfo_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.FamilyInfo_Respond
         * @static
         * @param {Protocol.IFamilyInfo_Respond=} [properties] Properties to set
         * @returns {Protocol.FamilyInfo_Respond} FamilyInfo_Respond instance
         */
        FamilyInfo_Respond.create = function create(properties) {
            return new FamilyInfo_Respond(properties);
        };

        /**
         * Encodes the specified FamilyInfo_Respond message. Does not implicitly {@link Protocol.FamilyInfo_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FamilyInfo_Respond
         * @static
         * @param {Protocol.IFamilyInfo_Respond} message FamilyInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyInfo_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.info != null && message.hasOwnProperty("info"))
                $root.Protocol.FamilyInfo.encode(message.info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.members != null && message.members.length)
                for (var i = 0; i < message.members.length; ++i)
                    $root.Protocol.FamilyMember.encode(message.members[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FamilyInfo_Respond message, length delimited. Does not implicitly {@link Protocol.FamilyInfo_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FamilyInfo_Respond
         * @static
         * @param {Protocol.IFamilyInfo_Respond} message FamilyInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyInfo_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FamilyInfo_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FamilyInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FamilyInfo_Respond} FamilyInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyInfo_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FamilyInfo_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.info = $root.Protocol.FamilyInfo.decode(reader, reader.uint32());
                    break;
                case 2:
                    if (!(message.members && message.members.length))
                        message.members = [];
                    message.members.push($root.Protocol.FamilyMember.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FamilyInfo_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FamilyInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FamilyInfo_Respond} FamilyInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyInfo_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FamilyInfo_Respond message.
         * @function verify
         * @memberof Protocol.FamilyInfo_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FamilyInfo_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.Protocol.FamilyInfo.verify(message.info);
                if (error)
                    return "info." + error;
            }
            if (message.members != null && message.hasOwnProperty("members")) {
                if (!Array.isArray(message.members))
                    return "members: array expected";
                for (var i = 0; i < message.members.length; ++i) {
                    var error = $root.Protocol.FamilyMember.verify(message.members[i]);
                    if (error)
                        return "members." + error;
                }
            }
            return null;
        };

        return FamilyInfo_Respond;
    })();

    Protocol.FamilyChats_Request = (function() {

        /**
         * Properties of a FamilyChats_Request.
         * @memberof Protocol
         * @interface IFamilyChats_Request
         */

        /**
         * Constructs a new FamilyChats_Request.
         * @memberof Protocol
         * @classdesc Represents a FamilyChats_Request.
         * @implements IFamilyChats_Request
         * @constructor
         * @param {Protocol.IFamilyChats_Request=} [properties] Properties to set
         */
        function FamilyChats_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FamilyChats_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.FamilyChats_Request
         * @static
         * @param {Protocol.IFamilyChats_Request=} [properties] Properties to set
         * @returns {Protocol.FamilyChats_Request} FamilyChats_Request instance
         */
        FamilyChats_Request.create = function create(properties) {
            return new FamilyChats_Request(properties);
        };

        /**
         * Encodes the specified FamilyChats_Request message. Does not implicitly {@link Protocol.FamilyChats_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FamilyChats_Request
         * @static
         * @param {Protocol.IFamilyChats_Request} message FamilyChats_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyChats_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FamilyChats_Request message, length delimited. Does not implicitly {@link Protocol.FamilyChats_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FamilyChats_Request
         * @static
         * @param {Protocol.IFamilyChats_Request} message FamilyChats_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyChats_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FamilyChats_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FamilyChats_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FamilyChats_Request} FamilyChats_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyChats_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FamilyChats_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FamilyChats_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FamilyChats_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FamilyChats_Request} FamilyChats_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyChats_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FamilyChats_Request message.
         * @function verify
         * @memberof Protocol.FamilyChats_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FamilyChats_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return FamilyChats_Request;
    })();

    Protocol.FamilyChats_Respond = (function() {

        /**
         * Properties of a FamilyChats_Respond.
         * @memberof Protocol
         * @interface IFamilyChats_Respond
         * @property {Array.<Protocol.IFamilyChat>|null} [chats] FamilyChats_Respond chats
         */

        /**
         * Constructs a new FamilyChats_Respond.
         * @memberof Protocol
         * @classdesc Represents a FamilyChats_Respond.
         * @implements IFamilyChats_Respond
         * @constructor
         * @param {Protocol.IFamilyChats_Respond=} [properties] Properties to set
         */
        function FamilyChats_Respond(properties) {
            this.chats = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FamilyChats_Respond chats.
         * @member {Array.<Protocol.IFamilyChat>} chats
         * @memberof Protocol.FamilyChats_Respond
         * @instance
         */
        FamilyChats_Respond.prototype.chats = $util.emptyArray;

        /**
         * Creates a new FamilyChats_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.FamilyChats_Respond
         * @static
         * @param {Protocol.IFamilyChats_Respond=} [properties] Properties to set
         * @returns {Protocol.FamilyChats_Respond} FamilyChats_Respond instance
         */
        FamilyChats_Respond.create = function create(properties) {
            return new FamilyChats_Respond(properties);
        };

        /**
         * Encodes the specified FamilyChats_Respond message. Does not implicitly {@link Protocol.FamilyChats_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FamilyChats_Respond
         * @static
         * @param {Protocol.IFamilyChats_Respond} message FamilyChats_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyChats_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chats != null && message.chats.length)
                for (var i = 0; i < message.chats.length; ++i)
                    $root.Protocol.FamilyChat.encode(message.chats[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FamilyChats_Respond message, length delimited. Does not implicitly {@link Protocol.FamilyChats_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FamilyChats_Respond
         * @static
         * @param {Protocol.IFamilyChats_Respond} message FamilyChats_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyChats_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FamilyChats_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FamilyChats_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FamilyChats_Respond} FamilyChats_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyChats_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FamilyChats_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.chats && message.chats.length))
                        message.chats = [];
                    message.chats.push($root.Protocol.FamilyChat.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FamilyChats_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FamilyChats_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FamilyChats_Respond} FamilyChats_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyChats_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FamilyChats_Respond message.
         * @function verify
         * @memberof Protocol.FamilyChats_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FamilyChats_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chats != null && message.hasOwnProperty("chats")) {
                if (!Array.isArray(message.chats))
                    return "chats: array expected";
                for (var i = 0; i < message.chats.length; ++i) {
                    var error = $root.Protocol.FamilyChat.verify(message.chats[i]);
                    if (error)
                        return "chats." + error;
                }
            }
            return null;
        };

        return FamilyChats_Respond;
    })();

    Protocol.SendFamilyChat_Request = (function() {

        /**
         * Properties of a SendFamilyChat_Request.
         * @memberof Protocol
         * @interface ISendFamilyChat_Request
         * @property {string|null} [content] SendFamilyChat_Request content
         * @property {number|null} [type] SendFamilyChat_Request type
         */

        /**
         * Constructs a new SendFamilyChat_Request.
         * @memberof Protocol
         * @classdesc Represents a SendFamilyChat_Request.
         * @implements ISendFamilyChat_Request
         * @constructor
         * @param {Protocol.ISendFamilyChat_Request=} [properties] Properties to set
         */
        function SendFamilyChat_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendFamilyChat_Request content.
         * @member {string} content
         * @memberof Protocol.SendFamilyChat_Request
         * @instance
         */
        SendFamilyChat_Request.prototype.content = "";

        /**
         * SendFamilyChat_Request type.
         * @member {number} type
         * @memberof Protocol.SendFamilyChat_Request
         * @instance
         */
        SendFamilyChat_Request.prototype.type = 0;

        /**
         * Creates a new SendFamilyChat_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.SendFamilyChat_Request
         * @static
         * @param {Protocol.ISendFamilyChat_Request=} [properties] Properties to set
         * @returns {Protocol.SendFamilyChat_Request} SendFamilyChat_Request instance
         */
        SendFamilyChat_Request.create = function create(properties) {
            return new SendFamilyChat_Request(properties);
        };

        /**
         * Encodes the specified SendFamilyChat_Request message. Does not implicitly {@link Protocol.SendFamilyChat_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SendFamilyChat_Request
         * @static
         * @param {Protocol.ISendFamilyChat_Request} message SendFamilyChat_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendFamilyChat_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified SendFamilyChat_Request message, length delimited. Does not implicitly {@link Protocol.SendFamilyChat_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SendFamilyChat_Request
         * @static
         * @param {Protocol.ISendFamilyChat_Request} message SendFamilyChat_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendFamilyChat_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendFamilyChat_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SendFamilyChat_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SendFamilyChat_Request} SendFamilyChat_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendFamilyChat_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SendFamilyChat_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.content = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendFamilyChat_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SendFamilyChat_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SendFamilyChat_Request} SendFamilyChat_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendFamilyChat_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendFamilyChat_Request message.
         * @function verify
         * @memberof Protocol.SendFamilyChat_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendFamilyChat_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        return SendFamilyChat_Request;
    })();

    Protocol.SendFamilyChat_Respond = (function() {

        /**
         * Properties of a SendFamilyChat_Respond.
         * @memberof Protocol
         * @interface ISendFamilyChat_Respond
         * @property {Protocol.IFamilyChat|null} [chat] SendFamilyChat_Respond chat
         */

        /**
         * Constructs a new SendFamilyChat_Respond.
         * @memberof Protocol
         * @classdesc Represents a SendFamilyChat_Respond.
         * @implements ISendFamilyChat_Respond
         * @constructor
         * @param {Protocol.ISendFamilyChat_Respond=} [properties] Properties to set
         */
        function SendFamilyChat_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SendFamilyChat_Respond chat.
         * @member {Protocol.IFamilyChat|null|undefined} chat
         * @memberof Protocol.SendFamilyChat_Respond
         * @instance
         */
        SendFamilyChat_Respond.prototype.chat = null;

        /**
         * Creates a new SendFamilyChat_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.SendFamilyChat_Respond
         * @static
         * @param {Protocol.ISendFamilyChat_Respond=} [properties] Properties to set
         * @returns {Protocol.SendFamilyChat_Respond} SendFamilyChat_Respond instance
         */
        SendFamilyChat_Respond.create = function create(properties) {
            return new SendFamilyChat_Respond(properties);
        };

        /**
         * Encodes the specified SendFamilyChat_Respond message. Does not implicitly {@link Protocol.SendFamilyChat_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SendFamilyChat_Respond
         * @static
         * @param {Protocol.ISendFamilyChat_Respond} message SendFamilyChat_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendFamilyChat_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.chat != null && message.hasOwnProperty("chat"))
                $root.Protocol.FamilyChat.encode(message.chat, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SendFamilyChat_Respond message, length delimited. Does not implicitly {@link Protocol.SendFamilyChat_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SendFamilyChat_Respond
         * @static
         * @param {Protocol.ISendFamilyChat_Respond} message SendFamilyChat_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SendFamilyChat_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SendFamilyChat_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SendFamilyChat_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SendFamilyChat_Respond} SendFamilyChat_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendFamilyChat_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SendFamilyChat_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.chat = $root.Protocol.FamilyChat.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SendFamilyChat_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SendFamilyChat_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SendFamilyChat_Respond} SendFamilyChat_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SendFamilyChat_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SendFamilyChat_Respond message.
         * @function verify
         * @memberof Protocol.SendFamilyChat_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SendFamilyChat_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.chat != null && message.hasOwnProperty("chat")) {
                var error = $root.Protocol.FamilyChat.verify(message.chat);
                if (error)
                    return "chat." + error;
            }
            return null;
        };

        return SendFamilyChat_Respond;
    })();

    Protocol.SearchFamily_Request = (function() {

        /**
         * Properties of a SearchFamily_Request.
         * @memberof Protocol
         * @interface ISearchFamily_Request
         * @property {string|null} [name] SearchFamily_Request name
         */

        /**
         * Constructs a new SearchFamily_Request.
         * @memberof Protocol
         * @classdesc Represents a SearchFamily_Request.
         * @implements ISearchFamily_Request
         * @constructor
         * @param {Protocol.ISearchFamily_Request=} [properties] Properties to set
         */
        function SearchFamily_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SearchFamily_Request name.
         * @member {string} name
         * @memberof Protocol.SearchFamily_Request
         * @instance
         */
        SearchFamily_Request.prototype.name = "";

        /**
         * Creates a new SearchFamily_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.SearchFamily_Request
         * @static
         * @param {Protocol.ISearchFamily_Request=} [properties] Properties to set
         * @returns {Protocol.SearchFamily_Request} SearchFamily_Request instance
         */
        SearchFamily_Request.create = function create(properties) {
            return new SearchFamily_Request(properties);
        };

        /**
         * Encodes the specified SearchFamily_Request message. Does not implicitly {@link Protocol.SearchFamily_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SearchFamily_Request
         * @static
         * @param {Protocol.ISearchFamily_Request} message SearchFamily_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchFamily_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified SearchFamily_Request message, length delimited. Does not implicitly {@link Protocol.SearchFamily_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SearchFamily_Request
         * @static
         * @param {Protocol.ISearchFamily_Request} message SearchFamily_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SearchFamily_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SearchFamily_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SearchFamily_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SearchFamily_Request} SearchFamily_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchFamily_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SearchFamily_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SearchFamily_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SearchFamily_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SearchFamily_Request} SearchFamily_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SearchFamily_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SearchFamily_Request message.
         * @function verify
         * @memberof Protocol.SearchFamily_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SearchFamily_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        return SearchFamily_Request;
    })();

    Protocol.NoticeMemberChange_Respond = (function() {

        /**
         * Properties of a NoticeMemberChange_Respond.
         * @memberof Protocol
         * @interface INoticeMemberChange_Respond
         * @property {Array.<Protocol.IFamilyMember>|null} [member] NoticeMemberChange_Respond member
         */

        /**
         * Constructs a new NoticeMemberChange_Respond.
         * @memberof Protocol
         * @classdesc Represents a NoticeMemberChange_Respond.
         * @implements INoticeMemberChange_Respond
         * @constructor
         * @param {Protocol.INoticeMemberChange_Respond=} [properties] Properties to set
         */
        function NoticeMemberChange_Respond(properties) {
            this.member = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NoticeMemberChange_Respond member.
         * @member {Array.<Protocol.IFamilyMember>} member
         * @memberof Protocol.NoticeMemberChange_Respond
         * @instance
         */
        NoticeMemberChange_Respond.prototype.member = $util.emptyArray;

        /**
         * Creates a new NoticeMemberChange_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.NoticeMemberChange_Respond
         * @static
         * @param {Protocol.INoticeMemberChange_Respond=} [properties] Properties to set
         * @returns {Protocol.NoticeMemberChange_Respond} NoticeMemberChange_Respond instance
         */
        NoticeMemberChange_Respond.create = function create(properties) {
            return new NoticeMemberChange_Respond(properties);
        };

        /**
         * Encodes the specified NoticeMemberChange_Respond message. Does not implicitly {@link Protocol.NoticeMemberChange_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.NoticeMemberChange_Respond
         * @static
         * @param {Protocol.INoticeMemberChange_Respond} message NoticeMemberChange_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeMemberChange_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.member != null && message.member.length)
                for (var i = 0; i < message.member.length; ++i)
                    $root.Protocol.FamilyMember.encode(message.member[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NoticeMemberChange_Respond message, length delimited. Does not implicitly {@link Protocol.NoticeMemberChange_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.NoticeMemberChange_Respond
         * @static
         * @param {Protocol.INoticeMemberChange_Respond} message NoticeMemberChange_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeMemberChange_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoticeMemberChange_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.NoticeMemberChange_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.NoticeMemberChange_Respond} NoticeMemberChange_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeMemberChange_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.NoticeMemberChange_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.member && message.member.length))
                        message.member = [];
                    message.member.push($root.Protocol.FamilyMember.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoticeMemberChange_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.NoticeMemberChange_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.NoticeMemberChange_Respond} NoticeMemberChange_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeMemberChange_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoticeMemberChange_Respond message.
         * @function verify
         * @memberof Protocol.NoticeMemberChange_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoticeMemberChange_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.member != null && message.hasOwnProperty("member")) {
                if (!Array.isArray(message.member))
                    return "member: array expected";
                for (var i = 0; i < message.member.length; ++i) {
                    var error = $root.Protocol.FamilyMember.verify(message.member[i]);
                    if (error)
                        return "member." + error;
                }
            }
            return null;
        };

        return NoticeMemberChange_Respond;
    })();

    Protocol.SetFamilyJob_Request = (function() {

        /**
         * Properties of a SetFamilyJob_Request.
         * @memberof Protocol
         * @interface ISetFamilyJob_Request
         * @property {number|Long|null} [roleId] SetFamilyJob_Request roleId
         * @property {number|null} [job] SetFamilyJob_Request job
         */

        /**
         * Constructs a new SetFamilyJob_Request.
         * @memberof Protocol
         * @classdesc Represents a SetFamilyJob_Request.
         * @implements ISetFamilyJob_Request
         * @constructor
         * @param {Protocol.ISetFamilyJob_Request=} [properties] Properties to set
         */
        function SetFamilyJob_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetFamilyJob_Request roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.SetFamilyJob_Request
         * @instance
         */
        SetFamilyJob_Request.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SetFamilyJob_Request job.
         * @member {number} job
         * @memberof Protocol.SetFamilyJob_Request
         * @instance
         */
        SetFamilyJob_Request.prototype.job = 0;

        /**
         * Creates a new SetFamilyJob_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.SetFamilyJob_Request
         * @static
         * @param {Protocol.ISetFamilyJob_Request=} [properties] Properties to set
         * @returns {Protocol.SetFamilyJob_Request} SetFamilyJob_Request instance
         */
        SetFamilyJob_Request.create = function create(properties) {
            return new SetFamilyJob_Request(properties);
        };

        /**
         * Encodes the specified SetFamilyJob_Request message. Does not implicitly {@link Protocol.SetFamilyJob_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SetFamilyJob_Request
         * @static
         * @param {Protocol.ISetFamilyJob_Request} message SetFamilyJob_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFamilyJob_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.job != null && message.hasOwnProperty("job"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.job);
            return writer;
        };

        /**
         * Encodes the specified SetFamilyJob_Request message, length delimited. Does not implicitly {@link Protocol.SetFamilyJob_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SetFamilyJob_Request
         * @static
         * @param {Protocol.ISetFamilyJob_Request} message SetFamilyJob_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFamilyJob_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetFamilyJob_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SetFamilyJob_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SetFamilyJob_Request} SetFamilyJob_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFamilyJob_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SetFamilyJob_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.job = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetFamilyJob_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SetFamilyJob_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SetFamilyJob_Request} SetFamilyJob_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFamilyJob_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetFamilyJob_Request message.
         * @function verify
         * @memberof Protocol.SetFamilyJob_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetFamilyJob_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.job != null && message.hasOwnProperty("job"))
                if (!$util.isInteger(message.job))
                    return "job: integer expected";
            return null;
        };

        return SetFamilyJob_Request;
    })();

    Protocol.SetFamilyJob_Respond = (function() {

        /**
         * Properties of a SetFamilyJob_Respond.
         * @memberof Protocol
         * @interface ISetFamilyJob_Respond
         * @property {number|null} [ret] SetFamilyJob_Respond ret
         * @property {number|Long|null} [roleId] SetFamilyJob_Respond roleId
         * @property {number|null} [job] SetFamilyJob_Respond job
         */

        /**
         * Constructs a new SetFamilyJob_Respond.
         * @memberof Protocol
         * @classdesc Represents a SetFamilyJob_Respond.
         * @implements ISetFamilyJob_Respond
         * @constructor
         * @param {Protocol.ISetFamilyJob_Respond=} [properties] Properties to set
         */
        function SetFamilyJob_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetFamilyJob_Respond ret.
         * @member {number} ret
         * @memberof Protocol.SetFamilyJob_Respond
         * @instance
         */
        SetFamilyJob_Respond.prototype.ret = 0;

        /**
         * SetFamilyJob_Respond roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.SetFamilyJob_Respond
         * @instance
         */
        SetFamilyJob_Respond.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SetFamilyJob_Respond job.
         * @member {number} job
         * @memberof Protocol.SetFamilyJob_Respond
         * @instance
         */
        SetFamilyJob_Respond.prototype.job = 0;

        /**
         * Creates a new SetFamilyJob_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.SetFamilyJob_Respond
         * @static
         * @param {Protocol.ISetFamilyJob_Respond=} [properties] Properties to set
         * @returns {Protocol.SetFamilyJob_Respond} SetFamilyJob_Respond instance
         */
        SetFamilyJob_Respond.create = function create(properties) {
            return new SetFamilyJob_Respond(properties);
        };

        /**
         * Encodes the specified SetFamilyJob_Respond message. Does not implicitly {@link Protocol.SetFamilyJob_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SetFamilyJob_Respond
         * @static
         * @param {Protocol.ISetFamilyJob_Respond} message SetFamilyJob_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFamilyJob_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roleId);
            if (message.job != null && message.hasOwnProperty("job"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.job);
            return writer;
        };

        /**
         * Encodes the specified SetFamilyJob_Respond message, length delimited. Does not implicitly {@link Protocol.SetFamilyJob_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SetFamilyJob_Respond
         * @static
         * @param {Protocol.ISetFamilyJob_Respond} message SetFamilyJob_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFamilyJob_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetFamilyJob_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SetFamilyJob_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SetFamilyJob_Respond} SetFamilyJob_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFamilyJob_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SetFamilyJob_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                case 2:
                    message.roleId = reader.int64();
                    break;
                case 3:
                    message.job = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetFamilyJob_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SetFamilyJob_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SetFamilyJob_Respond} SetFamilyJob_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFamilyJob_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetFamilyJob_Respond message.
         * @function verify
         * @memberof Protocol.SetFamilyJob_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetFamilyJob_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.job != null && message.hasOwnProperty("job"))
                if (!$util.isInteger(message.job))
                    return "job: integer expected";
            return null;
        };

        return SetFamilyJob_Respond;
    })();

    Protocol.TickFamilyMember_Request = (function() {

        /**
         * Properties of a TickFamilyMember_Request.
         * @memberof Protocol
         * @interface ITickFamilyMember_Request
         * @property {number|Long|null} [roleId] TickFamilyMember_Request roleId
         */

        /**
         * Constructs a new TickFamilyMember_Request.
         * @memberof Protocol
         * @classdesc Represents a TickFamilyMember_Request.
         * @implements ITickFamilyMember_Request
         * @constructor
         * @param {Protocol.ITickFamilyMember_Request=} [properties] Properties to set
         */
        function TickFamilyMember_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TickFamilyMember_Request roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.TickFamilyMember_Request
         * @instance
         */
        TickFamilyMember_Request.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TickFamilyMember_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.TickFamilyMember_Request
         * @static
         * @param {Protocol.ITickFamilyMember_Request=} [properties] Properties to set
         * @returns {Protocol.TickFamilyMember_Request} TickFamilyMember_Request instance
         */
        TickFamilyMember_Request.create = function create(properties) {
            return new TickFamilyMember_Request(properties);
        };

        /**
         * Encodes the specified TickFamilyMember_Request message. Does not implicitly {@link Protocol.TickFamilyMember_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.TickFamilyMember_Request
         * @static
         * @param {Protocol.ITickFamilyMember_Request} message TickFamilyMember_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TickFamilyMember_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            return writer;
        };

        /**
         * Encodes the specified TickFamilyMember_Request message, length delimited. Does not implicitly {@link Protocol.TickFamilyMember_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.TickFamilyMember_Request
         * @static
         * @param {Protocol.ITickFamilyMember_Request} message TickFamilyMember_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TickFamilyMember_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TickFamilyMember_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.TickFamilyMember_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.TickFamilyMember_Request} TickFamilyMember_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TickFamilyMember_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.TickFamilyMember_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TickFamilyMember_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.TickFamilyMember_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.TickFamilyMember_Request} TickFamilyMember_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TickFamilyMember_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TickFamilyMember_Request message.
         * @function verify
         * @memberof Protocol.TickFamilyMember_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TickFamilyMember_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            return null;
        };

        return TickFamilyMember_Request;
    })();

    Protocol.TickFamilyMember_Respond = (function() {

        /**
         * Properties of a TickFamilyMember_Respond.
         * @memberof Protocol
         * @interface ITickFamilyMember_Respond
         * @property {number|null} [ret] TickFamilyMember_Respond ret
         * @property {number|Long|null} [memberId] TickFamilyMember_Respond memberId
         */

        /**
         * Constructs a new TickFamilyMember_Respond.
         * @memberof Protocol
         * @classdesc Represents a TickFamilyMember_Respond.
         * @implements ITickFamilyMember_Respond
         * @constructor
         * @param {Protocol.ITickFamilyMember_Respond=} [properties] Properties to set
         */
        function TickFamilyMember_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TickFamilyMember_Respond ret.
         * @member {number} ret
         * @memberof Protocol.TickFamilyMember_Respond
         * @instance
         */
        TickFamilyMember_Respond.prototype.ret = 0;

        /**
         * TickFamilyMember_Respond memberId.
         * @member {number|Long} memberId
         * @memberof Protocol.TickFamilyMember_Respond
         * @instance
         */
        TickFamilyMember_Respond.prototype.memberId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TickFamilyMember_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.TickFamilyMember_Respond
         * @static
         * @param {Protocol.ITickFamilyMember_Respond=} [properties] Properties to set
         * @returns {Protocol.TickFamilyMember_Respond} TickFamilyMember_Respond instance
         */
        TickFamilyMember_Respond.create = function create(properties) {
            return new TickFamilyMember_Respond(properties);
        };

        /**
         * Encodes the specified TickFamilyMember_Respond message. Does not implicitly {@link Protocol.TickFamilyMember_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.TickFamilyMember_Respond
         * @static
         * @param {Protocol.ITickFamilyMember_Respond} message TickFamilyMember_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TickFamilyMember_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            if (message.memberId != null && message.hasOwnProperty("memberId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.memberId);
            return writer;
        };

        /**
         * Encodes the specified TickFamilyMember_Respond message, length delimited. Does not implicitly {@link Protocol.TickFamilyMember_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.TickFamilyMember_Respond
         * @static
         * @param {Protocol.ITickFamilyMember_Respond} message TickFamilyMember_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TickFamilyMember_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TickFamilyMember_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.TickFamilyMember_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.TickFamilyMember_Respond} TickFamilyMember_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TickFamilyMember_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.TickFamilyMember_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                case 2:
                    message.memberId = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TickFamilyMember_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.TickFamilyMember_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.TickFamilyMember_Respond} TickFamilyMember_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TickFamilyMember_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TickFamilyMember_Respond message.
         * @function verify
         * @memberof Protocol.TickFamilyMember_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TickFamilyMember_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.memberId != null && message.hasOwnProperty("memberId"))
                if (!$util.isInteger(message.memberId) && !(message.memberId && $util.isInteger(message.memberId.low) && $util.isInteger(message.memberId.high)))
                    return "memberId: integer|Long expected";
            return null;
        };

        return TickFamilyMember_Respond;
    })();

    Protocol.BuyTreasure_Request = (function() {

        /**
         * Properties of a BuyTreasure_Request.
         * @memberof Protocol
         * @interface IBuyTreasure_Request
         * @property {number|null} [treasureId] BuyTreasure_Request treasureId
         */

        /**
         * Constructs a new BuyTreasure_Request.
         * @memberof Protocol
         * @classdesc Represents a BuyTreasure_Request.
         * @implements IBuyTreasure_Request
         * @constructor
         * @param {Protocol.IBuyTreasure_Request=} [properties] Properties to set
         */
        function BuyTreasure_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyTreasure_Request treasureId.
         * @member {number} treasureId
         * @memberof Protocol.BuyTreasure_Request
         * @instance
         */
        BuyTreasure_Request.prototype.treasureId = 0;

        /**
         * Creates a new BuyTreasure_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.BuyTreasure_Request
         * @static
         * @param {Protocol.IBuyTreasure_Request=} [properties] Properties to set
         * @returns {Protocol.BuyTreasure_Request} BuyTreasure_Request instance
         */
        BuyTreasure_Request.create = function create(properties) {
            return new BuyTreasure_Request(properties);
        };

        /**
         * Encodes the specified BuyTreasure_Request message. Does not implicitly {@link Protocol.BuyTreasure_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BuyTreasure_Request
         * @static
         * @param {Protocol.IBuyTreasure_Request} message BuyTreasure_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTreasure_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.treasureId != null && message.hasOwnProperty("treasureId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.treasureId);
            return writer;
        };

        /**
         * Encodes the specified BuyTreasure_Request message, length delimited. Does not implicitly {@link Protocol.BuyTreasure_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BuyTreasure_Request
         * @static
         * @param {Protocol.IBuyTreasure_Request} message BuyTreasure_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTreasure_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyTreasure_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BuyTreasure_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BuyTreasure_Request} BuyTreasure_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTreasure_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BuyTreasure_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.treasureId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyTreasure_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BuyTreasure_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BuyTreasure_Request} BuyTreasure_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTreasure_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyTreasure_Request message.
         * @function verify
         * @memberof Protocol.BuyTreasure_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyTreasure_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.treasureId != null && message.hasOwnProperty("treasureId"))
                if (!$util.isInteger(message.treasureId))
                    return "treasureId: integer expected";
            return null;
        };

        return BuyTreasure_Request;
    })();

    Protocol.BuyTreasure_Respond = (function() {

        /**
         * Properties of a BuyTreasure_Respond.
         * @memberof Protocol
         * @interface IBuyTreasure_Respond
         * @property {number|null} [ret] BuyTreasure_Respond ret
         * @property {number|null} [treasureId] BuyTreasure_Respond treasureId
         */

        /**
         * Constructs a new BuyTreasure_Respond.
         * @memberof Protocol
         * @classdesc Represents a BuyTreasure_Respond.
         * @implements IBuyTreasure_Respond
         * @constructor
         * @param {Protocol.IBuyTreasure_Respond=} [properties] Properties to set
         */
        function BuyTreasure_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyTreasure_Respond ret.
         * @member {number} ret
         * @memberof Protocol.BuyTreasure_Respond
         * @instance
         */
        BuyTreasure_Respond.prototype.ret = 0;

        /**
         * BuyTreasure_Respond treasureId.
         * @member {number} treasureId
         * @memberof Protocol.BuyTreasure_Respond
         * @instance
         */
        BuyTreasure_Respond.prototype.treasureId = 0;

        /**
         * Creates a new BuyTreasure_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.BuyTreasure_Respond
         * @static
         * @param {Protocol.IBuyTreasure_Respond=} [properties] Properties to set
         * @returns {Protocol.BuyTreasure_Respond} BuyTreasure_Respond instance
         */
        BuyTreasure_Respond.create = function create(properties) {
            return new BuyTreasure_Respond(properties);
        };

        /**
         * Encodes the specified BuyTreasure_Respond message. Does not implicitly {@link Protocol.BuyTreasure_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BuyTreasure_Respond
         * @static
         * @param {Protocol.IBuyTreasure_Respond} message BuyTreasure_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTreasure_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            if (message.treasureId != null && message.hasOwnProperty("treasureId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.treasureId);
            return writer;
        };

        /**
         * Encodes the specified BuyTreasure_Respond message, length delimited. Does not implicitly {@link Protocol.BuyTreasure_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BuyTreasure_Respond
         * @static
         * @param {Protocol.IBuyTreasure_Respond} message BuyTreasure_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTreasure_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyTreasure_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BuyTreasure_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BuyTreasure_Respond} BuyTreasure_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTreasure_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BuyTreasure_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                case 2:
                    message.treasureId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyTreasure_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BuyTreasure_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BuyTreasure_Respond} BuyTreasure_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTreasure_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyTreasure_Respond message.
         * @function verify
         * @memberof Protocol.BuyTreasure_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyTreasure_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.treasureId != null && message.hasOwnProperty("treasureId"))
                if (!$util.isInteger(message.treasureId))
                    return "treasureId: integer expected";
            return null;
        };

        return BuyTreasure_Respond;
    })();

    Protocol.BuyTreasureInfo_Request = (function() {

        /**
         * Properties of a BuyTreasureInfo_Request.
         * @memberof Protocol
         * @interface IBuyTreasureInfo_Request
         */

        /**
         * Constructs a new BuyTreasureInfo_Request.
         * @memberof Protocol
         * @classdesc Represents a BuyTreasureInfo_Request.
         * @implements IBuyTreasureInfo_Request
         * @constructor
         * @param {Protocol.IBuyTreasureInfo_Request=} [properties] Properties to set
         */
        function BuyTreasureInfo_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new BuyTreasureInfo_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.BuyTreasureInfo_Request
         * @static
         * @param {Protocol.IBuyTreasureInfo_Request=} [properties] Properties to set
         * @returns {Protocol.BuyTreasureInfo_Request} BuyTreasureInfo_Request instance
         */
        BuyTreasureInfo_Request.create = function create(properties) {
            return new BuyTreasureInfo_Request(properties);
        };

        /**
         * Encodes the specified BuyTreasureInfo_Request message. Does not implicitly {@link Protocol.BuyTreasureInfo_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BuyTreasureInfo_Request
         * @static
         * @param {Protocol.IBuyTreasureInfo_Request} message BuyTreasureInfo_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTreasureInfo_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified BuyTreasureInfo_Request message, length delimited. Does not implicitly {@link Protocol.BuyTreasureInfo_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BuyTreasureInfo_Request
         * @static
         * @param {Protocol.IBuyTreasureInfo_Request} message BuyTreasureInfo_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTreasureInfo_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyTreasureInfo_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BuyTreasureInfo_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BuyTreasureInfo_Request} BuyTreasureInfo_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTreasureInfo_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BuyTreasureInfo_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyTreasureInfo_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BuyTreasureInfo_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BuyTreasureInfo_Request} BuyTreasureInfo_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTreasureInfo_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyTreasureInfo_Request message.
         * @function verify
         * @memberof Protocol.BuyTreasureInfo_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyTreasureInfo_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return BuyTreasureInfo_Request;
    })();

    Protocol.BuyTreasureInfo_Respond = (function() {

        /**
         * Properties of a BuyTreasureInfo_Respond.
         * @memberof Protocol
         * @interface IBuyTreasureInfo_Respond
         * @property {Array.<Protocol.IBuyInfo>|null} [infos] BuyTreasureInfo_Respond infos
         */

        /**
         * Constructs a new BuyTreasureInfo_Respond.
         * @memberof Protocol
         * @classdesc Represents a BuyTreasureInfo_Respond.
         * @implements IBuyTreasureInfo_Respond
         * @constructor
         * @param {Protocol.IBuyTreasureInfo_Respond=} [properties] Properties to set
         */
        function BuyTreasureInfo_Respond(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyTreasureInfo_Respond infos.
         * @member {Array.<Protocol.IBuyInfo>} infos
         * @memberof Protocol.BuyTreasureInfo_Respond
         * @instance
         */
        BuyTreasureInfo_Respond.prototype.infos = $util.emptyArray;

        /**
         * Creates a new BuyTreasureInfo_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.BuyTreasureInfo_Respond
         * @static
         * @param {Protocol.IBuyTreasureInfo_Respond=} [properties] Properties to set
         * @returns {Protocol.BuyTreasureInfo_Respond} BuyTreasureInfo_Respond instance
         */
        BuyTreasureInfo_Respond.create = function create(properties) {
            return new BuyTreasureInfo_Respond(properties);
        };

        /**
         * Encodes the specified BuyTreasureInfo_Respond message. Does not implicitly {@link Protocol.BuyTreasureInfo_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BuyTreasureInfo_Respond
         * @static
         * @param {Protocol.IBuyTreasureInfo_Respond} message BuyTreasureInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTreasureInfo_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.Protocol.BuyInfo.encode(message.infos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BuyTreasureInfo_Respond message, length delimited. Does not implicitly {@link Protocol.BuyTreasureInfo_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BuyTreasureInfo_Respond
         * @static
         * @param {Protocol.IBuyTreasureInfo_Respond} message BuyTreasureInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTreasureInfo_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyTreasureInfo_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BuyTreasureInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BuyTreasureInfo_Respond} BuyTreasureInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTreasureInfo_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BuyTreasureInfo_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.Protocol.BuyInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyTreasureInfo_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BuyTreasureInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BuyTreasureInfo_Respond} BuyTreasureInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTreasureInfo_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyTreasureInfo_Respond message.
         * @function verify
         * @memberof Protocol.BuyTreasureInfo_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyTreasureInfo_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.Protocol.BuyInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            return null;
        };

        return BuyTreasureInfo_Respond;
    })();

    Protocol.BattleReward_Respond = (function() {

        /**
         * Properties of a BattleReward_Respond.
         * @memberof Protocol
         * @interface IBattleReward_Respond
         * @property {number|null} [cups] BattleReward_Respond cups
         * @property {number|null} [winType] BattleReward_Respond winType
         * @property {Array.<Protocol.IReward>|null} [rewards] BattleReward_Respond rewards
         */

        /**
         * Constructs a new BattleReward_Respond.
         * @memberof Protocol
         * @classdesc Represents a BattleReward_Respond.
         * @implements IBattleReward_Respond
         * @constructor
         * @param {Protocol.IBattleReward_Respond=} [properties] Properties to set
         */
        function BattleReward_Respond(properties) {
            this.rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BattleReward_Respond cups.
         * @member {number} cups
         * @memberof Protocol.BattleReward_Respond
         * @instance
         */
        BattleReward_Respond.prototype.cups = 0;

        /**
         * BattleReward_Respond winType.
         * @member {number} winType
         * @memberof Protocol.BattleReward_Respond
         * @instance
         */
        BattleReward_Respond.prototype.winType = 0;

        /**
         * BattleReward_Respond rewards.
         * @member {Array.<Protocol.IReward>} rewards
         * @memberof Protocol.BattleReward_Respond
         * @instance
         */
        BattleReward_Respond.prototype.rewards = $util.emptyArray;

        /**
         * Creates a new BattleReward_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.BattleReward_Respond
         * @static
         * @param {Protocol.IBattleReward_Respond=} [properties] Properties to set
         * @returns {Protocol.BattleReward_Respond} BattleReward_Respond instance
         */
        BattleReward_Respond.create = function create(properties) {
            return new BattleReward_Respond(properties);
        };

        /**
         * Encodes the specified BattleReward_Respond message. Does not implicitly {@link Protocol.BattleReward_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BattleReward_Respond
         * @static
         * @param {Protocol.IBattleReward_Respond} message BattleReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleReward_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cups != null && message.hasOwnProperty("cups"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cups);
            if (message.winType != null && message.hasOwnProperty("winType"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.winType);
            if (message.rewards != null && message.rewards.length)
                for (var i = 0; i < message.rewards.length; ++i)
                    $root.Protocol.Reward.encode(message.rewards[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified BattleReward_Respond message, length delimited. Does not implicitly {@link Protocol.BattleReward_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BattleReward_Respond
         * @static
         * @param {Protocol.IBattleReward_Respond} message BattleReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BattleReward_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BattleReward_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BattleReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BattleReward_Respond} BattleReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleReward_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BattleReward_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cups = reader.int32();
                    break;
                case 2:
                    message.winType = reader.int32();
                    break;
                case 3:
                    if (!(message.rewards && message.rewards.length))
                        message.rewards = [];
                    message.rewards.push($root.Protocol.Reward.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BattleReward_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BattleReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BattleReward_Respond} BattleReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BattleReward_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BattleReward_Respond message.
         * @function verify
         * @memberof Protocol.BattleReward_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BattleReward_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cups != null && message.hasOwnProperty("cups"))
                if (!$util.isInteger(message.cups))
                    return "cups: integer expected";
            if (message.winType != null && message.hasOwnProperty("winType"))
                if (!$util.isInteger(message.winType))
                    return "winType: integer expected";
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                if (!Array.isArray(message.rewards))
                    return "rewards: array expected";
                for (var i = 0; i < message.rewards.length; ++i) {
                    var error = $root.Protocol.Reward.verify(message.rewards[i]);
                    if (error)
                        return "rewards." + error;
                }
            }
            return null;
        };

        return BattleReward_Respond;
    })();

    Protocol.SimpleRecord_Request = (function() {

        /**
         * Properties of a SimpleRecord_Request.
         * @memberof Protocol
         * @interface ISimpleRecord_Request
         */

        /**
         * Constructs a new SimpleRecord_Request.
         * @memberof Protocol
         * @classdesc Represents a SimpleRecord_Request.
         * @implements ISimpleRecord_Request
         * @constructor
         * @param {Protocol.ISimpleRecord_Request=} [properties] Properties to set
         */
        function SimpleRecord_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new SimpleRecord_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.SimpleRecord_Request
         * @static
         * @param {Protocol.ISimpleRecord_Request=} [properties] Properties to set
         * @returns {Protocol.SimpleRecord_Request} SimpleRecord_Request instance
         */
        SimpleRecord_Request.create = function create(properties) {
            return new SimpleRecord_Request(properties);
        };

        /**
         * Encodes the specified SimpleRecord_Request message. Does not implicitly {@link Protocol.SimpleRecord_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SimpleRecord_Request
         * @static
         * @param {Protocol.ISimpleRecord_Request} message SimpleRecord_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleRecord_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified SimpleRecord_Request message, length delimited. Does not implicitly {@link Protocol.SimpleRecord_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SimpleRecord_Request
         * @static
         * @param {Protocol.ISimpleRecord_Request} message SimpleRecord_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleRecord_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimpleRecord_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SimpleRecord_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SimpleRecord_Request} SimpleRecord_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleRecord_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SimpleRecord_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimpleRecord_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SimpleRecord_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SimpleRecord_Request} SimpleRecord_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleRecord_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimpleRecord_Request message.
         * @function verify
         * @memberof Protocol.SimpleRecord_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimpleRecord_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return SimpleRecord_Request;
    })();

    Protocol.SimpleRecord_Respond = (function() {

        /**
         * Properties of a SimpleRecord_Respond.
         * @memberof Protocol
         * @interface ISimpleRecord_Respond
         * @property {Array.<Protocol.ISimpleRecord>|null} [records] SimpleRecord_Respond records
         */

        /**
         * Constructs a new SimpleRecord_Respond.
         * @memberof Protocol
         * @classdesc Represents a SimpleRecord_Respond.
         * @implements ISimpleRecord_Respond
         * @constructor
         * @param {Protocol.ISimpleRecord_Respond=} [properties] Properties to set
         */
        function SimpleRecord_Respond(properties) {
            this.records = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimpleRecord_Respond records.
         * @member {Array.<Protocol.ISimpleRecord>} records
         * @memberof Protocol.SimpleRecord_Respond
         * @instance
         */
        SimpleRecord_Respond.prototype.records = $util.emptyArray;

        /**
         * Creates a new SimpleRecord_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.SimpleRecord_Respond
         * @static
         * @param {Protocol.ISimpleRecord_Respond=} [properties] Properties to set
         * @returns {Protocol.SimpleRecord_Respond} SimpleRecord_Respond instance
         */
        SimpleRecord_Respond.create = function create(properties) {
            return new SimpleRecord_Respond(properties);
        };

        /**
         * Encodes the specified SimpleRecord_Respond message. Does not implicitly {@link Protocol.SimpleRecord_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SimpleRecord_Respond
         * @static
         * @param {Protocol.ISimpleRecord_Respond} message SimpleRecord_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleRecord_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.records != null && message.records.length)
                for (var i = 0; i < message.records.length; ++i)
                    $root.Protocol.SimpleRecord.encode(message.records[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SimpleRecord_Respond message, length delimited. Does not implicitly {@link Protocol.SimpleRecord_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SimpleRecord_Respond
         * @static
         * @param {Protocol.ISimpleRecord_Respond} message SimpleRecord_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleRecord_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimpleRecord_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SimpleRecord_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SimpleRecord_Respond} SimpleRecord_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleRecord_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SimpleRecord_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.records && message.records.length))
                        message.records = [];
                    message.records.push($root.Protocol.SimpleRecord.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimpleRecord_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SimpleRecord_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SimpleRecord_Respond} SimpleRecord_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleRecord_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimpleRecord_Respond message.
         * @function verify
         * @memberof Protocol.SimpleRecord_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimpleRecord_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.records != null && message.hasOwnProperty("records")) {
                if (!Array.isArray(message.records))
                    return "records: array expected";
                for (var i = 0; i < message.records.length; ++i) {
                    var error = $root.Protocol.SimpleRecord.verify(message.records[i]);
                    if (error)
                        return "records." + error;
                }
            }
            return null;
        };

        return SimpleRecord_Respond;
    })();

    Protocol.FightRecord_Request = (function() {

        /**
         * Properties of a FightRecord_Request.
         * @memberof Protocol
         * @interface IFightRecord_Request
         * @property {number|null} [index] FightRecord_Request index
         */

        /**
         * Constructs a new FightRecord_Request.
         * @memberof Protocol
         * @classdesc Represents a FightRecord_Request.
         * @implements IFightRecord_Request
         * @constructor
         * @param {Protocol.IFightRecord_Request=} [properties] Properties to set
         */
        function FightRecord_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightRecord_Request index.
         * @member {number} index
         * @memberof Protocol.FightRecord_Request
         * @instance
         */
        FightRecord_Request.prototype.index = 0;

        /**
         * Creates a new FightRecord_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.FightRecord_Request
         * @static
         * @param {Protocol.IFightRecord_Request=} [properties] Properties to set
         * @returns {Protocol.FightRecord_Request} FightRecord_Request instance
         */
        FightRecord_Request.create = function create(properties) {
            return new FightRecord_Request(properties);
        };

        /**
         * Encodes the specified FightRecord_Request message. Does not implicitly {@link Protocol.FightRecord_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FightRecord_Request
         * @static
         * @param {Protocol.IFightRecord_Request} message FightRecord_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightRecord_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified FightRecord_Request message, length delimited. Does not implicitly {@link Protocol.FightRecord_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FightRecord_Request
         * @static
         * @param {Protocol.IFightRecord_Request} message FightRecord_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightRecord_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightRecord_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FightRecord_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FightRecord_Request} FightRecord_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightRecord_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FightRecord_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightRecord_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FightRecord_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FightRecord_Request} FightRecord_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightRecord_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightRecord_Request message.
         * @function verify
         * @memberof Protocol.FightRecord_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightRecord_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return FightRecord_Request;
    })();

    Protocol.FightRecord_Respond = (function() {

        /**
         * Properties of a FightRecord_Respond.
         * @memberof Protocol
         * @interface IFightRecord_Respond
         * @property {Protocol.IFightRecord|null} [record] FightRecord_Respond record
         */

        /**
         * Constructs a new FightRecord_Respond.
         * @memberof Protocol
         * @classdesc Represents a FightRecord_Respond.
         * @implements IFightRecord_Respond
         * @constructor
         * @param {Protocol.IFightRecord_Respond=} [properties] Properties to set
         */
        function FightRecord_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightRecord_Respond record.
         * @member {Protocol.IFightRecord|null|undefined} record
         * @memberof Protocol.FightRecord_Respond
         * @instance
         */
        FightRecord_Respond.prototype.record = null;

        /**
         * Creates a new FightRecord_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.FightRecord_Respond
         * @static
         * @param {Protocol.IFightRecord_Respond=} [properties] Properties to set
         * @returns {Protocol.FightRecord_Respond} FightRecord_Respond instance
         */
        FightRecord_Respond.create = function create(properties) {
            return new FightRecord_Respond(properties);
        };

        /**
         * Encodes the specified FightRecord_Respond message. Does not implicitly {@link Protocol.FightRecord_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FightRecord_Respond
         * @static
         * @param {Protocol.IFightRecord_Respond} message FightRecord_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightRecord_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.record != null && message.hasOwnProperty("record"))
                $root.Protocol.FightRecord.encode(message.record, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FightRecord_Respond message, length delimited. Does not implicitly {@link Protocol.FightRecord_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FightRecord_Respond
         * @static
         * @param {Protocol.IFightRecord_Respond} message FightRecord_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightRecord_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightRecord_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FightRecord_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FightRecord_Respond} FightRecord_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightRecord_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FightRecord_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.record = $root.Protocol.FightRecord.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightRecord_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FightRecord_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FightRecord_Respond} FightRecord_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightRecord_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightRecord_Respond message.
         * @function verify
         * @memberof Protocol.FightRecord_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightRecord_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.record != null && message.hasOwnProperty("record")) {
                var error = $root.Protocol.FightRecord.verify(message.record);
                if (error)
                    return "record." + error;
            }
            return null;
        };

        return FightRecord_Respond;
    })();

    Protocol.AllMails_Request = (function() {

        /**
         * Properties of an AllMails_Request.
         * @memberof Protocol
         * @interface IAllMails_Request
         */

        /**
         * Constructs a new AllMails_Request.
         * @memberof Protocol
         * @classdesc Represents an AllMails_Request.
         * @implements IAllMails_Request
         * @constructor
         * @param {Protocol.IAllMails_Request=} [properties] Properties to set
         */
        function AllMails_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AllMails_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.AllMails_Request
         * @static
         * @param {Protocol.IAllMails_Request=} [properties] Properties to set
         * @returns {Protocol.AllMails_Request} AllMails_Request instance
         */
        AllMails_Request.create = function create(properties) {
            return new AllMails_Request(properties);
        };

        /**
         * Encodes the specified AllMails_Request message. Does not implicitly {@link Protocol.AllMails_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AllMails_Request
         * @static
         * @param {Protocol.IAllMails_Request} message AllMails_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllMails_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AllMails_Request message, length delimited. Does not implicitly {@link Protocol.AllMails_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AllMails_Request
         * @static
         * @param {Protocol.IAllMails_Request} message AllMails_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllMails_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllMails_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AllMails_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AllMails_Request} AllMails_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllMails_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AllMails_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllMails_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AllMails_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AllMails_Request} AllMails_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllMails_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllMails_Request message.
         * @function verify
         * @memberof Protocol.AllMails_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllMails_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AllMails_Request;
    })();

    Protocol.AllMails_Respond = (function() {

        /**
         * Properties of an AllMails_Respond.
         * @memberof Protocol
         * @interface IAllMails_Respond
         * @property {Array.<Protocol.IMail>|null} [mails] AllMails_Respond mails
         */

        /**
         * Constructs a new AllMails_Respond.
         * @memberof Protocol
         * @classdesc Represents an AllMails_Respond.
         * @implements IAllMails_Respond
         * @constructor
         * @param {Protocol.IAllMails_Respond=} [properties] Properties to set
         */
        function AllMails_Respond(properties) {
            this.mails = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AllMails_Respond mails.
         * @member {Array.<Protocol.IMail>} mails
         * @memberof Protocol.AllMails_Respond
         * @instance
         */
        AllMails_Respond.prototype.mails = $util.emptyArray;

        /**
         * Creates a new AllMails_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AllMails_Respond
         * @static
         * @param {Protocol.IAllMails_Respond=} [properties] Properties to set
         * @returns {Protocol.AllMails_Respond} AllMails_Respond instance
         */
        AllMails_Respond.create = function create(properties) {
            return new AllMails_Respond(properties);
        };

        /**
         * Encodes the specified AllMails_Respond message. Does not implicitly {@link Protocol.AllMails_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AllMails_Respond
         * @static
         * @param {Protocol.IAllMails_Respond} message AllMails_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllMails_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mails != null && message.mails.length)
                for (var i = 0; i < message.mails.length; ++i)
                    $root.Protocol.Mail.encode(message.mails[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AllMails_Respond message, length delimited. Does not implicitly {@link Protocol.AllMails_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AllMails_Respond
         * @static
         * @param {Protocol.IAllMails_Respond} message AllMails_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllMails_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllMails_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AllMails_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AllMails_Respond} AllMails_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllMails_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AllMails_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.mails && message.mails.length))
                        message.mails = [];
                    message.mails.push($root.Protocol.Mail.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllMails_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AllMails_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AllMails_Respond} AllMails_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllMails_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllMails_Respond message.
         * @function verify
         * @memberof Protocol.AllMails_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllMails_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mails != null && message.hasOwnProperty("mails")) {
                if (!Array.isArray(message.mails))
                    return "mails: array expected";
                for (var i = 0; i < message.mails.length; ++i) {
                    var error = $root.Protocol.Mail.verify(message.mails[i]);
                    if (error)
                        return "mails." + error;
                }
            }
            return null;
        };

        return AllMails_Respond;
    })();

    Protocol.NoticeMail_Respond = (function() {

        /**
         * Properties of a NoticeMail_Respond.
         * @memberof Protocol
         * @interface INoticeMail_Respond
         */

        /**
         * Constructs a new NoticeMail_Respond.
         * @memberof Protocol
         * @classdesc Represents a NoticeMail_Respond.
         * @implements INoticeMail_Respond
         * @constructor
         * @param {Protocol.INoticeMail_Respond=} [properties] Properties to set
         */
        function NoticeMail_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new NoticeMail_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.NoticeMail_Respond
         * @static
         * @param {Protocol.INoticeMail_Respond=} [properties] Properties to set
         * @returns {Protocol.NoticeMail_Respond} NoticeMail_Respond instance
         */
        NoticeMail_Respond.create = function create(properties) {
            return new NoticeMail_Respond(properties);
        };

        /**
         * Encodes the specified NoticeMail_Respond message. Does not implicitly {@link Protocol.NoticeMail_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.NoticeMail_Respond
         * @static
         * @param {Protocol.INoticeMail_Respond} message NoticeMail_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeMail_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified NoticeMail_Respond message, length delimited. Does not implicitly {@link Protocol.NoticeMail_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.NoticeMail_Respond
         * @static
         * @param {Protocol.INoticeMail_Respond} message NoticeMail_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeMail_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoticeMail_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.NoticeMail_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.NoticeMail_Respond} NoticeMail_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeMail_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.NoticeMail_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoticeMail_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.NoticeMail_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.NoticeMail_Respond} NoticeMail_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeMail_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoticeMail_Respond message.
         * @function verify
         * @memberof Protocol.NoticeMail_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoticeMail_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return NoticeMail_Respond;
    })();

    Protocol.ReadMail_Request = (function() {

        /**
         * Properties of a ReadMail_Request.
         * @memberof Protocol
         * @interface IReadMail_Request
         * @property {string|null} [id] ReadMail_Request id
         */

        /**
         * Constructs a new ReadMail_Request.
         * @memberof Protocol
         * @classdesc Represents a ReadMail_Request.
         * @implements IReadMail_Request
         * @constructor
         * @param {Protocol.IReadMail_Request=} [properties] Properties to set
         */
        function ReadMail_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReadMail_Request id.
         * @member {string} id
         * @memberof Protocol.ReadMail_Request
         * @instance
         */
        ReadMail_Request.prototype.id = "";

        /**
         * Creates a new ReadMail_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.ReadMail_Request
         * @static
         * @param {Protocol.IReadMail_Request=} [properties] Properties to set
         * @returns {Protocol.ReadMail_Request} ReadMail_Request instance
         */
        ReadMail_Request.create = function create(properties) {
            return new ReadMail_Request(properties);
        };

        /**
         * Encodes the specified ReadMail_Request message. Does not implicitly {@link Protocol.ReadMail_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.ReadMail_Request
         * @static
         * @param {Protocol.IReadMail_Request} message ReadMail_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadMail_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified ReadMail_Request message, length delimited. Does not implicitly {@link Protocol.ReadMail_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.ReadMail_Request
         * @static
         * @param {Protocol.IReadMail_Request} message ReadMail_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadMail_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReadMail_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.ReadMail_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.ReadMail_Request} ReadMail_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadMail_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.ReadMail_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReadMail_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.ReadMail_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.ReadMail_Request} ReadMail_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadMail_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReadMail_Request message.
         * @function verify
         * @memberof Protocol.ReadMail_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReadMail_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        return ReadMail_Request;
    })();

    Protocol.ReadMail_Respond = (function() {

        /**
         * Properties of a ReadMail_Respond.
         * @memberof Protocol
         * @interface IReadMail_Respond
         * @property {Protocol.IMail|null} [mail] ReadMail_Respond mail
         * @property {number|null} [ret] ReadMail_Respond ret
         */

        /**
         * Constructs a new ReadMail_Respond.
         * @memberof Protocol
         * @classdesc Represents a ReadMail_Respond.
         * @implements IReadMail_Respond
         * @constructor
         * @param {Protocol.IReadMail_Respond=} [properties] Properties to set
         */
        function ReadMail_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ReadMail_Respond mail.
         * @member {Protocol.IMail|null|undefined} mail
         * @memberof Protocol.ReadMail_Respond
         * @instance
         */
        ReadMail_Respond.prototype.mail = null;

        /**
         * ReadMail_Respond ret.
         * @member {number} ret
         * @memberof Protocol.ReadMail_Respond
         * @instance
         */
        ReadMail_Respond.prototype.ret = 0;

        /**
         * Creates a new ReadMail_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.ReadMail_Respond
         * @static
         * @param {Protocol.IReadMail_Respond=} [properties] Properties to set
         * @returns {Protocol.ReadMail_Respond} ReadMail_Respond instance
         */
        ReadMail_Respond.create = function create(properties) {
            return new ReadMail_Respond(properties);
        };

        /**
         * Encodes the specified ReadMail_Respond message. Does not implicitly {@link Protocol.ReadMail_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.ReadMail_Respond
         * @static
         * @param {Protocol.IReadMail_Respond} message ReadMail_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadMail_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mail != null && message.hasOwnProperty("mail"))
                $root.Protocol.Mail.encode(message.mail, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified ReadMail_Respond message, length delimited. Does not implicitly {@link Protocol.ReadMail_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.ReadMail_Respond
         * @static
         * @param {Protocol.IReadMail_Respond} message ReadMail_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ReadMail_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ReadMail_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.ReadMail_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.ReadMail_Respond} ReadMail_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadMail_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.ReadMail_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.mail = $root.Protocol.Mail.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ReadMail_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.ReadMail_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.ReadMail_Respond} ReadMail_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ReadMail_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ReadMail_Respond message.
         * @function verify
         * @memberof Protocol.ReadMail_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ReadMail_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mail != null && message.hasOwnProperty("mail")) {
                var error = $root.Protocol.Mail.verify(message.mail);
                if (error)
                    return "mail." + error;
            }
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return ReadMail_Respond;
    })();

    Protocol.GetMail_Request = (function() {

        /**
         * Properties of a GetMail_Request.
         * @memberof Protocol
         * @interface IGetMail_Request
         * @property {Array.<string>|null} [id] GetMail_Request id
         */

        /**
         * Constructs a new GetMail_Request.
         * @memberof Protocol
         * @classdesc Represents a GetMail_Request.
         * @implements IGetMail_Request
         * @constructor
         * @param {Protocol.IGetMail_Request=} [properties] Properties to set
         */
        function GetMail_Request(properties) {
            this.id = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetMail_Request id.
         * @member {Array.<string>} id
         * @memberof Protocol.GetMail_Request
         * @instance
         */
        GetMail_Request.prototype.id = $util.emptyArray;

        /**
         * Creates a new GetMail_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.GetMail_Request
         * @static
         * @param {Protocol.IGetMail_Request=} [properties] Properties to set
         * @returns {Protocol.GetMail_Request} GetMail_Request instance
         */
        GetMail_Request.create = function create(properties) {
            return new GetMail_Request(properties);
        };

        /**
         * Encodes the specified GetMail_Request message. Does not implicitly {@link Protocol.GetMail_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetMail_Request
         * @static
         * @param {Protocol.IGetMail_Request} message GetMail_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMail_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.id.length)
                for (var i = 0; i < message.id.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id[i]);
            return writer;
        };

        /**
         * Encodes the specified GetMail_Request message, length delimited. Does not implicitly {@link Protocol.GetMail_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetMail_Request
         * @static
         * @param {Protocol.IGetMail_Request} message GetMail_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetMail_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetMail_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetMail_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetMail_Request} GetMail_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMail_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetMail_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.id && message.id.length))
                        message.id = [];
                    message.id.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetMail_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetMail_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetMail_Request} GetMail_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetMail_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetMail_Request message.
         * @function verify
         * @memberof Protocol.GetMail_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetMail_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                if (!Array.isArray(message.id))
                    return "id: array expected";
                for (var i = 0; i < message.id.length; ++i)
                    if (!$util.isString(message.id[i]))
                        return "id: string[] expected";
            }
            return null;
        };

        return GetMail_Request;
    })();

    Protocol.Getmail_Respond = (function() {

        /**
         * Properties of a Getmail_Respond.
         * @memberof Protocol
         * @interface IGetmail_Respond
         * @property {Array.<Protocol.IMail>|null} [mail] Getmail_Respond mail
         * @property {number|null} [ret] Getmail_Respond ret
         */

        /**
         * Constructs a new Getmail_Respond.
         * @memberof Protocol
         * @classdesc Represents a Getmail_Respond.
         * @implements IGetmail_Respond
         * @constructor
         * @param {Protocol.IGetmail_Respond=} [properties] Properties to set
         */
        function Getmail_Respond(properties) {
            this.mail = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Getmail_Respond mail.
         * @member {Array.<Protocol.IMail>} mail
         * @memberof Protocol.Getmail_Respond
         * @instance
         */
        Getmail_Respond.prototype.mail = $util.emptyArray;

        /**
         * Getmail_Respond ret.
         * @member {number} ret
         * @memberof Protocol.Getmail_Respond
         * @instance
         */
        Getmail_Respond.prototype.ret = 0;

        /**
         * Creates a new Getmail_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.Getmail_Respond
         * @static
         * @param {Protocol.IGetmail_Respond=} [properties] Properties to set
         * @returns {Protocol.Getmail_Respond} Getmail_Respond instance
         */
        Getmail_Respond.create = function create(properties) {
            return new Getmail_Respond(properties);
        };

        /**
         * Encodes the specified Getmail_Respond message. Does not implicitly {@link Protocol.Getmail_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Getmail_Respond
         * @static
         * @param {Protocol.IGetmail_Respond} message Getmail_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Getmail_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mail != null && message.mail.length)
                for (var i = 0; i < message.mail.length; ++i)
                    $root.Protocol.Mail.encode(message.mail[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified Getmail_Respond message, length delimited. Does not implicitly {@link Protocol.Getmail_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Getmail_Respond
         * @static
         * @param {Protocol.IGetmail_Respond} message Getmail_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Getmail_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Getmail_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Getmail_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Getmail_Respond} Getmail_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Getmail_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Getmail_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.mail && message.mail.length))
                        message.mail = [];
                    message.mail.push($root.Protocol.Mail.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Getmail_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Getmail_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Getmail_Respond} Getmail_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Getmail_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Getmail_Respond message.
         * @function verify
         * @memberof Protocol.Getmail_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Getmail_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mail != null && message.hasOwnProperty("mail")) {
                if (!Array.isArray(message.mail))
                    return "mail: array expected";
                for (var i = 0; i < message.mail.length; ++i) {
                    var error = $root.Protocol.Mail.verify(message.mail[i]);
                    if (error)
                        return "mail." + error;
                }
            }
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return Getmail_Respond;
    })();

    Protocol.DelMail_Request = (function() {

        /**
         * Properties of a DelMail_Request.
         * @memberof Protocol
         * @interface IDelMail_Request
         * @property {Array.<string>|null} [id] DelMail_Request id
         */

        /**
         * Constructs a new DelMail_Request.
         * @memberof Protocol
         * @classdesc Represents a DelMail_Request.
         * @implements IDelMail_Request
         * @constructor
         * @param {Protocol.IDelMail_Request=} [properties] Properties to set
         */
        function DelMail_Request(properties) {
            this.id = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelMail_Request id.
         * @member {Array.<string>} id
         * @memberof Protocol.DelMail_Request
         * @instance
         */
        DelMail_Request.prototype.id = $util.emptyArray;

        /**
         * Creates a new DelMail_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.DelMail_Request
         * @static
         * @param {Protocol.IDelMail_Request=} [properties] Properties to set
         * @returns {Protocol.DelMail_Request} DelMail_Request instance
         */
        DelMail_Request.create = function create(properties) {
            return new DelMail_Request(properties);
        };

        /**
         * Encodes the specified DelMail_Request message. Does not implicitly {@link Protocol.DelMail_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.DelMail_Request
         * @static
         * @param {Protocol.IDelMail_Request} message DelMail_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelMail_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.id.length)
                for (var i = 0; i < message.id.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id[i]);
            return writer;
        };

        /**
         * Encodes the specified DelMail_Request message, length delimited. Does not implicitly {@link Protocol.DelMail_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.DelMail_Request
         * @static
         * @param {Protocol.IDelMail_Request} message DelMail_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelMail_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelMail_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.DelMail_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.DelMail_Request} DelMail_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelMail_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.DelMail_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.id && message.id.length))
                        message.id = [];
                    message.id.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelMail_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.DelMail_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.DelMail_Request} DelMail_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelMail_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelMail_Request message.
         * @function verify
         * @memberof Protocol.DelMail_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelMail_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                if (!Array.isArray(message.id))
                    return "id: array expected";
                for (var i = 0; i < message.id.length; ++i)
                    if (!$util.isString(message.id[i]))
                        return "id: string[] expected";
            }
            return null;
        };

        return DelMail_Request;
    })();

    Protocol.DelMail_Respond = (function() {

        /**
         * Properties of a DelMail_Respond.
         * @memberof Protocol
         * @interface IDelMail_Respond
         * @property {Array.<string>|null} [id] DelMail_Respond id
         * @property {number|null} [ret] DelMail_Respond ret
         */

        /**
         * Constructs a new DelMail_Respond.
         * @memberof Protocol
         * @classdesc Represents a DelMail_Respond.
         * @implements IDelMail_Respond
         * @constructor
         * @param {Protocol.IDelMail_Respond=} [properties] Properties to set
         */
        function DelMail_Respond(properties) {
            this.id = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DelMail_Respond id.
         * @member {Array.<string>} id
         * @memberof Protocol.DelMail_Respond
         * @instance
         */
        DelMail_Respond.prototype.id = $util.emptyArray;

        /**
         * DelMail_Respond ret.
         * @member {number} ret
         * @memberof Protocol.DelMail_Respond
         * @instance
         */
        DelMail_Respond.prototype.ret = 0;

        /**
         * Creates a new DelMail_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.DelMail_Respond
         * @static
         * @param {Protocol.IDelMail_Respond=} [properties] Properties to set
         * @returns {Protocol.DelMail_Respond} DelMail_Respond instance
         */
        DelMail_Respond.create = function create(properties) {
            return new DelMail_Respond(properties);
        };

        /**
         * Encodes the specified DelMail_Respond message. Does not implicitly {@link Protocol.DelMail_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.DelMail_Respond
         * @static
         * @param {Protocol.IDelMail_Respond} message DelMail_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelMail_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.id.length)
                for (var i = 0; i < message.id.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.id[i]);
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified DelMail_Respond message, length delimited. Does not implicitly {@link Protocol.DelMail_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.DelMail_Respond
         * @static
         * @param {Protocol.IDelMail_Respond} message DelMail_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DelMail_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DelMail_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.DelMail_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.DelMail_Respond} DelMail_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelMail_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.DelMail_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.id && message.id.length))
                        message.id = [];
                    message.id.push(reader.string());
                    break;
                case 2:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DelMail_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.DelMail_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.DelMail_Respond} DelMail_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DelMail_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DelMail_Respond message.
         * @function verify
         * @memberof Protocol.DelMail_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DelMail_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id")) {
                if (!Array.isArray(message.id))
                    return "id: array expected";
                for (var i = 0; i < message.id.length; ++i)
                    if (!$util.isString(message.id[i]))
                        return "id: string[] expected";
            }
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return DelMail_Respond;
    })();

    Protocol.FightMonster_Request = (function() {

        /**
         * Properties of a FightMonster_Request.
         * @memberof Protocol
         * @interface IFightMonster_Request
         */

        /**
         * Constructs a new FightMonster_Request.
         * @memberof Protocol
         * @classdesc Represents a FightMonster_Request.
         * @implements IFightMonster_Request
         * @constructor
         * @param {Protocol.IFightMonster_Request=} [properties] Properties to set
         */
        function FightMonster_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FightMonster_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.FightMonster_Request
         * @static
         * @param {Protocol.IFightMonster_Request=} [properties] Properties to set
         * @returns {Protocol.FightMonster_Request} FightMonster_Request instance
         */
        FightMonster_Request.create = function create(properties) {
            return new FightMonster_Request(properties);
        };

        /**
         * Encodes the specified FightMonster_Request message. Does not implicitly {@link Protocol.FightMonster_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FightMonster_Request
         * @static
         * @param {Protocol.IFightMonster_Request} message FightMonster_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightMonster_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FightMonster_Request message, length delimited. Does not implicitly {@link Protocol.FightMonster_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FightMonster_Request
         * @static
         * @param {Protocol.IFightMonster_Request} message FightMonster_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightMonster_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightMonster_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FightMonster_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FightMonster_Request} FightMonster_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightMonster_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FightMonster_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightMonster_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FightMonster_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FightMonster_Request} FightMonster_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightMonster_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightMonster_Request message.
         * @function verify
         * @memberof Protocol.FightMonster_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightMonster_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return FightMonster_Request;
    })();

    Protocol.FightMonster_Respond = (function() {

        /**
         * Properties of a FightMonster_Respond.
         * @memberof Protocol
         * @interface IFightMonster_Respond
         * @property {Protocol.IFightRoomInfo_Respond|null} [info] FightMonster_Respond info
         * @property {number|null} [ret] FightMonster_Respond ret
         */

        /**
         * Constructs a new FightMonster_Respond.
         * @memberof Protocol
         * @classdesc Represents a FightMonster_Respond.
         * @implements IFightMonster_Respond
         * @constructor
         * @param {Protocol.IFightMonster_Respond=} [properties] Properties to set
         */
        function FightMonster_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightMonster_Respond info.
         * @member {Protocol.IFightRoomInfo_Respond|null|undefined} info
         * @memberof Protocol.FightMonster_Respond
         * @instance
         */
        FightMonster_Respond.prototype.info = null;

        /**
         * FightMonster_Respond ret.
         * @member {number} ret
         * @memberof Protocol.FightMonster_Respond
         * @instance
         */
        FightMonster_Respond.prototype.ret = 0;

        /**
         * Creates a new FightMonster_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.FightMonster_Respond
         * @static
         * @param {Protocol.IFightMonster_Respond=} [properties] Properties to set
         * @returns {Protocol.FightMonster_Respond} FightMonster_Respond instance
         */
        FightMonster_Respond.create = function create(properties) {
            return new FightMonster_Respond(properties);
        };

        /**
         * Encodes the specified FightMonster_Respond message. Does not implicitly {@link Protocol.FightMonster_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FightMonster_Respond
         * @static
         * @param {Protocol.IFightMonster_Respond} message FightMonster_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightMonster_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.info != null && message.hasOwnProperty("info"))
                $root.Protocol.FightRoomInfo_Respond.encode(message.info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified FightMonster_Respond message, length delimited. Does not implicitly {@link Protocol.FightMonster_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FightMonster_Respond
         * @static
         * @param {Protocol.IFightMonster_Respond} message FightMonster_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightMonster_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightMonster_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FightMonster_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FightMonster_Respond} FightMonster_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightMonster_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FightMonster_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.info = $root.Protocol.FightRoomInfo_Respond.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightMonster_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FightMonster_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FightMonster_Respond} FightMonster_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightMonster_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightMonster_Respond message.
         * @function verify
         * @memberof Protocol.FightMonster_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightMonster_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.Protocol.FightRoomInfo_Respond.verify(message.info);
                if (error)
                    return "info." + error;
            }
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return FightMonster_Respond;
    })();

    Protocol.FightMonsterResult_Request = (function() {

        /**
         * Properties of a FightMonsterResult_Request.
         * @memberof Protocol
         * @interface IFightMonsterResult_Request
         * @property {number|null} [result] FightMonsterResult_Request result
         * @property {number|null} [star] FightMonsterResult_Request star
         * @property {number|null} [monsterId] FightMonsterResult_Request monsterId
         */

        /**
         * Constructs a new FightMonsterResult_Request.
         * @memberof Protocol
         * @classdesc Represents a FightMonsterResult_Request.
         * @implements IFightMonsterResult_Request
         * @constructor
         * @param {Protocol.IFightMonsterResult_Request=} [properties] Properties to set
         */
        function FightMonsterResult_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightMonsterResult_Request result.
         * @member {number} result
         * @memberof Protocol.FightMonsterResult_Request
         * @instance
         */
        FightMonsterResult_Request.prototype.result = 0;

        /**
         * FightMonsterResult_Request star.
         * @member {number} star
         * @memberof Protocol.FightMonsterResult_Request
         * @instance
         */
        FightMonsterResult_Request.prototype.star = 0;

        /**
         * FightMonsterResult_Request monsterId.
         * @member {number} monsterId
         * @memberof Protocol.FightMonsterResult_Request
         * @instance
         */
        FightMonsterResult_Request.prototype.monsterId = 0;

        /**
         * Creates a new FightMonsterResult_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.FightMonsterResult_Request
         * @static
         * @param {Protocol.IFightMonsterResult_Request=} [properties] Properties to set
         * @returns {Protocol.FightMonsterResult_Request} FightMonsterResult_Request instance
         */
        FightMonsterResult_Request.create = function create(properties) {
            return new FightMonsterResult_Request(properties);
        };

        /**
         * Encodes the specified FightMonsterResult_Request message. Does not implicitly {@link Protocol.FightMonsterResult_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FightMonsterResult_Request
         * @static
         * @param {Protocol.IFightMonsterResult_Request} message FightMonsterResult_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightMonsterResult_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.result != null && message.hasOwnProperty("result"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.result);
            if (message.star != null && message.hasOwnProperty("star"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.star);
            if (message.monsterId != null && message.hasOwnProperty("monsterId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.monsterId);
            return writer;
        };

        /**
         * Encodes the specified FightMonsterResult_Request message, length delimited. Does not implicitly {@link Protocol.FightMonsterResult_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FightMonsterResult_Request
         * @static
         * @param {Protocol.IFightMonsterResult_Request} message FightMonsterResult_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightMonsterResult_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightMonsterResult_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FightMonsterResult_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FightMonsterResult_Request} FightMonsterResult_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightMonsterResult_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FightMonsterResult_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.result = reader.int32();
                    break;
                case 2:
                    message.star = reader.int32();
                    break;
                case 3:
                    message.monsterId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightMonsterResult_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FightMonsterResult_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FightMonsterResult_Request} FightMonsterResult_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightMonsterResult_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightMonsterResult_Request message.
         * @function verify
         * @memberof Protocol.FightMonsterResult_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightMonsterResult_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.result != null && message.hasOwnProperty("result"))
                if (!$util.isInteger(message.result))
                    return "result: integer expected";
            if (message.star != null && message.hasOwnProperty("star"))
                if (!$util.isInteger(message.star))
                    return "star: integer expected";
            if (message.monsterId != null && message.hasOwnProperty("monsterId"))
                if (!$util.isInteger(message.monsterId))
                    return "monsterId: integer expected";
            return null;
        };

        return FightMonsterResult_Request;
    })();

    Protocol.FightMonsterResult_Respond = (function() {

        /**
         * Properties of a FightMonsterResult_Respond.
         * @memberof Protocol
         * @interface IFightMonsterResult_Respond
         */

        /**
         * Constructs a new FightMonsterResult_Respond.
         * @memberof Protocol
         * @classdesc Represents a FightMonsterResult_Respond.
         * @implements IFightMonsterResult_Respond
         * @constructor
         * @param {Protocol.IFightMonsterResult_Respond=} [properties] Properties to set
         */
        function FightMonsterResult_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new FightMonsterResult_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.FightMonsterResult_Respond
         * @static
         * @param {Protocol.IFightMonsterResult_Respond=} [properties] Properties to set
         * @returns {Protocol.FightMonsterResult_Respond} FightMonsterResult_Respond instance
         */
        FightMonsterResult_Respond.create = function create(properties) {
            return new FightMonsterResult_Respond(properties);
        };

        /**
         * Encodes the specified FightMonsterResult_Respond message. Does not implicitly {@link Protocol.FightMonsterResult_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FightMonsterResult_Respond
         * @static
         * @param {Protocol.IFightMonsterResult_Respond} message FightMonsterResult_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightMonsterResult_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified FightMonsterResult_Respond message, length delimited. Does not implicitly {@link Protocol.FightMonsterResult_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FightMonsterResult_Respond
         * @static
         * @param {Protocol.IFightMonsterResult_Respond} message FightMonsterResult_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightMonsterResult_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightMonsterResult_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FightMonsterResult_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FightMonsterResult_Respond} FightMonsterResult_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightMonsterResult_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FightMonsterResult_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightMonsterResult_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FightMonsterResult_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FightMonsterResult_Respond} FightMonsterResult_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightMonsterResult_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightMonsterResult_Respond message.
         * @function verify
         * @memberof Protocol.FightMonsterResult_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightMonsterResult_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return FightMonsterResult_Respond;
    })();

    Protocol.SetFamilyInfo_Request = (function() {

        /**
         * Properties of a SetFamilyInfo_Request.
         * @memberof Protocol
         * @interface ISetFamilyInfo_Request
         * @property {string|null} [name] SetFamilyInfo_Request name
         * @property {number|null} [pic] SetFamilyInfo_Request pic
         * @property {string|null} [introduce] SetFamilyInfo_Request introduce
         * @property {number|null} [autoCup] SetFamilyInfo_Request autoCup
         * @property {number|null} [backGroup] SetFamilyInfo_Request backGroup
         */

        /**
         * Constructs a new SetFamilyInfo_Request.
         * @memberof Protocol
         * @classdesc Represents a SetFamilyInfo_Request.
         * @implements ISetFamilyInfo_Request
         * @constructor
         * @param {Protocol.ISetFamilyInfo_Request=} [properties] Properties to set
         */
        function SetFamilyInfo_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetFamilyInfo_Request name.
         * @member {string} name
         * @memberof Protocol.SetFamilyInfo_Request
         * @instance
         */
        SetFamilyInfo_Request.prototype.name = "";

        /**
         * SetFamilyInfo_Request pic.
         * @member {number} pic
         * @memberof Protocol.SetFamilyInfo_Request
         * @instance
         */
        SetFamilyInfo_Request.prototype.pic = 0;

        /**
         * SetFamilyInfo_Request introduce.
         * @member {string} introduce
         * @memberof Protocol.SetFamilyInfo_Request
         * @instance
         */
        SetFamilyInfo_Request.prototype.introduce = "";

        /**
         * SetFamilyInfo_Request autoCup.
         * @member {number} autoCup
         * @memberof Protocol.SetFamilyInfo_Request
         * @instance
         */
        SetFamilyInfo_Request.prototype.autoCup = 0;

        /**
         * SetFamilyInfo_Request backGroup.
         * @member {number} backGroup
         * @memberof Protocol.SetFamilyInfo_Request
         * @instance
         */
        SetFamilyInfo_Request.prototype.backGroup = 0;

        /**
         * Creates a new SetFamilyInfo_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.SetFamilyInfo_Request
         * @static
         * @param {Protocol.ISetFamilyInfo_Request=} [properties] Properties to set
         * @returns {Protocol.SetFamilyInfo_Request} SetFamilyInfo_Request instance
         */
        SetFamilyInfo_Request.create = function create(properties) {
            return new SetFamilyInfo_Request(properties);
        };

        /**
         * Encodes the specified SetFamilyInfo_Request message. Does not implicitly {@link Protocol.SetFamilyInfo_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SetFamilyInfo_Request
         * @static
         * @param {Protocol.ISetFamilyInfo_Request} message SetFamilyInfo_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFamilyInfo_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.pic != null && message.hasOwnProperty("pic"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pic);
            if (message.introduce != null && message.hasOwnProperty("introduce"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.introduce);
            if (message.autoCup != null && message.hasOwnProperty("autoCup"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.autoCup);
            if (message.backGroup != null && message.hasOwnProperty("backGroup"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.backGroup);
            return writer;
        };

        /**
         * Encodes the specified SetFamilyInfo_Request message, length delimited. Does not implicitly {@link Protocol.SetFamilyInfo_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SetFamilyInfo_Request
         * @static
         * @param {Protocol.ISetFamilyInfo_Request} message SetFamilyInfo_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFamilyInfo_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetFamilyInfo_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SetFamilyInfo_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SetFamilyInfo_Request} SetFamilyInfo_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFamilyInfo_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SetFamilyInfo_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.pic = reader.int32();
                    break;
                case 3:
                    message.introduce = reader.string();
                    break;
                case 4:
                    message.autoCup = reader.int32();
                    break;
                case 5:
                    message.backGroup = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetFamilyInfo_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SetFamilyInfo_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SetFamilyInfo_Request} SetFamilyInfo_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFamilyInfo_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetFamilyInfo_Request message.
         * @function verify
         * @memberof Protocol.SetFamilyInfo_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetFamilyInfo_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.pic != null && message.hasOwnProperty("pic"))
                if (!$util.isInteger(message.pic))
                    return "pic: integer expected";
            if (message.introduce != null && message.hasOwnProperty("introduce"))
                if (!$util.isString(message.introduce))
                    return "introduce: string expected";
            if (message.autoCup != null && message.hasOwnProperty("autoCup"))
                if (!$util.isInteger(message.autoCup))
                    return "autoCup: integer expected";
            if (message.backGroup != null && message.hasOwnProperty("backGroup"))
                if (!$util.isInteger(message.backGroup))
                    return "backGroup: integer expected";
            return null;
        };

        return SetFamilyInfo_Request;
    })();

    Protocol.SetFamilyInfo_Respond = (function() {

        /**
         * Properties of a SetFamilyInfo_Respond.
         * @memberof Protocol
         * @interface ISetFamilyInfo_Respond
         * @property {string|null} [name] SetFamilyInfo_Respond name
         * @property {number|null} [pic] SetFamilyInfo_Respond pic
         * @property {string|null} [introduce] SetFamilyInfo_Respond introduce
         * @property {number|null} [autoCup] SetFamilyInfo_Respond autoCup
         * @property {number|null} [ret] SetFamilyInfo_Respond ret
         * @property {number|null} [backGroup] SetFamilyInfo_Respond backGroup
         */

        /**
         * Constructs a new SetFamilyInfo_Respond.
         * @memberof Protocol
         * @classdesc Represents a SetFamilyInfo_Respond.
         * @implements ISetFamilyInfo_Respond
         * @constructor
         * @param {Protocol.ISetFamilyInfo_Respond=} [properties] Properties to set
         */
        function SetFamilyInfo_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SetFamilyInfo_Respond name.
         * @member {string} name
         * @memberof Protocol.SetFamilyInfo_Respond
         * @instance
         */
        SetFamilyInfo_Respond.prototype.name = "";

        /**
         * SetFamilyInfo_Respond pic.
         * @member {number} pic
         * @memberof Protocol.SetFamilyInfo_Respond
         * @instance
         */
        SetFamilyInfo_Respond.prototype.pic = 0;

        /**
         * SetFamilyInfo_Respond introduce.
         * @member {string} introduce
         * @memberof Protocol.SetFamilyInfo_Respond
         * @instance
         */
        SetFamilyInfo_Respond.prototype.introduce = "";

        /**
         * SetFamilyInfo_Respond autoCup.
         * @member {number} autoCup
         * @memberof Protocol.SetFamilyInfo_Respond
         * @instance
         */
        SetFamilyInfo_Respond.prototype.autoCup = 0;

        /**
         * SetFamilyInfo_Respond ret.
         * @member {number} ret
         * @memberof Protocol.SetFamilyInfo_Respond
         * @instance
         */
        SetFamilyInfo_Respond.prototype.ret = 0;

        /**
         * SetFamilyInfo_Respond backGroup.
         * @member {number} backGroup
         * @memberof Protocol.SetFamilyInfo_Respond
         * @instance
         */
        SetFamilyInfo_Respond.prototype.backGroup = 0;

        /**
         * Creates a new SetFamilyInfo_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.SetFamilyInfo_Respond
         * @static
         * @param {Protocol.ISetFamilyInfo_Respond=} [properties] Properties to set
         * @returns {Protocol.SetFamilyInfo_Respond} SetFamilyInfo_Respond instance
         */
        SetFamilyInfo_Respond.create = function create(properties) {
            return new SetFamilyInfo_Respond(properties);
        };

        /**
         * Encodes the specified SetFamilyInfo_Respond message. Does not implicitly {@link Protocol.SetFamilyInfo_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SetFamilyInfo_Respond
         * @static
         * @param {Protocol.ISetFamilyInfo_Respond} message SetFamilyInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFamilyInfo_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.pic != null && message.hasOwnProperty("pic"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pic);
            if (message.introduce != null && message.hasOwnProperty("introduce"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.introduce);
            if (message.autoCup != null && message.hasOwnProperty("autoCup"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.autoCup);
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.ret);
            if (message.backGroup != null && message.hasOwnProperty("backGroup"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.backGroup);
            return writer;
        };

        /**
         * Encodes the specified SetFamilyInfo_Respond message, length delimited. Does not implicitly {@link Protocol.SetFamilyInfo_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SetFamilyInfo_Respond
         * @static
         * @param {Protocol.ISetFamilyInfo_Respond} message SetFamilyInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SetFamilyInfo_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SetFamilyInfo_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SetFamilyInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SetFamilyInfo_Respond} SetFamilyInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFamilyInfo_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SetFamilyInfo_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                case 2:
                    message.pic = reader.int32();
                    break;
                case 3:
                    message.introduce = reader.string();
                    break;
                case 4:
                    message.autoCup = reader.int32();
                    break;
                case 5:
                    message.ret = reader.int32();
                    break;
                case 6:
                    message.backGroup = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SetFamilyInfo_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SetFamilyInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SetFamilyInfo_Respond} SetFamilyInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SetFamilyInfo_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SetFamilyInfo_Respond message.
         * @function verify
         * @memberof Protocol.SetFamilyInfo_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SetFamilyInfo_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.pic != null && message.hasOwnProperty("pic"))
                if (!$util.isInteger(message.pic))
                    return "pic: integer expected";
            if (message.introduce != null && message.hasOwnProperty("introduce"))
                if (!$util.isString(message.introduce))
                    return "introduce: string expected";
            if (message.autoCup != null && message.hasOwnProperty("autoCup"))
                if (!$util.isInteger(message.autoCup))
                    return "autoCup: integer expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.backGroup != null && message.hasOwnProperty("backGroup"))
                if (!$util.isInteger(message.backGroup))
                    return "backGroup: integer expected";
            return null;
        };

        return SetFamilyInfo_Respond;
    })();

    Protocol.QueryRoleLineUp_Request = (function() {

        /**
         * Properties of a QueryRoleLineUp_Request.
         * @memberof Protocol
         * @interface IQueryRoleLineUp_Request
         * @property {Array.<number|Long>|null} [roleIds] QueryRoleLineUp_Request roleIds
         */

        /**
         * Constructs a new QueryRoleLineUp_Request.
         * @memberof Protocol
         * @classdesc Represents a QueryRoleLineUp_Request.
         * @implements IQueryRoleLineUp_Request
         * @constructor
         * @param {Protocol.IQueryRoleLineUp_Request=} [properties] Properties to set
         */
        function QueryRoleLineUp_Request(properties) {
            this.roleIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRoleLineUp_Request roleIds.
         * @member {Array.<number|Long>} roleIds
         * @memberof Protocol.QueryRoleLineUp_Request
         * @instance
         */
        QueryRoleLineUp_Request.prototype.roleIds = $util.emptyArray;

        /**
         * Creates a new QueryRoleLineUp_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.QueryRoleLineUp_Request
         * @static
         * @param {Protocol.IQueryRoleLineUp_Request=} [properties] Properties to set
         * @returns {Protocol.QueryRoleLineUp_Request} QueryRoleLineUp_Request instance
         */
        QueryRoleLineUp_Request.create = function create(properties) {
            return new QueryRoleLineUp_Request(properties);
        };

        /**
         * Encodes the specified QueryRoleLineUp_Request message. Does not implicitly {@link Protocol.QueryRoleLineUp_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.QueryRoleLineUp_Request
         * @static
         * @param {Protocol.IQueryRoleLineUp_Request} message QueryRoleLineUp_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoleLineUp_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleIds != null && message.roleIds.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.roleIds.length; ++i)
                    writer.int64(message.roleIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified QueryRoleLineUp_Request message, length delimited. Does not implicitly {@link Protocol.QueryRoleLineUp_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.QueryRoleLineUp_Request
         * @static
         * @param {Protocol.IQueryRoleLineUp_Request} message QueryRoleLineUp_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoleLineUp_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRoleLineUp_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.QueryRoleLineUp_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.QueryRoleLineUp_Request} QueryRoleLineUp_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoleLineUp_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.QueryRoleLineUp_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.roleIds && message.roleIds.length))
                        message.roleIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.roleIds.push(reader.int64());
                    } else
                        message.roleIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryRoleLineUp_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.QueryRoleLineUp_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.QueryRoleLineUp_Request} QueryRoleLineUp_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoleLineUp_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRoleLineUp_Request message.
         * @function verify
         * @memberof Protocol.QueryRoleLineUp_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRoleLineUp_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleIds != null && message.hasOwnProperty("roleIds")) {
                if (!Array.isArray(message.roleIds))
                    return "roleIds: array expected";
                for (var i = 0; i < message.roleIds.length; ++i)
                    if (!$util.isInteger(message.roleIds[i]) && !(message.roleIds[i] && $util.isInteger(message.roleIds[i].low) && $util.isInteger(message.roleIds[i].high)))
                        return "roleIds: integer|Long[] expected";
            }
            return null;
        };

        return QueryRoleLineUp_Request;
    })();

    Protocol.QueryRoleLineUp_Respond = (function() {

        /**
         * Properties of a QueryRoleLineUp_Respond.
         * @memberof Protocol
         * @interface IQueryRoleLineUp_Respond
         * @property {number|Long|null} [roleId] QueryRoleLineUp_Respond roleId
         * @property {Array.<Protocol.IRankInfo>|null} [infos] QueryRoleLineUp_Respond infos
         */

        /**
         * Constructs a new QueryRoleLineUp_Respond.
         * @memberof Protocol
         * @classdesc Represents a QueryRoleLineUp_Respond.
         * @implements IQueryRoleLineUp_Respond
         * @constructor
         * @param {Protocol.IQueryRoleLineUp_Respond=} [properties] Properties to set
         */
        function QueryRoleLineUp_Respond(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * QueryRoleLineUp_Respond roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.QueryRoleLineUp_Respond
         * @instance
         */
        QueryRoleLineUp_Respond.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * QueryRoleLineUp_Respond infos.
         * @member {Array.<Protocol.IRankInfo>} infos
         * @memberof Protocol.QueryRoleLineUp_Respond
         * @instance
         */
        QueryRoleLineUp_Respond.prototype.infos = $util.emptyArray;

        /**
         * Creates a new QueryRoleLineUp_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.QueryRoleLineUp_Respond
         * @static
         * @param {Protocol.IQueryRoleLineUp_Respond=} [properties] Properties to set
         * @returns {Protocol.QueryRoleLineUp_Respond} QueryRoleLineUp_Respond instance
         */
        QueryRoleLineUp_Respond.create = function create(properties) {
            return new QueryRoleLineUp_Respond(properties);
        };

        /**
         * Encodes the specified QueryRoleLineUp_Respond message. Does not implicitly {@link Protocol.QueryRoleLineUp_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.QueryRoleLineUp_Respond
         * @static
         * @param {Protocol.IQueryRoleLineUp_Respond} message QueryRoleLineUp_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoleLineUp_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.Protocol.RankInfo.encode(message.infos[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified QueryRoleLineUp_Respond message, length delimited. Does not implicitly {@link Protocol.QueryRoleLineUp_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.QueryRoleLineUp_Respond
         * @static
         * @param {Protocol.IQueryRoleLineUp_Respond} message QueryRoleLineUp_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        QueryRoleLineUp_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a QueryRoleLineUp_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.QueryRoleLineUp_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.QueryRoleLineUp_Respond} QueryRoleLineUp_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoleLineUp_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.QueryRoleLineUp_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.Protocol.RankInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a QueryRoleLineUp_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.QueryRoleLineUp_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.QueryRoleLineUp_Respond} QueryRoleLineUp_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        QueryRoleLineUp_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a QueryRoleLineUp_Respond message.
         * @function verify
         * @memberof Protocol.QueryRoleLineUp_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        QueryRoleLineUp_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.Protocol.RankInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            return null;
        };

        return QueryRoleLineUp_Respond;
    })();

    Protocol.AllBox_Request = (function() {

        /**
         * Properties of an AllBox_Request.
         * @memberof Protocol
         * @interface IAllBox_Request
         */

        /**
         * Constructs a new AllBox_Request.
         * @memberof Protocol
         * @classdesc Represents an AllBox_Request.
         * @implements IAllBox_Request
         * @constructor
         * @param {Protocol.IAllBox_Request=} [properties] Properties to set
         */
        function AllBox_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AllBox_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.AllBox_Request
         * @static
         * @param {Protocol.IAllBox_Request=} [properties] Properties to set
         * @returns {Protocol.AllBox_Request} AllBox_Request instance
         */
        AllBox_Request.create = function create(properties) {
            return new AllBox_Request(properties);
        };

        /**
         * Encodes the specified AllBox_Request message. Does not implicitly {@link Protocol.AllBox_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AllBox_Request
         * @static
         * @param {Protocol.IAllBox_Request} message AllBox_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllBox_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AllBox_Request message, length delimited. Does not implicitly {@link Protocol.AllBox_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AllBox_Request
         * @static
         * @param {Protocol.IAllBox_Request} message AllBox_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllBox_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllBox_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AllBox_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AllBox_Request} AllBox_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllBox_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AllBox_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllBox_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AllBox_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AllBox_Request} AllBox_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllBox_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllBox_Request message.
         * @function verify
         * @memberof Protocol.AllBox_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllBox_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AllBox_Request;
    })();

    Protocol.AllBox_Respond = (function() {

        /**
         * Properties of an AllBox_Respond.
         * @memberof Protocol
         * @interface IAllBox_Respond
         * @property {Array.<Protocol.IBox>|null} [boxs] AllBox_Respond boxs
         */

        /**
         * Constructs a new AllBox_Respond.
         * @memberof Protocol
         * @classdesc Represents an AllBox_Respond.
         * @implements IAllBox_Respond
         * @constructor
         * @param {Protocol.IAllBox_Respond=} [properties] Properties to set
         */
        function AllBox_Respond(properties) {
            this.boxs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AllBox_Respond boxs.
         * @member {Array.<Protocol.IBox>} boxs
         * @memberof Protocol.AllBox_Respond
         * @instance
         */
        AllBox_Respond.prototype.boxs = $util.emptyArray;

        /**
         * Creates a new AllBox_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AllBox_Respond
         * @static
         * @param {Protocol.IAllBox_Respond=} [properties] Properties to set
         * @returns {Protocol.AllBox_Respond} AllBox_Respond instance
         */
        AllBox_Respond.create = function create(properties) {
            return new AllBox_Respond(properties);
        };

        /**
         * Encodes the specified AllBox_Respond message. Does not implicitly {@link Protocol.AllBox_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AllBox_Respond
         * @static
         * @param {Protocol.IAllBox_Respond} message AllBox_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllBox_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.boxs != null && message.boxs.length)
                for (var i = 0; i < message.boxs.length; ++i)
                    $root.Protocol.Box.encode(message.boxs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AllBox_Respond message, length delimited. Does not implicitly {@link Protocol.AllBox_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AllBox_Respond
         * @static
         * @param {Protocol.IAllBox_Respond} message AllBox_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AllBox_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AllBox_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AllBox_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AllBox_Respond} AllBox_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllBox_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AllBox_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.boxs && message.boxs.length))
                        message.boxs = [];
                    message.boxs.push($root.Protocol.Box.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AllBox_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AllBox_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AllBox_Respond} AllBox_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AllBox_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AllBox_Respond message.
         * @function verify
         * @memberof Protocol.AllBox_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AllBox_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.boxs != null && message.hasOwnProperty("boxs")) {
                if (!Array.isArray(message.boxs))
                    return "boxs: array expected";
                for (var i = 0; i < message.boxs.length; ++i) {
                    var error = $root.Protocol.Box.verify(message.boxs[i]);
                    if (error)
                        return "boxs." + error;
                }
            }
            return null;
        };

        return AllBox_Respond;
    })();

    Protocol.SingleBox_Respond = (function() {

        /**
         * Properties of a SingleBox_Respond.
         * @memberof Protocol
         * @interface ISingleBox_Respond
         * @property {Protocol.IBox|null} [box] SingleBox_Respond box
         */

        /**
         * Constructs a new SingleBox_Respond.
         * @memberof Protocol
         * @classdesc Represents a SingleBox_Respond.
         * @implements ISingleBox_Respond
         * @constructor
         * @param {Protocol.ISingleBox_Respond=} [properties] Properties to set
         */
        function SingleBox_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SingleBox_Respond box.
         * @member {Protocol.IBox|null|undefined} box
         * @memberof Protocol.SingleBox_Respond
         * @instance
         */
        SingleBox_Respond.prototype.box = null;

        /**
         * Creates a new SingleBox_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.SingleBox_Respond
         * @static
         * @param {Protocol.ISingleBox_Respond=} [properties] Properties to set
         * @returns {Protocol.SingleBox_Respond} SingleBox_Respond instance
         */
        SingleBox_Respond.create = function create(properties) {
            return new SingleBox_Respond(properties);
        };

        /**
         * Encodes the specified SingleBox_Respond message. Does not implicitly {@link Protocol.SingleBox_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SingleBox_Respond
         * @static
         * @param {Protocol.ISingleBox_Respond} message SingleBox_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SingleBox_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.box != null && message.hasOwnProperty("box"))
                $root.Protocol.Box.encode(message.box, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified SingleBox_Respond message, length delimited. Does not implicitly {@link Protocol.SingleBox_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SingleBox_Respond
         * @static
         * @param {Protocol.ISingleBox_Respond} message SingleBox_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SingleBox_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SingleBox_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SingleBox_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SingleBox_Respond} SingleBox_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SingleBox_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SingleBox_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.box = $root.Protocol.Box.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SingleBox_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SingleBox_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SingleBox_Respond} SingleBox_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SingleBox_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SingleBox_Respond message.
         * @function verify
         * @memberof Protocol.SingleBox_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SingleBox_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.box != null && message.hasOwnProperty("box")) {
                var error = $root.Protocol.Box.verify(message.box);
                if (error)
                    return "box." + error;
            }
            return null;
        };

        return SingleBox_Respond;
    })();

    Protocol.OpenBox_Request = (function() {

        /**
         * Properties of an OpenBox_Request.
         * @memberof Protocol
         * @interface IOpenBox_Request
         * @property {string|null} [id] OpenBox_Request id
         */

        /**
         * Constructs a new OpenBox_Request.
         * @memberof Protocol
         * @classdesc Represents an OpenBox_Request.
         * @implements IOpenBox_Request
         * @constructor
         * @param {Protocol.IOpenBox_Request=} [properties] Properties to set
         */
        function OpenBox_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenBox_Request id.
         * @member {string} id
         * @memberof Protocol.OpenBox_Request
         * @instance
         */
        OpenBox_Request.prototype.id = "";

        /**
         * Creates a new OpenBox_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.OpenBox_Request
         * @static
         * @param {Protocol.IOpenBox_Request=} [properties] Properties to set
         * @returns {Protocol.OpenBox_Request} OpenBox_Request instance
         */
        OpenBox_Request.create = function create(properties) {
            return new OpenBox_Request(properties);
        };

        /**
         * Encodes the specified OpenBox_Request message. Does not implicitly {@link Protocol.OpenBox_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.OpenBox_Request
         * @static
         * @param {Protocol.IOpenBox_Request} message OpenBox_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenBox_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified OpenBox_Request message, length delimited. Does not implicitly {@link Protocol.OpenBox_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.OpenBox_Request
         * @static
         * @param {Protocol.IOpenBox_Request} message OpenBox_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenBox_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenBox_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.OpenBox_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.OpenBox_Request} OpenBox_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenBox_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.OpenBox_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenBox_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.OpenBox_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.OpenBox_Request} OpenBox_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenBox_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenBox_Request message.
         * @function verify
         * @memberof Protocol.OpenBox_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenBox_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        return OpenBox_Request;
    })();

    Protocol.OpenBox_Respond = (function() {

        /**
         * Properties of an OpenBox_Respond.
         * @memberof Protocol
         * @interface IOpenBox_Respond
         * @property {string|null} [id] OpenBox_Respond id
         * @property {boolean|null} [ret] OpenBox_Respond ret
         */

        /**
         * Constructs a new OpenBox_Respond.
         * @memberof Protocol
         * @classdesc Represents an OpenBox_Respond.
         * @implements IOpenBox_Respond
         * @constructor
         * @param {Protocol.IOpenBox_Respond=} [properties] Properties to set
         */
        function OpenBox_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OpenBox_Respond id.
         * @member {string} id
         * @memberof Protocol.OpenBox_Respond
         * @instance
         */
        OpenBox_Respond.prototype.id = "";

        /**
         * OpenBox_Respond ret.
         * @member {boolean} ret
         * @memberof Protocol.OpenBox_Respond
         * @instance
         */
        OpenBox_Respond.prototype.ret = false;

        /**
         * Creates a new OpenBox_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.OpenBox_Respond
         * @static
         * @param {Protocol.IOpenBox_Respond=} [properties] Properties to set
         * @returns {Protocol.OpenBox_Respond} OpenBox_Respond instance
         */
        OpenBox_Respond.create = function create(properties) {
            return new OpenBox_Respond(properties);
        };

        /**
         * Encodes the specified OpenBox_Respond message. Does not implicitly {@link Protocol.OpenBox_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.OpenBox_Respond
         * @static
         * @param {Protocol.IOpenBox_Respond} message OpenBox_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenBox_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ret);
            return writer;
        };

        /**
         * Encodes the specified OpenBox_Respond message, length delimited. Does not implicitly {@link Protocol.OpenBox_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.OpenBox_Respond
         * @static
         * @param {Protocol.IOpenBox_Respond} message OpenBox_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OpenBox_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OpenBox_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.OpenBox_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.OpenBox_Respond} OpenBox_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenBox_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.OpenBox_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.ret = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OpenBox_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.OpenBox_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.OpenBox_Respond} OpenBox_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OpenBox_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OpenBox_Respond message.
         * @function verify
         * @memberof Protocol.OpenBox_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OpenBox_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (typeof message.ret !== "boolean")
                    return "ret: boolean expected";
            return null;
        };

        return OpenBox_Respond;
    })();

    Protocol.GetBox_Request = (function() {

        /**
         * Properties of a GetBox_Request.
         * @memberof Protocol
         * @interface IGetBox_Request
         * @property {string|null} [id] GetBox_Request id
         */

        /**
         * Constructs a new GetBox_Request.
         * @memberof Protocol
         * @classdesc Represents a GetBox_Request.
         * @implements IGetBox_Request
         * @constructor
         * @param {Protocol.IGetBox_Request=} [properties] Properties to set
         */
        function GetBox_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetBox_Request id.
         * @member {string} id
         * @memberof Protocol.GetBox_Request
         * @instance
         */
        GetBox_Request.prototype.id = "";

        /**
         * Creates a new GetBox_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.GetBox_Request
         * @static
         * @param {Protocol.IGetBox_Request=} [properties] Properties to set
         * @returns {Protocol.GetBox_Request} GetBox_Request instance
         */
        GetBox_Request.create = function create(properties) {
            return new GetBox_Request(properties);
        };

        /**
         * Encodes the specified GetBox_Request message. Does not implicitly {@link Protocol.GetBox_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetBox_Request
         * @static
         * @param {Protocol.IGetBox_Request} message GetBox_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBox_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified GetBox_Request message, length delimited. Does not implicitly {@link Protocol.GetBox_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetBox_Request
         * @static
         * @param {Protocol.IGetBox_Request} message GetBox_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBox_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetBox_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetBox_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetBox_Request} GetBox_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBox_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetBox_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetBox_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetBox_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetBox_Request} GetBox_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBox_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetBox_Request message.
         * @function verify
         * @memberof Protocol.GetBox_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetBox_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        return GetBox_Request;
    })();

    Protocol.GetBox_Respond = (function() {

        /**
         * Properties of a GetBox_Respond.
         * @memberof Protocol
         * @interface IGetBox_Respond
         * @property {string|null} [id] GetBox_Respond id
         * @property {boolean|null} [ret] GetBox_Respond ret
         */

        /**
         * Constructs a new GetBox_Respond.
         * @memberof Protocol
         * @classdesc Represents a GetBox_Respond.
         * @implements IGetBox_Respond
         * @constructor
         * @param {Protocol.IGetBox_Respond=} [properties] Properties to set
         */
        function GetBox_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetBox_Respond id.
         * @member {string} id
         * @memberof Protocol.GetBox_Respond
         * @instance
         */
        GetBox_Respond.prototype.id = "";

        /**
         * GetBox_Respond ret.
         * @member {boolean} ret
         * @memberof Protocol.GetBox_Respond
         * @instance
         */
        GetBox_Respond.prototype.ret = false;

        /**
         * Creates a new GetBox_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.GetBox_Respond
         * @static
         * @param {Protocol.IGetBox_Respond=} [properties] Properties to set
         * @returns {Protocol.GetBox_Respond} GetBox_Respond instance
         */
        GetBox_Respond.create = function create(properties) {
            return new GetBox_Respond(properties);
        };

        /**
         * Encodes the specified GetBox_Respond message. Does not implicitly {@link Protocol.GetBox_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetBox_Respond
         * @static
         * @param {Protocol.IGetBox_Respond} message GetBox_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBox_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.ret);
            return writer;
        };

        /**
         * Encodes the specified GetBox_Respond message, length delimited. Does not implicitly {@link Protocol.GetBox_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetBox_Respond
         * @static
         * @param {Protocol.IGetBox_Respond} message GetBox_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetBox_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetBox_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetBox_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetBox_Respond} GetBox_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBox_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetBox_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.ret = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetBox_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetBox_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetBox_Respond} GetBox_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetBox_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetBox_Respond message.
         * @function verify
         * @memberof Protocol.GetBox_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetBox_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (typeof message.ret !== "boolean")
                    return "ret: boolean expected";
            return null;
        };

        return GetBox_Respond;
    })();

    Protocol.DeleteBox_Respond = (function() {

        /**
         * Properties of a DeleteBox_Respond.
         * @memberof Protocol
         * @interface IDeleteBox_Respond
         * @property {string|null} [id] DeleteBox_Respond id
         */

        /**
         * Constructs a new DeleteBox_Respond.
         * @memberof Protocol
         * @classdesc Represents a DeleteBox_Respond.
         * @implements IDeleteBox_Respond
         * @constructor
         * @param {Protocol.IDeleteBox_Respond=} [properties] Properties to set
         */
        function DeleteBox_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeleteBox_Respond id.
         * @member {string} id
         * @memberof Protocol.DeleteBox_Respond
         * @instance
         */
        DeleteBox_Respond.prototype.id = "";

        /**
         * Creates a new DeleteBox_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.DeleteBox_Respond
         * @static
         * @param {Protocol.IDeleteBox_Respond=} [properties] Properties to set
         * @returns {Protocol.DeleteBox_Respond} DeleteBox_Respond instance
         */
        DeleteBox_Respond.create = function create(properties) {
            return new DeleteBox_Respond(properties);
        };

        /**
         * Encodes the specified DeleteBox_Respond message. Does not implicitly {@link Protocol.DeleteBox_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.DeleteBox_Respond
         * @static
         * @param {Protocol.IDeleteBox_Respond} message DeleteBox_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteBox_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified DeleteBox_Respond message, length delimited. Does not implicitly {@link Protocol.DeleteBox_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.DeleteBox_Respond
         * @static
         * @param {Protocol.IDeleteBox_Respond} message DeleteBox_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeleteBox_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeleteBox_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.DeleteBox_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.DeleteBox_Respond} DeleteBox_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteBox_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.DeleteBox_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeleteBox_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.DeleteBox_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.DeleteBox_Respond} DeleteBox_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeleteBox_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeleteBox_Respond message.
         * @function verify
         * @memberof Protocol.DeleteBox_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeleteBox_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        return DeleteBox_Respond;
    })();

    Protocol.BoxReward_Respond = (function() {

        /**
         * Properties of a BoxReward_Respond.
         * @memberof Protocol
         * @interface IBoxReward_Respond
         * @property {Array.<Protocol.IReward>|null} [rewards] BoxReward_Respond rewards
         * @property {number|null} [boxId] BoxReward_Respond boxId
         */

        /**
         * Constructs a new BoxReward_Respond.
         * @memberof Protocol
         * @classdesc Represents a BoxReward_Respond.
         * @implements IBoxReward_Respond
         * @constructor
         * @param {Protocol.IBoxReward_Respond=} [properties] Properties to set
         */
        function BoxReward_Respond(properties) {
            this.rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BoxReward_Respond rewards.
         * @member {Array.<Protocol.IReward>} rewards
         * @memberof Protocol.BoxReward_Respond
         * @instance
         */
        BoxReward_Respond.prototype.rewards = $util.emptyArray;

        /**
         * BoxReward_Respond boxId.
         * @member {number} boxId
         * @memberof Protocol.BoxReward_Respond
         * @instance
         */
        BoxReward_Respond.prototype.boxId = 0;

        /**
         * Creates a new BoxReward_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.BoxReward_Respond
         * @static
         * @param {Protocol.IBoxReward_Respond=} [properties] Properties to set
         * @returns {Protocol.BoxReward_Respond} BoxReward_Respond instance
         */
        BoxReward_Respond.create = function create(properties) {
            return new BoxReward_Respond(properties);
        };

        /**
         * Encodes the specified BoxReward_Respond message. Does not implicitly {@link Protocol.BoxReward_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BoxReward_Respond
         * @static
         * @param {Protocol.IBoxReward_Respond} message BoxReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BoxReward_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rewards != null && message.rewards.length)
                for (var i = 0; i < message.rewards.length; ++i)
                    $root.Protocol.Reward.encode(message.rewards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.boxId != null && message.hasOwnProperty("boxId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.boxId);
            return writer;
        };

        /**
         * Encodes the specified BoxReward_Respond message, length delimited. Does not implicitly {@link Protocol.BoxReward_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BoxReward_Respond
         * @static
         * @param {Protocol.IBoxReward_Respond} message BoxReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BoxReward_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BoxReward_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BoxReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BoxReward_Respond} BoxReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BoxReward_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BoxReward_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.rewards && message.rewards.length))
                        message.rewards = [];
                    message.rewards.push($root.Protocol.Reward.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.boxId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BoxReward_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BoxReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BoxReward_Respond} BoxReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BoxReward_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BoxReward_Respond message.
         * @function verify
         * @memberof Protocol.BoxReward_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BoxReward_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                if (!Array.isArray(message.rewards))
                    return "rewards: array expected";
                for (var i = 0; i < message.rewards.length; ++i) {
                    var error = $root.Protocol.Reward.verify(message.rewards[i]);
                    if (error)
                        return "rewards." + error;
                }
            }
            if (message.boxId != null && message.hasOwnProperty("boxId"))
                if (!$util.isInteger(message.boxId))
                    return "boxId: integer expected";
            return null;
        };

        return BoxReward_Respond;
    })();

    Protocol.CostKey_Request = (function() {

        /**
         * Properties of a CostKey_Request.
         * @memberof Protocol
         * @interface ICostKey_Request
         * @property {string|null} [id] CostKey_Request id
         */

        /**
         * Constructs a new CostKey_Request.
         * @memberof Protocol
         * @classdesc Represents a CostKey_Request.
         * @implements ICostKey_Request
         * @constructor
         * @param {Protocol.ICostKey_Request=} [properties] Properties to set
         */
        function CostKey_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CostKey_Request id.
         * @member {string} id
         * @memberof Protocol.CostKey_Request
         * @instance
         */
        CostKey_Request.prototype.id = "";

        /**
         * Creates a new CostKey_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.CostKey_Request
         * @static
         * @param {Protocol.ICostKey_Request=} [properties] Properties to set
         * @returns {Protocol.CostKey_Request} CostKey_Request instance
         */
        CostKey_Request.create = function create(properties) {
            return new CostKey_Request(properties);
        };

        /**
         * Encodes the specified CostKey_Request message. Does not implicitly {@link Protocol.CostKey_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.CostKey_Request
         * @static
         * @param {Protocol.ICostKey_Request} message CostKey_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CostKey_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            return writer;
        };

        /**
         * Encodes the specified CostKey_Request message, length delimited. Does not implicitly {@link Protocol.CostKey_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.CostKey_Request
         * @static
         * @param {Protocol.ICostKey_Request} message CostKey_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CostKey_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CostKey_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.CostKey_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.CostKey_Request} CostKey_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CostKey_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.CostKey_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CostKey_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.CostKey_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.CostKey_Request} CostKey_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CostKey_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CostKey_Request message.
         * @function verify
         * @memberof Protocol.CostKey_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CostKey_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            return null;
        };

        return CostKey_Request;
    })();

    Protocol.CostKey_Respond = (function() {

        /**
         * Properties of a CostKey_Respond.
         * @memberof Protocol
         * @interface ICostKey_Respond
         * @property {number|null} [ret] CostKey_Respond ret
         */

        /**
         * Constructs a new CostKey_Respond.
         * @memberof Protocol
         * @classdesc Represents a CostKey_Respond.
         * @implements ICostKey_Respond
         * @constructor
         * @param {Protocol.ICostKey_Respond=} [properties] Properties to set
         */
        function CostKey_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CostKey_Respond ret.
         * @member {number} ret
         * @memberof Protocol.CostKey_Respond
         * @instance
         */
        CostKey_Respond.prototype.ret = 0;

        /**
         * Creates a new CostKey_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.CostKey_Respond
         * @static
         * @param {Protocol.ICostKey_Respond=} [properties] Properties to set
         * @returns {Protocol.CostKey_Respond} CostKey_Respond instance
         */
        CostKey_Respond.create = function create(properties) {
            return new CostKey_Respond(properties);
        };

        /**
         * Encodes the specified CostKey_Respond message. Does not implicitly {@link Protocol.CostKey_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.CostKey_Respond
         * @static
         * @param {Protocol.ICostKey_Respond} message CostKey_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CostKey_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified CostKey_Respond message, length delimited. Does not implicitly {@link Protocol.CostKey_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.CostKey_Respond
         * @static
         * @param {Protocol.ICostKey_Respond} message CostKey_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CostKey_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CostKey_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.CostKey_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.CostKey_Respond} CostKey_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CostKey_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.CostKey_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CostKey_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.CostKey_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.CostKey_Respond} CostKey_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CostKey_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CostKey_Respond message.
         * @function verify
         * @memberof Protocol.CostKey_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CostKey_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return CostKey_Respond;
    })();

    Protocol.BuyKey_Request = (function() {

        /**
         * Properties of a BuyKey_Request.
         * @memberof Protocol
         * @interface IBuyKey_Request
         * @property {number|null} [diamond] BuyKey_Request diamond
         */

        /**
         * Constructs a new BuyKey_Request.
         * @memberof Protocol
         * @classdesc Represents a BuyKey_Request.
         * @implements IBuyKey_Request
         * @constructor
         * @param {Protocol.IBuyKey_Request=} [properties] Properties to set
         */
        function BuyKey_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyKey_Request diamond.
         * @member {number} diamond
         * @memberof Protocol.BuyKey_Request
         * @instance
         */
        BuyKey_Request.prototype.diamond = 0;

        /**
         * Creates a new BuyKey_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.BuyKey_Request
         * @static
         * @param {Protocol.IBuyKey_Request=} [properties] Properties to set
         * @returns {Protocol.BuyKey_Request} BuyKey_Request instance
         */
        BuyKey_Request.create = function create(properties) {
            return new BuyKey_Request(properties);
        };

        /**
         * Encodes the specified BuyKey_Request message. Does not implicitly {@link Protocol.BuyKey_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BuyKey_Request
         * @static
         * @param {Protocol.IBuyKey_Request} message BuyKey_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyKey_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.diamond != null && message.hasOwnProperty("diamond"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.diamond);
            return writer;
        };

        /**
         * Encodes the specified BuyKey_Request message, length delimited. Does not implicitly {@link Protocol.BuyKey_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BuyKey_Request
         * @static
         * @param {Protocol.IBuyKey_Request} message BuyKey_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyKey_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyKey_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BuyKey_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BuyKey_Request} BuyKey_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyKey_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BuyKey_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.diamond = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyKey_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BuyKey_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BuyKey_Request} BuyKey_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyKey_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyKey_Request message.
         * @function verify
         * @memberof Protocol.BuyKey_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyKey_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.diamond != null && message.hasOwnProperty("diamond"))
                if (!$util.isInteger(message.diamond))
                    return "diamond: integer expected";
            return null;
        };

        return BuyKey_Request;
    })();

    Protocol.BuyKey_Respond = (function() {

        /**
         * Properties of a BuyKey_Respond.
         * @memberof Protocol
         * @interface IBuyKey_Respond
         * @property {number|null} [ret] BuyKey_Respond ret
         */

        /**
         * Constructs a new BuyKey_Respond.
         * @memberof Protocol
         * @classdesc Represents a BuyKey_Respond.
         * @implements IBuyKey_Respond
         * @constructor
         * @param {Protocol.IBuyKey_Respond=} [properties] Properties to set
         */
        function BuyKey_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyKey_Respond ret.
         * @member {number} ret
         * @memberof Protocol.BuyKey_Respond
         * @instance
         */
        BuyKey_Respond.prototype.ret = 0;

        /**
         * Creates a new BuyKey_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.BuyKey_Respond
         * @static
         * @param {Protocol.IBuyKey_Respond=} [properties] Properties to set
         * @returns {Protocol.BuyKey_Respond} BuyKey_Respond instance
         */
        BuyKey_Respond.create = function create(properties) {
            return new BuyKey_Respond(properties);
        };

        /**
         * Encodes the specified BuyKey_Respond message. Does not implicitly {@link Protocol.BuyKey_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BuyKey_Respond
         * @static
         * @param {Protocol.IBuyKey_Respond} message BuyKey_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyKey_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified BuyKey_Respond message, length delimited. Does not implicitly {@link Protocol.BuyKey_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BuyKey_Respond
         * @static
         * @param {Protocol.IBuyKey_Respond} message BuyKey_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyKey_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyKey_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BuyKey_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BuyKey_Respond} BuyKey_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyKey_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BuyKey_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyKey_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BuyKey_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BuyKey_Respond} BuyKey_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyKey_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyKey_Respond message.
         * @function verify
         * @memberof Protocol.BuyKey_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyKey_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return BuyKey_Respond;
    })();

    Protocol.BuyTaskTime_Request = (function() {

        /**
         * Properties of a BuyTaskTime_Request.
         * @memberof Protocol
         * @interface IBuyTaskTime_Request
         * @property {number|null} [taskId] BuyTaskTime_Request taskId
         */

        /**
         * Constructs a new BuyTaskTime_Request.
         * @memberof Protocol
         * @classdesc Represents a BuyTaskTime_Request.
         * @implements IBuyTaskTime_Request
         * @constructor
         * @param {Protocol.IBuyTaskTime_Request=} [properties] Properties to set
         */
        function BuyTaskTime_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyTaskTime_Request taskId.
         * @member {number} taskId
         * @memberof Protocol.BuyTaskTime_Request
         * @instance
         */
        BuyTaskTime_Request.prototype.taskId = 0;

        /**
         * Creates a new BuyTaskTime_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.BuyTaskTime_Request
         * @static
         * @param {Protocol.IBuyTaskTime_Request=} [properties] Properties to set
         * @returns {Protocol.BuyTaskTime_Request} BuyTaskTime_Request instance
         */
        BuyTaskTime_Request.create = function create(properties) {
            return new BuyTaskTime_Request(properties);
        };

        /**
         * Encodes the specified BuyTaskTime_Request message. Does not implicitly {@link Protocol.BuyTaskTime_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BuyTaskTime_Request
         * @static
         * @param {Protocol.IBuyTaskTime_Request} message BuyTaskTime_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTaskTime_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskId);
            return writer;
        };

        /**
         * Encodes the specified BuyTaskTime_Request message, length delimited. Does not implicitly {@link Protocol.BuyTaskTime_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BuyTaskTime_Request
         * @static
         * @param {Protocol.IBuyTaskTime_Request} message BuyTaskTime_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTaskTime_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyTaskTime_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BuyTaskTime_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BuyTaskTime_Request} BuyTaskTime_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTaskTime_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BuyTaskTime_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyTaskTime_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BuyTaskTime_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BuyTaskTime_Request} BuyTaskTime_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTaskTime_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyTaskTime_Request message.
         * @function verify
         * @memberof Protocol.BuyTaskTime_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyTaskTime_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                if (!$util.isInteger(message.taskId))
                    return "taskId: integer expected";
            return null;
        };

        return BuyTaskTime_Request;
    })();

    Protocol.BuyTaskTime_Respond = (function() {

        /**
         * Properties of a BuyTaskTime_Respond.
         * @memberof Protocol
         * @interface IBuyTaskTime_Respond
         * @property {number|null} [ret] BuyTaskTime_Respond ret
         */

        /**
         * Constructs a new BuyTaskTime_Respond.
         * @memberof Protocol
         * @classdesc Represents a BuyTaskTime_Respond.
         * @implements IBuyTaskTime_Respond
         * @constructor
         * @param {Protocol.IBuyTaskTime_Respond=} [properties] Properties to set
         */
        function BuyTaskTime_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyTaskTime_Respond ret.
         * @member {number} ret
         * @memberof Protocol.BuyTaskTime_Respond
         * @instance
         */
        BuyTaskTime_Respond.prototype.ret = 0;

        /**
         * Creates a new BuyTaskTime_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.BuyTaskTime_Respond
         * @static
         * @param {Protocol.IBuyTaskTime_Respond=} [properties] Properties to set
         * @returns {Protocol.BuyTaskTime_Respond} BuyTaskTime_Respond instance
         */
        BuyTaskTime_Respond.create = function create(properties) {
            return new BuyTaskTime_Respond(properties);
        };

        /**
         * Encodes the specified BuyTaskTime_Respond message. Does not implicitly {@link Protocol.BuyTaskTime_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BuyTaskTime_Respond
         * @static
         * @param {Protocol.IBuyTaskTime_Respond} message BuyTaskTime_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTaskTime_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified BuyTaskTime_Respond message, length delimited. Does not implicitly {@link Protocol.BuyTaskTime_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BuyTaskTime_Respond
         * @static
         * @param {Protocol.IBuyTaskTime_Respond} message BuyTaskTime_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyTaskTime_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyTaskTime_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BuyTaskTime_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BuyTaskTime_Respond} BuyTaskTime_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTaskTime_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BuyTaskTime_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyTaskTime_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BuyTaskTime_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BuyTaskTime_Respond} BuyTaskTime_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyTaskTime_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyTaskTime_Respond message.
         * @function verify
         * @memberof Protocol.BuyTaskTime_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyTaskTime_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return BuyTaskTime_Respond;
    })();

    Protocol.ChangeName_Request = (function() {

        /**
         * Properties of a ChangeName_Request.
         * @memberof Protocol
         * @interface IChangeName_Request
         * @property {string|null} [name] ChangeName_Request name
         */

        /**
         * Constructs a new ChangeName_Request.
         * @memberof Protocol
         * @classdesc Represents a ChangeName_Request.
         * @implements IChangeName_Request
         * @constructor
         * @param {Protocol.IChangeName_Request=} [properties] Properties to set
         */
        function ChangeName_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeName_Request name.
         * @member {string} name
         * @memberof Protocol.ChangeName_Request
         * @instance
         */
        ChangeName_Request.prototype.name = "";

        /**
         * Creates a new ChangeName_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.ChangeName_Request
         * @static
         * @param {Protocol.IChangeName_Request=} [properties] Properties to set
         * @returns {Protocol.ChangeName_Request} ChangeName_Request instance
         */
        ChangeName_Request.create = function create(properties) {
            return new ChangeName_Request(properties);
        };

        /**
         * Encodes the specified ChangeName_Request message. Does not implicitly {@link Protocol.ChangeName_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.ChangeName_Request
         * @static
         * @param {Protocol.IChangeName_Request} message ChangeName_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeName_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified ChangeName_Request message, length delimited. Does not implicitly {@link Protocol.ChangeName_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.ChangeName_Request
         * @static
         * @param {Protocol.IChangeName_Request} message ChangeName_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeName_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeName_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.ChangeName_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.ChangeName_Request} ChangeName_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeName_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.ChangeName_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeName_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.ChangeName_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.ChangeName_Request} ChangeName_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeName_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeName_Request message.
         * @function verify
         * @memberof Protocol.ChangeName_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeName_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        return ChangeName_Request;
    })();

    Protocol.ChangeName_Respond = (function() {

        /**
         * Properties of a ChangeName_Respond.
         * @memberof Protocol
         * @interface IChangeName_Respond
         * @property {number|null} [ret] ChangeName_Respond ret
         * @property {string|null} [name] ChangeName_Respond name
         */

        /**
         * Constructs a new ChangeName_Respond.
         * @memberof Protocol
         * @classdesc Represents a ChangeName_Respond.
         * @implements IChangeName_Respond
         * @constructor
         * @param {Protocol.IChangeName_Respond=} [properties] Properties to set
         */
        function ChangeName_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeName_Respond ret.
         * @member {number} ret
         * @memberof Protocol.ChangeName_Respond
         * @instance
         */
        ChangeName_Respond.prototype.ret = 0;

        /**
         * ChangeName_Respond name.
         * @member {string} name
         * @memberof Protocol.ChangeName_Respond
         * @instance
         */
        ChangeName_Respond.prototype.name = "";

        /**
         * Creates a new ChangeName_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.ChangeName_Respond
         * @static
         * @param {Protocol.IChangeName_Respond=} [properties] Properties to set
         * @returns {Protocol.ChangeName_Respond} ChangeName_Respond instance
         */
        ChangeName_Respond.create = function create(properties) {
            return new ChangeName_Respond(properties);
        };

        /**
         * Encodes the specified ChangeName_Respond message. Does not implicitly {@link Protocol.ChangeName_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.ChangeName_Respond
         * @static
         * @param {Protocol.IChangeName_Respond} message ChangeName_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeName_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified ChangeName_Respond message, length delimited. Does not implicitly {@link Protocol.ChangeName_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.ChangeName_Respond
         * @static
         * @param {Protocol.IChangeName_Respond} message ChangeName_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeName_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeName_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.ChangeName_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.ChangeName_Respond} ChangeName_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeName_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.ChangeName_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeName_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.ChangeName_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.ChangeName_Respond} ChangeName_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeName_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeName_Respond message.
         * @function verify
         * @memberof Protocol.ChangeName_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeName_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        return ChangeName_Respond;
    })();

    Protocol.WarGodInfo_Request = (function() {

        /**
         * Properties of a WarGodInfo_Request.
         * @memberof Protocol
         * @interface IWarGodInfo_Request
         */

        /**
         * Constructs a new WarGodInfo_Request.
         * @memberof Protocol
         * @classdesc Represents a WarGodInfo_Request.
         * @implements IWarGodInfo_Request
         * @constructor
         * @param {Protocol.IWarGodInfo_Request=} [properties] Properties to set
         */
        function WarGodInfo_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new WarGodInfo_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.WarGodInfo_Request
         * @static
         * @param {Protocol.IWarGodInfo_Request=} [properties] Properties to set
         * @returns {Protocol.WarGodInfo_Request} WarGodInfo_Request instance
         */
        WarGodInfo_Request.create = function create(properties) {
            return new WarGodInfo_Request(properties);
        };

        /**
         * Encodes the specified WarGodInfo_Request message. Does not implicitly {@link Protocol.WarGodInfo_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.WarGodInfo_Request
         * @static
         * @param {Protocol.IWarGodInfo_Request} message WarGodInfo_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarGodInfo_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified WarGodInfo_Request message, length delimited. Does not implicitly {@link Protocol.WarGodInfo_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.WarGodInfo_Request
         * @static
         * @param {Protocol.IWarGodInfo_Request} message WarGodInfo_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarGodInfo_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarGodInfo_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.WarGodInfo_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.WarGodInfo_Request} WarGodInfo_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarGodInfo_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.WarGodInfo_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WarGodInfo_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.WarGodInfo_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.WarGodInfo_Request} WarGodInfo_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarGodInfo_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarGodInfo_Request message.
         * @function verify
         * @memberof Protocol.WarGodInfo_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarGodInfo_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return WarGodInfo_Request;
    })();

    Protocol.WarGodInfo_Respond = (function() {

        /**
         * Properties of a WarGodInfo_Respond.
         * @memberof Protocol
         * @interface IWarGodInfo_Respond
         * @property {string|null} [begin] WarGodInfo_Respond begin
         * @property {string|null} [end] WarGodInfo_Respond end
         * @property {boolean|null} [state] WarGodInfo_Respond state
         * @property {Array.<Protocol.IWarGodGettedInfo>|null} [infos] WarGodInfo_Respond infos
         * @property {string|null} [warGodCode] WarGodInfo_Respond warGodCode
         * @property {string|null} [selfWarGodCode] WarGodInfo_Respond selfWarGodCode
         */

        /**
         * Constructs a new WarGodInfo_Respond.
         * @memberof Protocol
         * @classdesc Represents a WarGodInfo_Respond.
         * @implements IWarGodInfo_Respond
         * @constructor
         * @param {Protocol.IWarGodInfo_Respond=} [properties] Properties to set
         */
        function WarGodInfo_Respond(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarGodInfo_Respond begin.
         * @member {string} begin
         * @memberof Protocol.WarGodInfo_Respond
         * @instance
         */
        WarGodInfo_Respond.prototype.begin = "";

        /**
         * WarGodInfo_Respond end.
         * @member {string} end
         * @memberof Protocol.WarGodInfo_Respond
         * @instance
         */
        WarGodInfo_Respond.prototype.end = "";

        /**
         * WarGodInfo_Respond state.
         * @member {boolean} state
         * @memberof Protocol.WarGodInfo_Respond
         * @instance
         */
        WarGodInfo_Respond.prototype.state = false;

        /**
         * WarGodInfo_Respond infos.
         * @member {Array.<Protocol.IWarGodGettedInfo>} infos
         * @memberof Protocol.WarGodInfo_Respond
         * @instance
         */
        WarGodInfo_Respond.prototype.infos = $util.emptyArray;

        /**
         * WarGodInfo_Respond warGodCode.
         * @member {string} warGodCode
         * @memberof Protocol.WarGodInfo_Respond
         * @instance
         */
        WarGodInfo_Respond.prototype.warGodCode = "";

        /**
         * WarGodInfo_Respond selfWarGodCode.
         * @member {string} selfWarGodCode
         * @memberof Protocol.WarGodInfo_Respond
         * @instance
         */
        WarGodInfo_Respond.prototype.selfWarGodCode = "";

        /**
         * Creates a new WarGodInfo_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.WarGodInfo_Respond
         * @static
         * @param {Protocol.IWarGodInfo_Respond=} [properties] Properties to set
         * @returns {Protocol.WarGodInfo_Respond} WarGodInfo_Respond instance
         */
        WarGodInfo_Respond.create = function create(properties) {
            return new WarGodInfo_Respond(properties);
        };

        /**
         * Encodes the specified WarGodInfo_Respond message. Does not implicitly {@link Protocol.WarGodInfo_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.WarGodInfo_Respond
         * @static
         * @param {Protocol.IWarGodInfo_Respond} message WarGodInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarGodInfo_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.begin != null && message.hasOwnProperty("begin"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.begin);
            if (message.end != null && message.hasOwnProperty("end"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.end);
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.state);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.Protocol.WarGodGettedInfo.encode(message.infos[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.warGodCode != null && message.hasOwnProperty("warGodCode"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.warGodCode);
            if (message.selfWarGodCode != null && message.hasOwnProperty("selfWarGodCode"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.selfWarGodCode);
            return writer;
        };

        /**
         * Encodes the specified WarGodInfo_Respond message, length delimited. Does not implicitly {@link Protocol.WarGodInfo_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.WarGodInfo_Respond
         * @static
         * @param {Protocol.IWarGodInfo_Respond} message WarGodInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarGodInfo_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarGodInfo_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.WarGodInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.WarGodInfo_Respond} WarGodInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarGodInfo_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.WarGodInfo_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.begin = reader.string();
                    break;
                case 2:
                    message.end = reader.string();
                    break;
                case 3:
                    message.state = reader.bool();
                    break;
                case 4:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.Protocol.WarGodGettedInfo.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.warGodCode = reader.string();
                    break;
                case 6:
                    message.selfWarGodCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WarGodInfo_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.WarGodInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.WarGodInfo_Respond} WarGodInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarGodInfo_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarGodInfo_Respond message.
         * @function verify
         * @memberof Protocol.WarGodInfo_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarGodInfo_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.begin != null && message.hasOwnProperty("begin"))
                if (!$util.isString(message.begin))
                    return "begin: string expected";
            if (message.end != null && message.hasOwnProperty("end"))
                if (!$util.isString(message.end))
                    return "end: string expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (typeof message.state !== "boolean")
                    return "state: boolean expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.Protocol.WarGodGettedInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.warGodCode != null && message.hasOwnProperty("warGodCode"))
                if (!$util.isString(message.warGodCode))
                    return "warGodCode: string expected";
            if (message.selfWarGodCode != null && message.hasOwnProperty("selfWarGodCode"))
                if (!$util.isString(message.selfWarGodCode))
                    return "selfWarGodCode: string expected";
            return null;
        };

        return WarGodInfo_Respond;
    })();

    Protocol.WarGodReward_Request = (function() {

        /**
         * Properties of a WarGodReward_Request.
         * @memberof Protocol
         * @interface IWarGodReward_Request
         * @property {number|null} [index] WarGodReward_Request index
         * @property {boolean|null} [type] WarGodReward_Request type
         */

        /**
         * Constructs a new WarGodReward_Request.
         * @memberof Protocol
         * @classdesc Represents a WarGodReward_Request.
         * @implements IWarGodReward_Request
         * @constructor
         * @param {Protocol.IWarGodReward_Request=} [properties] Properties to set
         */
        function WarGodReward_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarGodReward_Request index.
         * @member {number} index
         * @memberof Protocol.WarGodReward_Request
         * @instance
         */
        WarGodReward_Request.prototype.index = 0;

        /**
         * WarGodReward_Request type.
         * @member {boolean} type
         * @memberof Protocol.WarGodReward_Request
         * @instance
         */
        WarGodReward_Request.prototype.type = false;

        /**
         * Creates a new WarGodReward_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.WarGodReward_Request
         * @static
         * @param {Protocol.IWarGodReward_Request=} [properties] Properties to set
         * @returns {Protocol.WarGodReward_Request} WarGodReward_Request instance
         */
        WarGodReward_Request.create = function create(properties) {
            return new WarGodReward_Request(properties);
        };

        /**
         * Encodes the specified WarGodReward_Request message. Does not implicitly {@link Protocol.WarGodReward_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.WarGodReward_Request
         * @static
         * @param {Protocol.IWarGodReward_Request} message WarGodReward_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarGodReward_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.type);
            return writer;
        };

        /**
         * Encodes the specified WarGodReward_Request message, length delimited. Does not implicitly {@link Protocol.WarGodReward_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.WarGodReward_Request
         * @static
         * @param {Protocol.IWarGodReward_Request} message WarGodReward_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarGodReward_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarGodReward_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.WarGodReward_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.WarGodReward_Request} WarGodReward_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarGodReward_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.WarGodReward_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.type = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WarGodReward_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.WarGodReward_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.WarGodReward_Request} WarGodReward_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarGodReward_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarGodReward_Request message.
         * @function verify
         * @memberof Protocol.WarGodReward_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarGodReward_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (typeof message.type !== "boolean")
                    return "type: boolean expected";
            return null;
        };

        return WarGodReward_Request;
    })();

    Protocol.WarGodReward_Respond = (function() {

        /**
         * Properties of a WarGodReward_Respond.
         * @memberof Protocol
         * @interface IWarGodReward_Respond
         * @property {number|null} [index] WarGodReward_Respond index
         * @property {number|null} [ret] WarGodReward_Respond ret
         * @property {boolean|null} [type] WarGodReward_Respond type
         */

        /**
         * Constructs a new WarGodReward_Respond.
         * @memberof Protocol
         * @classdesc Represents a WarGodReward_Respond.
         * @implements IWarGodReward_Respond
         * @constructor
         * @param {Protocol.IWarGodReward_Respond=} [properties] Properties to set
         */
        function WarGodReward_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarGodReward_Respond index.
         * @member {number} index
         * @memberof Protocol.WarGodReward_Respond
         * @instance
         */
        WarGodReward_Respond.prototype.index = 0;

        /**
         * WarGodReward_Respond ret.
         * @member {number} ret
         * @memberof Protocol.WarGodReward_Respond
         * @instance
         */
        WarGodReward_Respond.prototype.ret = 0;

        /**
         * WarGodReward_Respond type.
         * @member {boolean} type
         * @memberof Protocol.WarGodReward_Respond
         * @instance
         */
        WarGodReward_Respond.prototype.type = false;

        /**
         * Creates a new WarGodReward_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.WarGodReward_Respond
         * @static
         * @param {Protocol.IWarGodReward_Respond=} [properties] Properties to set
         * @returns {Protocol.WarGodReward_Respond} WarGodReward_Respond instance
         */
        WarGodReward_Respond.create = function create(properties) {
            return new WarGodReward_Respond(properties);
        };

        /**
         * Encodes the specified WarGodReward_Respond message. Does not implicitly {@link Protocol.WarGodReward_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.WarGodReward_Respond
         * @static
         * @param {Protocol.IWarGodReward_Respond} message WarGodReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarGodReward_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ret);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.type);
            return writer;
        };

        /**
         * Encodes the specified WarGodReward_Respond message, length delimited. Does not implicitly {@link Protocol.WarGodReward_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.WarGodReward_Respond
         * @static
         * @param {Protocol.IWarGodReward_Respond} message WarGodReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarGodReward_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarGodReward_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.WarGodReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.WarGodReward_Respond} WarGodReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarGodReward_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.WarGodReward_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.ret = reader.int32();
                    break;
                case 3:
                    message.type = reader.bool();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WarGodReward_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.WarGodReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.WarGodReward_Respond} WarGodReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarGodReward_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarGodReward_Respond message.
         * @function verify
         * @memberof Protocol.WarGodReward_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarGodReward_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (typeof message.type !== "boolean")
                    return "type: boolean expected";
            return null;
        };

        return WarGodReward_Respond;
    })();

    Protocol.GetLoginReward_Request = (function() {

        /**
         * Properties of a GetLoginReward_Request.
         * @memberof Protocol
         * @interface IGetLoginReward_Request
         * @property {number|null} [index] GetLoginReward_Request index
         */

        /**
         * Constructs a new GetLoginReward_Request.
         * @memberof Protocol
         * @classdesc Represents a GetLoginReward_Request.
         * @implements IGetLoginReward_Request
         * @constructor
         * @param {Protocol.IGetLoginReward_Request=} [properties] Properties to set
         */
        function GetLoginReward_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetLoginReward_Request index.
         * @member {number} index
         * @memberof Protocol.GetLoginReward_Request
         * @instance
         */
        GetLoginReward_Request.prototype.index = 0;

        /**
         * Creates a new GetLoginReward_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.GetLoginReward_Request
         * @static
         * @param {Protocol.IGetLoginReward_Request=} [properties] Properties to set
         * @returns {Protocol.GetLoginReward_Request} GetLoginReward_Request instance
         */
        GetLoginReward_Request.create = function create(properties) {
            return new GetLoginReward_Request(properties);
        };

        /**
         * Encodes the specified GetLoginReward_Request message. Does not implicitly {@link Protocol.GetLoginReward_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetLoginReward_Request
         * @static
         * @param {Protocol.IGetLoginReward_Request} message GetLoginReward_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLoginReward_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified GetLoginReward_Request message, length delimited. Does not implicitly {@link Protocol.GetLoginReward_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetLoginReward_Request
         * @static
         * @param {Protocol.IGetLoginReward_Request} message GetLoginReward_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLoginReward_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetLoginReward_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetLoginReward_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetLoginReward_Request} GetLoginReward_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLoginReward_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetLoginReward_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetLoginReward_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetLoginReward_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetLoginReward_Request} GetLoginReward_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLoginReward_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetLoginReward_Request message.
         * @function verify
         * @memberof Protocol.GetLoginReward_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetLoginReward_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return GetLoginReward_Request;
    })();

    Protocol.GetLoginReward_Respond = (function() {

        /**
         * Properties of a GetLoginReward_Respond.
         * @memberof Protocol
         * @interface IGetLoginReward_Respond
         * @property {number|null} [index] GetLoginReward_Respond index
         * @property {number|null} [ret] GetLoginReward_Respond ret
         */

        /**
         * Constructs a new GetLoginReward_Respond.
         * @memberof Protocol
         * @classdesc Represents a GetLoginReward_Respond.
         * @implements IGetLoginReward_Respond
         * @constructor
         * @param {Protocol.IGetLoginReward_Respond=} [properties] Properties to set
         */
        function GetLoginReward_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetLoginReward_Respond index.
         * @member {number} index
         * @memberof Protocol.GetLoginReward_Respond
         * @instance
         */
        GetLoginReward_Respond.prototype.index = 0;

        /**
         * GetLoginReward_Respond ret.
         * @member {number} ret
         * @memberof Protocol.GetLoginReward_Respond
         * @instance
         */
        GetLoginReward_Respond.prototype.ret = 0;

        /**
         * Creates a new GetLoginReward_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.GetLoginReward_Respond
         * @static
         * @param {Protocol.IGetLoginReward_Respond=} [properties] Properties to set
         * @returns {Protocol.GetLoginReward_Respond} GetLoginReward_Respond instance
         */
        GetLoginReward_Respond.create = function create(properties) {
            return new GetLoginReward_Respond(properties);
        };

        /**
         * Encodes the specified GetLoginReward_Respond message. Does not implicitly {@link Protocol.GetLoginReward_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetLoginReward_Respond
         * @static
         * @param {Protocol.IGetLoginReward_Respond} message GetLoginReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLoginReward_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified GetLoginReward_Respond message, length delimited. Does not implicitly {@link Protocol.GetLoginReward_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetLoginReward_Respond
         * @static
         * @param {Protocol.IGetLoginReward_Respond} message GetLoginReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetLoginReward_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetLoginReward_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetLoginReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetLoginReward_Respond} GetLoginReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLoginReward_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetLoginReward_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetLoginReward_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetLoginReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetLoginReward_Respond} GetLoginReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetLoginReward_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetLoginReward_Respond message.
         * @function verify
         * @memberof Protocol.GetLoginReward_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetLoginReward_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return GetLoginReward_Respond;
    })();

    Protocol.PassDaya_Respond = (function() {

        /**
         * Properties of a PassDaya_Respond.
         * @memberof Protocol
         * @interface IPassDaya_Respond
         */

        /**
         * Constructs a new PassDaya_Respond.
         * @memberof Protocol
         * @classdesc Represents a PassDaya_Respond.
         * @implements IPassDaya_Respond
         * @constructor
         * @param {Protocol.IPassDaya_Respond=} [properties] Properties to set
         */
        function PassDaya_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new PassDaya_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.PassDaya_Respond
         * @static
         * @param {Protocol.IPassDaya_Respond=} [properties] Properties to set
         * @returns {Protocol.PassDaya_Respond} PassDaya_Respond instance
         */
        PassDaya_Respond.create = function create(properties) {
            return new PassDaya_Respond(properties);
        };

        /**
         * Encodes the specified PassDaya_Respond message. Does not implicitly {@link Protocol.PassDaya_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.PassDaya_Respond
         * @static
         * @param {Protocol.IPassDaya_Respond} message PassDaya_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PassDaya_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified PassDaya_Respond message, length delimited. Does not implicitly {@link Protocol.PassDaya_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.PassDaya_Respond
         * @static
         * @param {Protocol.IPassDaya_Respond} message PassDaya_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        PassDaya_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a PassDaya_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.PassDaya_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.PassDaya_Respond} PassDaya_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PassDaya_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.PassDaya_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a PassDaya_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.PassDaya_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.PassDaya_Respond} PassDaya_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        PassDaya_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a PassDaya_Respond message.
         * @function verify
         * @memberof Protocol.PassDaya_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        PassDaya_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return PassDaya_Respond;
    })();

    Protocol.AskLoginRewardGetted_Request = (function() {

        /**
         * Properties of an AskLoginRewardGetted_Request.
         * @memberof Protocol
         * @interface IAskLoginRewardGetted_Request
         */

        /**
         * Constructs a new AskLoginRewardGetted_Request.
         * @memberof Protocol
         * @classdesc Represents an AskLoginRewardGetted_Request.
         * @implements IAskLoginRewardGetted_Request
         * @constructor
         * @param {Protocol.IAskLoginRewardGetted_Request=} [properties] Properties to set
         */
        function AskLoginRewardGetted_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new AskLoginRewardGetted_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.AskLoginRewardGetted_Request
         * @static
         * @param {Protocol.IAskLoginRewardGetted_Request=} [properties] Properties to set
         * @returns {Protocol.AskLoginRewardGetted_Request} AskLoginRewardGetted_Request instance
         */
        AskLoginRewardGetted_Request.create = function create(properties) {
            return new AskLoginRewardGetted_Request(properties);
        };

        /**
         * Encodes the specified AskLoginRewardGetted_Request message. Does not implicitly {@link Protocol.AskLoginRewardGetted_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AskLoginRewardGetted_Request
         * @static
         * @param {Protocol.IAskLoginRewardGetted_Request} message AskLoginRewardGetted_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskLoginRewardGetted_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified AskLoginRewardGetted_Request message, length delimited. Does not implicitly {@link Protocol.AskLoginRewardGetted_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AskLoginRewardGetted_Request
         * @static
         * @param {Protocol.IAskLoginRewardGetted_Request} message AskLoginRewardGetted_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskLoginRewardGetted_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AskLoginRewardGetted_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AskLoginRewardGetted_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AskLoginRewardGetted_Request} AskLoginRewardGetted_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskLoginRewardGetted_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AskLoginRewardGetted_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AskLoginRewardGetted_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AskLoginRewardGetted_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AskLoginRewardGetted_Request} AskLoginRewardGetted_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskLoginRewardGetted_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AskLoginRewardGetted_Request message.
         * @function verify
         * @memberof Protocol.AskLoginRewardGetted_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AskLoginRewardGetted_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return AskLoginRewardGetted_Request;
    })();

    Protocol.AskLoginRewardGetted_Respond = (function() {

        /**
         * Properties of an AskLoginRewardGetted_Respond.
         * @memberof Protocol
         * @interface IAskLoginRewardGetted_Respond
         * @property {Array.<number>|null} [ids] AskLoginRewardGetted_Respond ids
         */

        /**
         * Constructs a new AskLoginRewardGetted_Respond.
         * @memberof Protocol
         * @classdesc Represents an AskLoginRewardGetted_Respond.
         * @implements IAskLoginRewardGetted_Respond
         * @constructor
         * @param {Protocol.IAskLoginRewardGetted_Respond=} [properties] Properties to set
         */
        function AskLoginRewardGetted_Respond(properties) {
            this.ids = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AskLoginRewardGetted_Respond ids.
         * @member {Array.<number>} ids
         * @memberof Protocol.AskLoginRewardGetted_Respond
         * @instance
         */
        AskLoginRewardGetted_Respond.prototype.ids = $util.emptyArray;

        /**
         * Creates a new AskLoginRewardGetted_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.AskLoginRewardGetted_Respond
         * @static
         * @param {Protocol.IAskLoginRewardGetted_Respond=} [properties] Properties to set
         * @returns {Protocol.AskLoginRewardGetted_Respond} AskLoginRewardGetted_Respond instance
         */
        AskLoginRewardGetted_Respond.create = function create(properties) {
            return new AskLoginRewardGetted_Respond(properties);
        };

        /**
         * Encodes the specified AskLoginRewardGetted_Respond message. Does not implicitly {@link Protocol.AskLoginRewardGetted_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.AskLoginRewardGetted_Respond
         * @static
         * @param {Protocol.IAskLoginRewardGetted_Respond} message AskLoginRewardGetted_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskLoginRewardGetted_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ids != null && message.ids.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.ids.length; ++i)
                    writer.int32(message.ids[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified AskLoginRewardGetted_Respond message, length delimited. Does not implicitly {@link Protocol.AskLoginRewardGetted_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.AskLoginRewardGetted_Respond
         * @static
         * @param {Protocol.IAskLoginRewardGetted_Respond} message AskLoginRewardGetted_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AskLoginRewardGetted_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AskLoginRewardGetted_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.AskLoginRewardGetted_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.AskLoginRewardGetted_Respond} AskLoginRewardGetted_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskLoginRewardGetted_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.AskLoginRewardGetted_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.ids && message.ids.length))
                        message.ids = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.ids.push(reader.int32());
                    } else
                        message.ids.push(reader.int32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AskLoginRewardGetted_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.AskLoginRewardGetted_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.AskLoginRewardGetted_Respond} AskLoginRewardGetted_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AskLoginRewardGetted_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AskLoginRewardGetted_Respond message.
         * @function verify
         * @memberof Protocol.AskLoginRewardGetted_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AskLoginRewardGetted_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ids != null && message.hasOwnProperty("ids")) {
                if (!Array.isArray(message.ids))
                    return "ids: array expected";
                for (var i = 0; i < message.ids.length; ++i)
                    if (!$util.isInteger(message.ids[i]))
                        return "ids: integer[] expected";
            }
            return null;
        };

        return AskLoginRewardGetted_Respond;
    })();

    Protocol.GiftInfo_Respond = (function() {

        /**
         * Properties of a GiftInfo_Respond.
         * @memberof Protocol
         * @interface IGiftInfo_Respond
         * @property {Array.<Protocol.IGift>|null} [infos] GiftInfo_Respond infos
         */

        /**
         * Constructs a new GiftInfo_Respond.
         * @memberof Protocol
         * @classdesc Represents a GiftInfo_Respond.
         * @implements IGiftInfo_Respond
         * @constructor
         * @param {Protocol.IGiftInfo_Respond=} [properties] Properties to set
         */
        function GiftInfo_Respond(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GiftInfo_Respond infos.
         * @member {Array.<Protocol.IGift>} infos
         * @memberof Protocol.GiftInfo_Respond
         * @instance
         */
        GiftInfo_Respond.prototype.infos = $util.emptyArray;

        /**
         * Creates a new GiftInfo_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.GiftInfo_Respond
         * @static
         * @param {Protocol.IGiftInfo_Respond=} [properties] Properties to set
         * @returns {Protocol.GiftInfo_Respond} GiftInfo_Respond instance
         */
        GiftInfo_Respond.create = function create(properties) {
            return new GiftInfo_Respond(properties);
        };

        /**
         * Encodes the specified GiftInfo_Respond message. Does not implicitly {@link Protocol.GiftInfo_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GiftInfo_Respond
         * @static
         * @param {Protocol.IGiftInfo_Respond} message GiftInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GiftInfo_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.Protocol.Gift.encode(message.infos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GiftInfo_Respond message, length delimited. Does not implicitly {@link Protocol.GiftInfo_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GiftInfo_Respond
         * @static
         * @param {Protocol.IGiftInfo_Respond} message GiftInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GiftInfo_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GiftInfo_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GiftInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GiftInfo_Respond} GiftInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GiftInfo_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GiftInfo_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.Protocol.Gift.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GiftInfo_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GiftInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GiftInfo_Respond} GiftInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GiftInfo_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GiftInfo_Respond message.
         * @function verify
         * @memberof Protocol.GiftInfo_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GiftInfo_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.Protocol.Gift.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            return null;
        };

        return GiftInfo_Respond;
    })();

    Protocol.BuyGift_Request = (function() {

        /**
         * Properties of a BuyGift_Request.
         * @memberof Protocol
         * @interface IBuyGift_Request
         * @property {number|null} [type] BuyGift_Request type
         * @property {number|null} [giftId] BuyGift_Request giftId
         * @property {number|null} [treasureId] BuyGift_Request treasureId
         */

        /**
         * Constructs a new BuyGift_Request.
         * @memberof Protocol
         * @classdesc Represents a BuyGift_Request.
         * @implements IBuyGift_Request
         * @constructor
         * @param {Protocol.IBuyGift_Request=} [properties] Properties to set
         */
        function BuyGift_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyGift_Request type.
         * @member {number} type
         * @memberof Protocol.BuyGift_Request
         * @instance
         */
        BuyGift_Request.prototype.type = 0;

        /**
         * BuyGift_Request giftId.
         * @member {number} giftId
         * @memberof Protocol.BuyGift_Request
         * @instance
         */
        BuyGift_Request.prototype.giftId = 0;

        /**
         * BuyGift_Request treasureId.
         * @member {number} treasureId
         * @memberof Protocol.BuyGift_Request
         * @instance
         */
        BuyGift_Request.prototype.treasureId = 0;

        /**
         * Creates a new BuyGift_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.BuyGift_Request
         * @static
         * @param {Protocol.IBuyGift_Request=} [properties] Properties to set
         * @returns {Protocol.BuyGift_Request} BuyGift_Request instance
         */
        BuyGift_Request.create = function create(properties) {
            return new BuyGift_Request(properties);
        };

        /**
         * Encodes the specified BuyGift_Request message. Does not implicitly {@link Protocol.BuyGift_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BuyGift_Request
         * @static
         * @param {Protocol.IBuyGift_Request} message BuyGift_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyGift_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.giftId);
            if (message.treasureId != null && message.hasOwnProperty("treasureId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.treasureId);
            return writer;
        };

        /**
         * Encodes the specified BuyGift_Request message, length delimited. Does not implicitly {@link Protocol.BuyGift_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BuyGift_Request
         * @static
         * @param {Protocol.IBuyGift_Request} message BuyGift_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyGift_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyGift_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BuyGift_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BuyGift_Request} BuyGift_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyGift_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BuyGift_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.giftId = reader.int32();
                    break;
                case 3:
                    message.treasureId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyGift_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BuyGift_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BuyGift_Request} BuyGift_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyGift_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyGift_Request message.
         * @function verify
         * @memberof Protocol.BuyGift_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyGift_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                if (!$util.isInteger(message.giftId))
                    return "giftId: integer expected";
            if (message.treasureId != null && message.hasOwnProperty("treasureId"))
                if (!$util.isInteger(message.treasureId))
                    return "treasureId: integer expected";
            return null;
        };

        return BuyGift_Request;
    })();

    Protocol.BuyGift_Respond = (function() {

        /**
         * Properties of a BuyGift_Respond.
         * @memberof Protocol
         * @interface IBuyGift_Respond
         * @property {number|null} [ret] BuyGift_Respond ret
         * @property {number|null} [type] BuyGift_Respond type
         * @property {number|null} [giftId] BuyGift_Respond giftId
         * @property {number|null} [treasureId] BuyGift_Respond treasureId
         */

        /**
         * Constructs a new BuyGift_Respond.
         * @memberof Protocol
         * @classdesc Represents a BuyGift_Respond.
         * @implements IBuyGift_Respond
         * @constructor
         * @param {Protocol.IBuyGift_Respond=} [properties] Properties to set
         */
        function BuyGift_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyGift_Respond ret.
         * @member {number} ret
         * @memberof Protocol.BuyGift_Respond
         * @instance
         */
        BuyGift_Respond.prototype.ret = 0;

        /**
         * BuyGift_Respond type.
         * @member {number} type
         * @memberof Protocol.BuyGift_Respond
         * @instance
         */
        BuyGift_Respond.prototype.type = 0;

        /**
         * BuyGift_Respond giftId.
         * @member {number} giftId
         * @memberof Protocol.BuyGift_Respond
         * @instance
         */
        BuyGift_Respond.prototype.giftId = 0;

        /**
         * BuyGift_Respond treasureId.
         * @member {number} treasureId
         * @memberof Protocol.BuyGift_Respond
         * @instance
         */
        BuyGift_Respond.prototype.treasureId = 0;

        /**
         * Creates a new BuyGift_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.BuyGift_Respond
         * @static
         * @param {Protocol.IBuyGift_Respond=} [properties] Properties to set
         * @returns {Protocol.BuyGift_Respond} BuyGift_Respond instance
         */
        BuyGift_Respond.create = function create(properties) {
            return new BuyGift_Respond(properties);
        };

        /**
         * Encodes the specified BuyGift_Respond message. Does not implicitly {@link Protocol.BuyGift_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BuyGift_Respond
         * @static
         * @param {Protocol.IBuyGift_Respond} message BuyGift_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyGift_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.giftId);
            if (message.treasureId != null && message.hasOwnProperty("treasureId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.treasureId);
            return writer;
        };

        /**
         * Encodes the specified BuyGift_Respond message, length delimited. Does not implicitly {@link Protocol.BuyGift_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BuyGift_Respond
         * @static
         * @param {Protocol.IBuyGift_Respond} message BuyGift_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyGift_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyGift_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BuyGift_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BuyGift_Respond} BuyGift_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyGift_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BuyGift_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.giftId = reader.int32();
                    break;
                case 4:
                    message.treasureId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyGift_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BuyGift_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BuyGift_Respond} BuyGift_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyGift_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyGift_Respond message.
         * @function verify
         * @memberof Protocol.BuyGift_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyGift_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.giftId != null && message.hasOwnProperty("giftId"))
                if (!$util.isInteger(message.giftId))
                    return "giftId: integer expected";
            if (message.treasureId != null && message.hasOwnProperty("treasureId"))
                if (!$util.isInteger(message.treasureId))
                    return "treasureId: integer expected";
            return null;
        };

        return BuyGift_Respond;
    })();

    Protocol.Rewards_Respond = (function() {

        /**
         * Properties of a Rewards_Respond.
         * @memberof Protocol
         * @interface IRewards_Respond
         * @property {Array.<Protocol.IReward>|null} [rewards] Rewards_Respond rewards
         */

        /**
         * Constructs a new Rewards_Respond.
         * @memberof Protocol
         * @classdesc Represents a Rewards_Respond.
         * @implements IRewards_Respond
         * @constructor
         * @param {Protocol.IRewards_Respond=} [properties] Properties to set
         */
        function Rewards_Respond(properties) {
            this.rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Rewards_Respond rewards.
         * @member {Array.<Protocol.IReward>} rewards
         * @memberof Protocol.Rewards_Respond
         * @instance
         */
        Rewards_Respond.prototype.rewards = $util.emptyArray;

        /**
         * Creates a new Rewards_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.Rewards_Respond
         * @static
         * @param {Protocol.IRewards_Respond=} [properties] Properties to set
         * @returns {Protocol.Rewards_Respond} Rewards_Respond instance
         */
        Rewards_Respond.create = function create(properties) {
            return new Rewards_Respond(properties);
        };

        /**
         * Encodes the specified Rewards_Respond message. Does not implicitly {@link Protocol.Rewards_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Rewards_Respond
         * @static
         * @param {Protocol.IRewards_Respond} message Rewards_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rewards_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rewards != null && message.rewards.length)
                for (var i = 0; i < message.rewards.length; ++i)
                    $root.Protocol.Reward.encode(message.rewards[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Rewards_Respond message, length delimited. Does not implicitly {@link Protocol.Rewards_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Rewards_Respond
         * @static
         * @param {Protocol.IRewards_Respond} message Rewards_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Rewards_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Rewards_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Rewards_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Rewards_Respond} Rewards_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rewards_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Rewards_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.rewards && message.rewards.length))
                        message.rewards = [];
                    message.rewards.push($root.Protocol.Reward.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Rewards_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Rewards_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Rewards_Respond} Rewards_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Rewards_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Rewards_Respond message.
         * @function verify
         * @memberof Protocol.Rewards_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Rewards_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                if (!Array.isArray(message.rewards))
                    return "rewards: array expected";
                for (var i = 0; i < message.rewards.length; ++i) {
                    var error = $root.Protocol.Reward.verify(message.rewards[i]);
                    if (error)
                        return "rewards." + error;
                }
            }
            return null;
        };

        return Rewards_Respond;
    })();

    Protocol.Guide_Request = (function() {

        /**
         * Properties of a Guide_Request.
         * @memberof Protocol
         * @interface IGuide_Request
         * @property {string|null} [name] Guide_Request name
         */

        /**
         * Constructs a new Guide_Request.
         * @memberof Protocol
         * @classdesc Represents a Guide_Request.
         * @implements IGuide_Request
         * @constructor
         * @param {Protocol.IGuide_Request=} [properties] Properties to set
         */
        function Guide_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Guide_Request name.
         * @member {string} name
         * @memberof Protocol.Guide_Request
         * @instance
         */
        Guide_Request.prototype.name = "";

        /**
         * Creates a new Guide_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.Guide_Request
         * @static
         * @param {Protocol.IGuide_Request=} [properties] Properties to set
         * @returns {Protocol.Guide_Request} Guide_Request instance
         */
        Guide_Request.create = function create(properties) {
            return new Guide_Request(properties);
        };

        /**
         * Encodes the specified Guide_Request message. Does not implicitly {@link Protocol.Guide_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Guide_Request
         * @static
         * @param {Protocol.IGuide_Request} message Guide_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Guide_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            return writer;
        };

        /**
         * Encodes the specified Guide_Request message, length delimited. Does not implicitly {@link Protocol.Guide_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Guide_Request
         * @static
         * @param {Protocol.IGuide_Request} message Guide_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Guide_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Guide_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Guide_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Guide_Request} Guide_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Guide_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Guide_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.name = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Guide_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Guide_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Guide_Request} Guide_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Guide_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Guide_Request message.
         * @function verify
         * @memberof Protocol.Guide_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Guide_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            return null;
        };

        return Guide_Request;
    })();

    Protocol.Guide_Respond = (function() {

        /**
         * Properties of a Guide_Respond.
         * @memberof Protocol
         * @interface IGuide_Respond
         * @property {Array.<string>|null} [list] Guide_Respond list
         */

        /**
         * Constructs a new Guide_Respond.
         * @memberof Protocol
         * @classdesc Represents a Guide_Respond.
         * @implements IGuide_Respond
         * @constructor
         * @param {Protocol.IGuide_Respond=} [properties] Properties to set
         */
        function Guide_Respond(properties) {
            this.list = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Guide_Respond list.
         * @member {Array.<string>} list
         * @memberof Protocol.Guide_Respond
         * @instance
         */
        Guide_Respond.prototype.list = $util.emptyArray;

        /**
         * Creates a new Guide_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.Guide_Respond
         * @static
         * @param {Protocol.IGuide_Respond=} [properties] Properties to set
         * @returns {Protocol.Guide_Respond} Guide_Respond instance
         */
        Guide_Respond.create = function create(properties) {
            return new Guide_Respond(properties);
        };

        /**
         * Encodes the specified Guide_Respond message. Does not implicitly {@link Protocol.Guide_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Guide_Respond
         * @static
         * @param {Protocol.IGuide_Respond} message Guide_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Guide_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.list != null && message.list.length)
                for (var i = 0; i < message.list.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.list[i]);
            return writer;
        };

        /**
         * Encodes the specified Guide_Respond message, length delimited. Does not implicitly {@link Protocol.Guide_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Guide_Respond
         * @static
         * @param {Protocol.IGuide_Respond} message Guide_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Guide_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Guide_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Guide_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Guide_Respond} Guide_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Guide_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Guide_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.list && message.list.length))
                        message.list = [];
                    message.list.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Guide_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Guide_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Guide_Respond} Guide_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Guide_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Guide_Respond message.
         * @function verify
         * @memberof Protocol.Guide_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Guide_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.list != null && message.hasOwnProperty("list")) {
                if (!Array.isArray(message.list))
                    return "list: array expected";
                for (var i = 0; i < message.list.length; ++i)
                    if (!$util.isString(message.list[i]))
                        return "list: string[] expected";
            }
            return null;
        };

        return Guide_Respond;
    })();

    Protocol.FinishRecharge_Respond = (function() {

        /**
         * Properties of a FinishRecharge_Respond.
         * @memberof Protocol
         * @interface IFinishRecharge_Respond
         * @property {string|null} [uniqueCode] FinishRecharge_Respond uniqueCode
         */

        /**
         * Constructs a new FinishRecharge_Respond.
         * @memberof Protocol
         * @classdesc Represents a FinishRecharge_Respond.
         * @implements IFinishRecharge_Respond
         * @constructor
         * @param {Protocol.IFinishRecharge_Respond=} [properties] Properties to set
         */
        function FinishRecharge_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FinishRecharge_Respond uniqueCode.
         * @member {string} uniqueCode
         * @memberof Protocol.FinishRecharge_Respond
         * @instance
         */
        FinishRecharge_Respond.prototype.uniqueCode = "";

        /**
         * Creates a new FinishRecharge_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.FinishRecharge_Respond
         * @static
         * @param {Protocol.IFinishRecharge_Respond=} [properties] Properties to set
         * @returns {Protocol.FinishRecharge_Respond} FinishRecharge_Respond instance
         */
        FinishRecharge_Respond.create = function create(properties) {
            return new FinishRecharge_Respond(properties);
        };

        /**
         * Encodes the specified FinishRecharge_Respond message. Does not implicitly {@link Protocol.FinishRecharge_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FinishRecharge_Respond
         * @static
         * @param {Protocol.IFinishRecharge_Respond} message FinishRecharge_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinishRecharge_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uniqueCode != null && message.hasOwnProperty("uniqueCode"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.uniqueCode);
            return writer;
        };

        /**
         * Encodes the specified FinishRecharge_Respond message, length delimited. Does not implicitly {@link Protocol.FinishRecharge_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FinishRecharge_Respond
         * @static
         * @param {Protocol.IFinishRecharge_Respond} message FinishRecharge_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FinishRecharge_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FinishRecharge_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FinishRecharge_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FinishRecharge_Respond} FinishRecharge_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinishRecharge_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FinishRecharge_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.uniqueCode = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FinishRecharge_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FinishRecharge_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FinishRecharge_Respond} FinishRecharge_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FinishRecharge_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FinishRecharge_Respond message.
         * @function verify
         * @memberof Protocol.FinishRecharge_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FinishRecharge_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uniqueCode != null && message.hasOwnProperty("uniqueCode"))
                if (!$util.isString(message.uniqueCode))
                    return "uniqueCode: string expected";
            return null;
        };

        return FinishRecharge_Respond;
    })();

    Protocol.GetFirstRechargeReward_Request = (function() {

        /**
         * Properties of a GetFirstRechargeReward_Request.
         * @memberof Protocol
         * @interface IGetFirstRechargeReward_Request
         */

        /**
         * Constructs a new GetFirstRechargeReward_Request.
         * @memberof Protocol
         * @classdesc Represents a GetFirstRechargeReward_Request.
         * @implements IGetFirstRechargeReward_Request
         * @constructor
         * @param {Protocol.IGetFirstRechargeReward_Request=} [properties] Properties to set
         */
        function GetFirstRechargeReward_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetFirstRechargeReward_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.GetFirstRechargeReward_Request
         * @static
         * @param {Protocol.IGetFirstRechargeReward_Request=} [properties] Properties to set
         * @returns {Protocol.GetFirstRechargeReward_Request} GetFirstRechargeReward_Request instance
         */
        GetFirstRechargeReward_Request.create = function create(properties) {
            return new GetFirstRechargeReward_Request(properties);
        };

        /**
         * Encodes the specified GetFirstRechargeReward_Request message. Does not implicitly {@link Protocol.GetFirstRechargeReward_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetFirstRechargeReward_Request
         * @static
         * @param {Protocol.IGetFirstRechargeReward_Request} message GetFirstRechargeReward_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFirstRechargeReward_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetFirstRechargeReward_Request message, length delimited. Does not implicitly {@link Protocol.GetFirstRechargeReward_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetFirstRechargeReward_Request
         * @static
         * @param {Protocol.IGetFirstRechargeReward_Request} message GetFirstRechargeReward_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFirstRechargeReward_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetFirstRechargeReward_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetFirstRechargeReward_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetFirstRechargeReward_Request} GetFirstRechargeReward_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFirstRechargeReward_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetFirstRechargeReward_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetFirstRechargeReward_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetFirstRechargeReward_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetFirstRechargeReward_Request} GetFirstRechargeReward_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFirstRechargeReward_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetFirstRechargeReward_Request message.
         * @function verify
         * @memberof Protocol.GetFirstRechargeReward_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetFirstRechargeReward_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GetFirstRechargeReward_Request;
    })();

    Protocol.TiantiRewardInfo_Request = (function() {

        /**
         * Properties of a TiantiRewardInfo_Request.
         * @memberof Protocol
         * @interface ITiantiRewardInfo_Request
         */

        /**
         * Constructs a new TiantiRewardInfo_Request.
         * @memberof Protocol
         * @classdesc Represents a TiantiRewardInfo_Request.
         * @implements ITiantiRewardInfo_Request
         * @constructor
         * @param {Protocol.ITiantiRewardInfo_Request=} [properties] Properties to set
         */
        function TiantiRewardInfo_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new TiantiRewardInfo_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.TiantiRewardInfo_Request
         * @static
         * @param {Protocol.ITiantiRewardInfo_Request=} [properties] Properties to set
         * @returns {Protocol.TiantiRewardInfo_Request} TiantiRewardInfo_Request instance
         */
        TiantiRewardInfo_Request.create = function create(properties) {
            return new TiantiRewardInfo_Request(properties);
        };

        /**
         * Encodes the specified TiantiRewardInfo_Request message. Does not implicitly {@link Protocol.TiantiRewardInfo_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.TiantiRewardInfo_Request
         * @static
         * @param {Protocol.ITiantiRewardInfo_Request} message TiantiRewardInfo_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TiantiRewardInfo_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified TiantiRewardInfo_Request message, length delimited. Does not implicitly {@link Protocol.TiantiRewardInfo_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.TiantiRewardInfo_Request
         * @static
         * @param {Protocol.ITiantiRewardInfo_Request} message TiantiRewardInfo_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TiantiRewardInfo_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TiantiRewardInfo_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.TiantiRewardInfo_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.TiantiRewardInfo_Request} TiantiRewardInfo_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TiantiRewardInfo_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.TiantiRewardInfo_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TiantiRewardInfo_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.TiantiRewardInfo_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.TiantiRewardInfo_Request} TiantiRewardInfo_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TiantiRewardInfo_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TiantiRewardInfo_Request message.
         * @function verify
         * @memberof Protocol.TiantiRewardInfo_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TiantiRewardInfo_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return TiantiRewardInfo_Request;
    })();

    Protocol.TiantiGetted = (function() {

        /**
         * Properties of a TiantiGetted.
         * @memberof Protocol
         * @interface ITiantiGetted
         * @property {number|null} [classlv] TiantiGetted classlv
         * @property {number|null} [index] TiantiGetted index
         */

        /**
         * Constructs a new TiantiGetted.
         * @memberof Protocol
         * @classdesc Represents a TiantiGetted.
         * @implements ITiantiGetted
         * @constructor
         * @param {Protocol.ITiantiGetted=} [properties] Properties to set
         */
        function TiantiGetted(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TiantiGetted classlv.
         * @member {number} classlv
         * @memberof Protocol.TiantiGetted
         * @instance
         */
        TiantiGetted.prototype.classlv = 0;

        /**
         * TiantiGetted index.
         * @member {number} index
         * @memberof Protocol.TiantiGetted
         * @instance
         */
        TiantiGetted.prototype.index = 0;

        /**
         * Creates a new TiantiGetted instance using the specified properties.
         * @function create
         * @memberof Protocol.TiantiGetted
         * @static
         * @param {Protocol.ITiantiGetted=} [properties] Properties to set
         * @returns {Protocol.TiantiGetted} TiantiGetted instance
         */
        TiantiGetted.create = function create(properties) {
            return new TiantiGetted(properties);
        };

        /**
         * Encodes the specified TiantiGetted message. Does not implicitly {@link Protocol.TiantiGetted.verify|verify} messages.
         * @function encode
         * @memberof Protocol.TiantiGetted
         * @static
         * @param {Protocol.ITiantiGetted} message TiantiGetted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TiantiGetted.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.classlv != null && message.hasOwnProperty("classlv"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.classlv);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified TiantiGetted message, length delimited. Does not implicitly {@link Protocol.TiantiGetted.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.TiantiGetted
         * @static
         * @param {Protocol.ITiantiGetted} message TiantiGetted message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TiantiGetted.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TiantiGetted message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.TiantiGetted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.TiantiGetted} TiantiGetted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TiantiGetted.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.TiantiGetted();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.classlv = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TiantiGetted message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.TiantiGetted
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.TiantiGetted} TiantiGetted
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TiantiGetted.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TiantiGetted message.
         * @function verify
         * @memberof Protocol.TiantiGetted
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TiantiGetted.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.classlv != null && message.hasOwnProperty("classlv"))
                if (!$util.isInteger(message.classlv))
                    return "classlv: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return TiantiGetted;
    })();

    Protocol.TiantiRewardInfo_Respond = (function() {

        /**
         * Properties of a TiantiRewardInfo_Respond.
         * @memberof Protocol
         * @interface ITiantiRewardInfo_Respond
         * @property {Array.<Protocol.ITiantiGetted>|null} [infos] TiantiRewardInfo_Respond infos
         */

        /**
         * Constructs a new TiantiRewardInfo_Respond.
         * @memberof Protocol
         * @classdesc Represents a TiantiRewardInfo_Respond.
         * @implements ITiantiRewardInfo_Respond
         * @constructor
         * @param {Protocol.ITiantiRewardInfo_Respond=} [properties] Properties to set
         */
        function TiantiRewardInfo_Respond(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TiantiRewardInfo_Respond infos.
         * @member {Array.<Protocol.ITiantiGetted>} infos
         * @memberof Protocol.TiantiRewardInfo_Respond
         * @instance
         */
        TiantiRewardInfo_Respond.prototype.infos = $util.emptyArray;

        /**
         * Creates a new TiantiRewardInfo_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.TiantiRewardInfo_Respond
         * @static
         * @param {Protocol.ITiantiRewardInfo_Respond=} [properties] Properties to set
         * @returns {Protocol.TiantiRewardInfo_Respond} TiantiRewardInfo_Respond instance
         */
        TiantiRewardInfo_Respond.create = function create(properties) {
            return new TiantiRewardInfo_Respond(properties);
        };

        /**
         * Encodes the specified TiantiRewardInfo_Respond message. Does not implicitly {@link Protocol.TiantiRewardInfo_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.TiantiRewardInfo_Respond
         * @static
         * @param {Protocol.ITiantiRewardInfo_Respond} message TiantiRewardInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TiantiRewardInfo_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.Protocol.TiantiGetted.encode(message.infos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TiantiRewardInfo_Respond message, length delimited. Does not implicitly {@link Protocol.TiantiRewardInfo_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.TiantiRewardInfo_Respond
         * @static
         * @param {Protocol.ITiantiRewardInfo_Respond} message TiantiRewardInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TiantiRewardInfo_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TiantiRewardInfo_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.TiantiRewardInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.TiantiRewardInfo_Respond} TiantiRewardInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TiantiRewardInfo_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.TiantiRewardInfo_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.Protocol.TiantiGetted.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TiantiRewardInfo_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.TiantiRewardInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.TiantiRewardInfo_Respond} TiantiRewardInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TiantiRewardInfo_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TiantiRewardInfo_Respond message.
         * @function verify
         * @memberof Protocol.TiantiRewardInfo_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TiantiRewardInfo_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.Protocol.TiantiGetted.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            return null;
        };

        return TiantiRewardInfo_Respond;
    })();

    Protocol.GetTiantiReward_Request = (function() {

        /**
         * Properties of a GetTiantiReward_Request.
         * @memberof Protocol
         * @interface IGetTiantiReward_Request
         * @property {number|null} [classlv] GetTiantiReward_Request classlv
         * @property {number|null} [index] GetTiantiReward_Request index
         */

        /**
         * Constructs a new GetTiantiReward_Request.
         * @memberof Protocol
         * @classdesc Represents a GetTiantiReward_Request.
         * @implements IGetTiantiReward_Request
         * @constructor
         * @param {Protocol.IGetTiantiReward_Request=} [properties] Properties to set
         */
        function GetTiantiReward_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTiantiReward_Request classlv.
         * @member {number} classlv
         * @memberof Protocol.GetTiantiReward_Request
         * @instance
         */
        GetTiantiReward_Request.prototype.classlv = 0;

        /**
         * GetTiantiReward_Request index.
         * @member {number} index
         * @memberof Protocol.GetTiantiReward_Request
         * @instance
         */
        GetTiantiReward_Request.prototype.index = 0;

        /**
         * Creates a new GetTiantiReward_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.GetTiantiReward_Request
         * @static
         * @param {Protocol.IGetTiantiReward_Request=} [properties] Properties to set
         * @returns {Protocol.GetTiantiReward_Request} GetTiantiReward_Request instance
         */
        GetTiantiReward_Request.create = function create(properties) {
            return new GetTiantiReward_Request(properties);
        };

        /**
         * Encodes the specified GetTiantiReward_Request message. Does not implicitly {@link Protocol.GetTiantiReward_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetTiantiReward_Request
         * @static
         * @param {Protocol.IGetTiantiReward_Request} message GetTiantiReward_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTiantiReward_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.classlv != null && message.hasOwnProperty("classlv"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.classlv);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified GetTiantiReward_Request message, length delimited. Does not implicitly {@link Protocol.GetTiantiReward_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetTiantiReward_Request
         * @static
         * @param {Protocol.IGetTiantiReward_Request} message GetTiantiReward_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTiantiReward_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTiantiReward_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetTiantiReward_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetTiantiReward_Request} GetTiantiReward_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTiantiReward_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetTiantiReward_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.classlv = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTiantiReward_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetTiantiReward_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetTiantiReward_Request} GetTiantiReward_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTiantiReward_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTiantiReward_Request message.
         * @function verify
         * @memberof Protocol.GetTiantiReward_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTiantiReward_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.classlv != null && message.hasOwnProperty("classlv"))
                if (!$util.isInteger(message.classlv))
                    return "classlv: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return GetTiantiReward_Request;
    })();

    Protocol.GetTiantiReward_Respond = (function() {

        /**
         * Properties of a GetTiantiReward_Respond.
         * @memberof Protocol
         * @interface IGetTiantiReward_Respond
         * @property {number|null} [ret] GetTiantiReward_Respond ret
         * @property {number|null} [classlv] GetTiantiReward_Respond classlv
         * @property {number|null} [index] GetTiantiReward_Respond index
         */

        /**
         * Constructs a new GetTiantiReward_Respond.
         * @memberof Protocol
         * @classdesc Represents a GetTiantiReward_Respond.
         * @implements IGetTiantiReward_Respond
         * @constructor
         * @param {Protocol.IGetTiantiReward_Respond=} [properties] Properties to set
         */
        function GetTiantiReward_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetTiantiReward_Respond ret.
         * @member {number} ret
         * @memberof Protocol.GetTiantiReward_Respond
         * @instance
         */
        GetTiantiReward_Respond.prototype.ret = 0;

        /**
         * GetTiantiReward_Respond classlv.
         * @member {number} classlv
         * @memberof Protocol.GetTiantiReward_Respond
         * @instance
         */
        GetTiantiReward_Respond.prototype.classlv = 0;

        /**
         * GetTiantiReward_Respond index.
         * @member {number} index
         * @memberof Protocol.GetTiantiReward_Respond
         * @instance
         */
        GetTiantiReward_Respond.prototype.index = 0;

        /**
         * Creates a new GetTiantiReward_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.GetTiantiReward_Respond
         * @static
         * @param {Protocol.IGetTiantiReward_Respond=} [properties] Properties to set
         * @returns {Protocol.GetTiantiReward_Respond} GetTiantiReward_Respond instance
         */
        GetTiantiReward_Respond.create = function create(properties) {
            return new GetTiantiReward_Respond(properties);
        };

        /**
         * Encodes the specified GetTiantiReward_Respond message. Does not implicitly {@link Protocol.GetTiantiReward_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetTiantiReward_Respond
         * @static
         * @param {Protocol.IGetTiantiReward_Respond} message GetTiantiReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTiantiReward_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            if (message.classlv != null && message.hasOwnProperty("classlv"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.classlv);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.index);
            return writer;
        };

        /**
         * Encodes the specified GetTiantiReward_Respond message, length delimited. Does not implicitly {@link Protocol.GetTiantiReward_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetTiantiReward_Respond
         * @static
         * @param {Protocol.IGetTiantiReward_Respond} message GetTiantiReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetTiantiReward_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetTiantiReward_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetTiantiReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetTiantiReward_Respond} GetTiantiReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTiantiReward_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetTiantiReward_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                case 2:
                    message.classlv = reader.int32();
                    break;
                case 3:
                    message.index = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetTiantiReward_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetTiantiReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetTiantiReward_Respond} GetTiantiReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetTiantiReward_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetTiantiReward_Respond message.
         * @function verify
         * @memberof Protocol.GetTiantiReward_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetTiantiReward_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.classlv != null && message.hasOwnProperty("classlv"))
                if (!$util.isInteger(message.classlv))
                    return "classlv: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            return null;
        };

        return GetTiantiReward_Respond;
    })();

    Protocol.WarEvent = (function() {

        /**
         * Properties of a WarEvent.
         * @memberof Protocol
         * @interface IWarEvent
         * @property {number|null} [cardId] WarEvent cardId
         * @property {number|null} [count] WarEvent count
         */

        /**
         * Constructs a new WarEvent.
         * @memberof Protocol
         * @classdesc Represents a WarEvent.
         * @implements IWarEvent
         * @constructor
         * @param {Protocol.IWarEvent=} [properties] Properties to set
         */
        function WarEvent(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarEvent cardId.
         * @member {number} cardId
         * @memberof Protocol.WarEvent
         * @instance
         */
        WarEvent.prototype.cardId = 0;

        /**
         * WarEvent count.
         * @member {number} count
         * @memberof Protocol.WarEvent
         * @instance
         */
        WarEvent.prototype.count = 0;

        /**
         * Creates a new WarEvent instance using the specified properties.
         * @function create
         * @memberof Protocol.WarEvent
         * @static
         * @param {Protocol.IWarEvent=} [properties] Properties to set
         * @returns {Protocol.WarEvent} WarEvent instance
         */
        WarEvent.create = function create(properties) {
            return new WarEvent(properties);
        };

        /**
         * Encodes the specified WarEvent message. Does not implicitly {@link Protocol.WarEvent.verify|verify} messages.
         * @function encode
         * @memberof Protocol.WarEvent
         * @static
         * @param {Protocol.IWarEvent} message WarEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarEvent.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cardId != null && message.hasOwnProperty("cardId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.cardId);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified WarEvent message, length delimited. Does not implicitly {@link Protocol.WarEvent.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.WarEvent
         * @static
         * @param {Protocol.IWarEvent} message WarEvent message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarEvent.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarEvent message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.WarEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.WarEvent} WarEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarEvent.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.WarEvent();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.cardId = reader.int32();
                    break;
                case 2:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WarEvent message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.WarEvent
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.WarEvent} WarEvent
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarEvent.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarEvent message.
         * @function verify
         * @memberof Protocol.WarEvent
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarEvent.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cardId != null && message.hasOwnProperty("cardId"))
                if (!$util.isInteger(message.cardId))
                    return "cardId: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        return WarEvent;
    })();

    Protocol.NoticeWarEvent_Request = (function() {

        /**
         * Properties of a NoticeWarEvent_Request.
         * @memberof Protocol
         * @interface INoticeWarEvent_Request
         * @property {Array.<Protocol.IWarEvent>|null} [info] NoticeWarEvent_Request info
         */

        /**
         * Constructs a new NoticeWarEvent_Request.
         * @memberof Protocol
         * @classdesc Represents a NoticeWarEvent_Request.
         * @implements INoticeWarEvent_Request
         * @constructor
         * @param {Protocol.INoticeWarEvent_Request=} [properties] Properties to set
         */
        function NoticeWarEvent_Request(properties) {
            this.info = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * NoticeWarEvent_Request info.
         * @member {Array.<Protocol.IWarEvent>} info
         * @memberof Protocol.NoticeWarEvent_Request
         * @instance
         */
        NoticeWarEvent_Request.prototype.info = $util.emptyArray;

        /**
         * Creates a new NoticeWarEvent_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.NoticeWarEvent_Request
         * @static
         * @param {Protocol.INoticeWarEvent_Request=} [properties] Properties to set
         * @returns {Protocol.NoticeWarEvent_Request} NoticeWarEvent_Request instance
         */
        NoticeWarEvent_Request.create = function create(properties) {
            return new NoticeWarEvent_Request(properties);
        };

        /**
         * Encodes the specified NoticeWarEvent_Request message. Does not implicitly {@link Protocol.NoticeWarEvent_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.NoticeWarEvent_Request
         * @static
         * @param {Protocol.INoticeWarEvent_Request} message NoticeWarEvent_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeWarEvent_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.info != null && message.info.length)
                for (var i = 0; i < message.info.length; ++i)
                    $root.Protocol.WarEvent.encode(message.info[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified NoticeWarEvent_Request message, length delimited. Does not implicitly {@link Protocol.NoticeWarEvent_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.NoticeWarEvent_Request
         * @static
         * @param {Protocol.INoticeWarEvent_Request} message NoticeWarEvent_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        NoticeWarEvent_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a NoticeWarEvent_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.NoticeWarEvent_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.NoticeWarEvent_Request} NoticeWarEvent_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeWarEvent_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.NoticeWarEvent_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.info && message.info.length))
                        message.info = [];
                    message.info.push($root.Protocol.WarEvent.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a NoticeWarEvent_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.NoticeWarEvent_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.NoticeWarEvent_Request} NoticeWarEvent_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        NoticeWarEvent_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a NoticeWarEvent_Request message.
         * @function verify
         * @memberof Protocol.NoticeWarEvent_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        NoticeWarEvent_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                if (!Array.isArray(message.info))
                    return "info: array expected";
                for (var i = 0; i < message.info.length; ++i) {
                    var error = $root.Protocol.WarEvent.verify(message.info[i]);
                    if (error)
                        return "info." + error;
                }
            }
            return null;
        };

        return NoticeWarEvent_Request;
    })();

    Protocol.GetFamilyRank_Request = (function() {

        /**
         * Properties of a GetFamilyRank_Request.
         * @memberof Protocol
         * @interface IGetFamilyRank_Request
         */

        /**
         * Constructs a new GetFamilyRank_Request.
         * @memberof Protocol
         * @classdesc Represents a GetFamilyRank_Request.
         * @implements IGetFamilyRank_Request
         * @constructor
         * @param {Protocol.IGetFamilyRank_Request=} [properties] Properties to set
         */
        function GetFamilyRank_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetFamilyRank_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.GetFamilyRank_Request
         * @static
         * @param {Protocol.IGetFamilyRank_Request=} [properties] Properties to set
         * @returns {Protocol.GetFamilyRank_Request} GetFamilyRank_Request instance
         */
        GetFamilyRank_Request.create = function create(properties) {
            return new GetFamilyRank_Request(properties);
        };

        /**
         * Encodes the specified GetFamilyRank_Request message. Does not implicitly {@link Protocol.GetFamilyRank_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetFamilyRank_Request
         * @static
         * @param {Protocol.IGetFamilyRank_Request} message GetFamilyRank_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFamilyRank_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetFamilyRank_Request message, length delimited. Does not implicitly {@link Protocol.GetFamilyRank_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetFamilyRank_Request
         * @static
         * @param {Protocol.IGetFamilyRank_Request} message GetFamilyRank_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFamilyRank_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetFamilyRank_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetFamilyRank_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetFamilyRank_Request} GetFamilyRank_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFamilyRank_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetFamilyRank_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetFamilyRank_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetFamilyRank_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetFamilyRank_Request} GetFamilyRank_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFamilyRank_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetFamilyRank_Request message.
         * @function verify
         * @memberof Protocol.GetFamilyRank_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetFamilyRank_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GetFamilyRank_Request;
    })();

    Protocol.GetFamilyRank_Respond = (function() {

        /**
         * Properties of a GetFamilyRank_Respond.
         * @memberof Protocol
         * @interface IGetFamilyRank_Respond
         * @property {Array.<Protocol.IFamilyInfo>|null} [infos] GetFamilyRank_Respond infos
         */

        /**
         * Constructs a new GetFamilyRank_Respond.
         * @memberof Protocol
         * @classdesc Represents a GetFamilyRank_Respond.
         * @implements IGetFamilyRank_Respond
         * @constructor
         * @param {Protocol.IGetFamilyRank_Respond=} [properties] Properties to set
         */
        function GetFamilyRank_Respond(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetFamilyRank_Respond infos.
         * @member {Array.<Protocol.IFamilyInfo>} infos
         * @memberof Protocol.GetFamilyRank_Respond
         * @instance
         */
        GetFamilyRank_Respond.prototype.infos = $util.emptyArray;

        /**
         * Creates a new GetFamilyRank_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.GetFamilyRank_Respond
         * @static
         * @param {Protocol.IGetFamilyRank_Respond=} [properties] Properties to set
         * @returns {Protocol.GetFamilyRank_Respond} GetFamilyRank_Respond instance
         */
        GetFamilyRank_Respond.create = function create(properties) {
            return new GetFamilyRank_Respond(properties);
        };

        /**
         * Encodes the specified GetFamilyRank_Respond message. Does not implicitly {@link Protocol.GetFamilyRank_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetFamilyRank_Respond
         * @static
         * @param {Protocol.IGetFamilyRank_Respond} message GetFamilyRank_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFamilyRank_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.Protocol.FamilyInfo.encode(message.infos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified GetFamilyRank_Respond message, length delimited. Does not implicitly {@link Protocol.GetFamilyRank_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetFamilyRank_Respond
         * @static
         * @param {Protocol.IGetFamilyRank_Respond} message GetFamilyRank_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetFamilyRank_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetFamilyRank_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetFamilyRank_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetFamilyRank_Respond} GetFamilyRank_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFamilyRank_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetFamilyRank_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.Protocol.FamilyInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetFamilyRank_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetFamilyRank_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetFamilyRank_Respond} GetFamilyRank_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetFamilyRank_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetFamilyRank_Respond message.
         * @function verify
         * @memberof Protocol.GetFamilyRank_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetFamilyRank_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.Protocol.FamilyInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            return null;
        };

        return GetFamilyRank_Respond;
    })();

    Protocol.KickOut_Respond = (function() {

        /**
         * Properties of a KickOut_Respond.
         * @memberof Protocol
         * @interface IKickOut_Respond
         * @property {number|null} [type] KickOut_Respond type
         */

        /**
         * Constructs a new KickOut_Respond.
         * @memberof Protocol
         * @classdesc Represents a KickOut_Respond.
         * @implements IKickOut_Respond
         * @constructor
         * @param {Protocol.IKickOut_Respond=} [properties] Properties to set
         */
        function KickOut_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * KickOut_Respond type.
         * @member {number} type
         * @memberof Protocol.KickOut_Respond
         * @instance
         */
        KickOut_Respond.prototype.type = 0;

        /**
         * Creates a new KickOut_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.KickOut_Respond
         * @static
         * @param {Protocol.IKickOut_Respond=} [properties] Properties to set
         * @returns {Protocol.KickOut_Respond} KickOut_Respond instance
         */
        KickOut_Respond.create = function create(properties) {
            return new KickOut_Respond(properties);
        };

        /**
         * Encodes the specified KickOut_Respond message. Does not implicitly {@link Protocol.KickOut_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.KickOut_Respond
         * @static
         * @param {Protocol.IKickOut_Respond} message KickOut_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KickOut_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified KickOut_Respond message, length delimited. Does not implicitly {@link Protocol.KickOut_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.KickOut_Respond
         * @static
         * @param {Protocol.IKickOut_Respond} message KickOut_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        KickOut_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a KickOut_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.KickOut_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.KickOut_Respond} KickOut_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KickOut_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.KickOut_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a KickOut_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.KickOut_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.KickOut_Respond} KickOut_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        KickOut_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a KickOut_Respond message.
         * @function verify
         * @memberof Protocol.KickOut_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        KickOut_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        return KickOut_Respond;
    })();

    Protocol.ChangeRolePic_Request = (function() {

        /**
         * Properties of a ChangeRolePic_Request.
         * @memberof Protocol
         * @interface IChangeRolePic_Request
         * @property {number|null} [rolePic] ChangeRolePic_Request rolePic
         */

        /**
         * Constructs a new ChangeRolePic_Request.
         * @memberof Protocol
         * @classdesc Represents a ChangeRolePic_Request.
         * @implements IChangeRolePic_Request
         * @constructor
         * @param {Protocol.IChangeRolePic_Request=} [properties] Properties to set
         */
        function ChangeRolePic_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeRolePic_Request rolePic.
         * @member {number} rolePic
         * @memberof Protocol.ChangeRolePic_Request
         * @instance
         */
        ChangeRolePic_Request.prototype.rolePic = 0;

        /**
         * Creates a new ChangeRolePic_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.ChangeRolePic_Request
         * @static
         * @param {Protocol.IChangeRolePic_Request=} [properties] Properties to set
         * @returns {Protocol.ChangeRolePic_Request} ChangeRolePic_Request instance
         */
        ChangeRolePic_Request.create = function create(properties) {
            return new ChangeRolePic_Request(properties);
        };

        /**
         * Encodes the specified ChangeRolePic_Request message. Does not implicitly {@link Protocol.ChangeRolePic_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.ChangeRolePic_Request
         * @static
         * @param {Protocol.IChangeRolePic_Request} message ChangeRolePic_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeRolePic_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.rolePic);
            return writer;
        };

        /**
         * Encodes the specified ChangeRolePic_Request message, length delimited. Does not implicitly {@link Protocol.ChangeRolePic_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.ChangeRolePic_Request
         * @static
         * @param {Protocol.IChangeRolePic_Request} message ChangeRolePic_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeRolePic_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeRolePic_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.ChangeRolePic_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.ChangeRolePic_Request} ChangeRolePic_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeRolePic_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.ChangeRolePic_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.rolePic = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeRolePic_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.ChangeRolePic_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.ChangeRolePic_Request} ChangeRolePic_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeRolePic_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeRolePic_Request message.
         * @function verify
         * @memberof Protocol.ChangeRolePic_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeRolePic_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                if (!$util.isInteger(message.rolePic))
                    return "rolePic: integer expected";
            return null;
        };

        return ChangeRolePic_Request;
    })();

    Protocol.ChangeRolePic_Respond = (function() {

        /**
         * Properties of a ChangeRolePic_Respond.
         * @memberof Protocol
         * @interface IChangeRolePic_Respond
         * @property {number|null} [ret] ChangeRolePic_Respond ret
         * @property {number|null} [rolePic] ChangeRolePic_Respond rolePic
         */

        /**
         * Constructs a new ChangeRolePic_Respond.
         * @memberof Protocol
         * @classdesc Represents a ChangeRolePic_Respond.
         * @implements IChangeRolePic_Respond
         * @constructor
         * @param {Protocol.IChangeRolePic_Respond=} [properties] Properties to set
         */
        function ChangeRolePic_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChangeRolePic_Respond ret.
         * @member {number} ret
         * @memberof Protocol.ChangeRolePic_Respond
         * @instance
         */
        ChangeRolePic_Respond.prototype.ret = 0;

        /**
         * ChangeRolePic_Respond rolePic.
         * @member {number} rolePic
         * @memberof Protocol.ChangeRolePic_Respond
         * @instance
         */
        ChangeRolePic_Respond.prototype.rolePic = 0;

        /**
         * Creates a new ChangeRolePic_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.ChangeRolePic_Respond
         * @static
         * @param {Protocol.IChangeRolePic_Respond=} [properties] Properties to set
         * @returns {Protocol.ChangeRolePic_Respond} ChangeRolePic_Respond instance
         */
        ChangeRolePic_Respond.create = function create(properties) {
            return new ChangeRolePic_Respond(properties);
        };

        /**
         * Encodes the specified ChangeRolePic_Respond message. Does not implicitly {@link Protocol.ChangeRolePic_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.ChangeRolePic_Respond
         * @static
         * @param {Protocol.IChangeRolePic_Respond} message ChangeRolePic_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeRolePic_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.rolePic);
            return writer;
        };

        /**
         * Encodes the specified ChangeRolePic_Respond message, length delimited. Does not implicitly {@link Protocol.ChangeRolePic_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.ChangeRolePic_Respond
         * @static
         * @param {Protocol.IChangeRolePic_Respond} message ChangeRolePic_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChangeRolePic_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChangeRolePic_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.ChangeRolePic_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.ChangeRolePic_Respond} ChangeRolePic_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeRolePic_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.ChangeRolePic_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                case 2:
                    message.rolePic = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChangeRolePic_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.ChangeRolePic_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.ChangeRolePic_Respond} ChangeRolePic_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChangeRolePic_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChangeRolePic_Respond message.
         * @function verify
         * @memberof Protocol.ChangeRolePic_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChangeRolePic_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                if (!$util.isInteger(message.rolePic))
                    return "rolePic: integer expected";
            return null;
        };

        return ChangeRolePic_Respond;
    })();

    Protocol.GetCodeReward_Request = (function() {

        /**
         * Properties of a GetCodeReward_Request.
         * @memberof Protocol
         * @interface IGetCodeReward_Request
         * @property {string|null} [code] GetCodeReward_Request code
         */

        /**
         * Constructs a new GetCodeReward_Request.
         * @memberof Protocol
         * @classdesc Represents a GetCodeReward_Request.
         * @implements IGetCodeReward_Request
         * @constructor
         * @param {Protocol.IGetCodeReward_Request=} [properties] Properties to set
         */
        function GetCodeReward_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCodeReward_Request code.
         * @member {string} code
         * @memberof Protocol.GetCodeReward_Request
         * @instance
         */
        GetCodeReward_Request.prototype.code = "";

        /**
         * Creates a new GetCodeReward_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.GetCodeReward_Request
         * @static
         * @param {Protocol.IGetCodeReward_Request=} [properties] Properties to set
         * @returns {Protocol.GetCodeReward_Request} GetCodeReward_Request instance
         */
        GetCodeReward_Request.create = function create(properties) {
            return new GetCodeReward_Request(properties);
        };

        /**
         * Encodes the specified GetCodeReward_Request message. Does not implicitly {@link Protocol.GetCodeReward_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetCodeReward_Request
         * @static
         * @param {Protocol.IGetCodeReward_Request} message GetCodeReward_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCodeReward_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.code != null && message.hasOwnProperty("code"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
            return writer;
        };

        /**
         * Encodes the specified GetCodeReward_Request message, length delimited. Does not implicitly {@link Protocol.GetCodeReward_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetCodeReward_Request
         * @static
         * @param {Protocol.IGetCodeReward_Request} message GetCodeReward_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCodeReward_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCodeReward_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetCodeReward_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetCodeReward_Request} GetCodeReward_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCodeReward_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetCodeReward_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.code = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCodeReward_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetCodeReward_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetCodeReward_Request} GetCodeReward_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCodeReward_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCodeReward_Request message.
         * @function verify
         * @memberof Protocol.GetCodeReward_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCodeReward_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.code != null && message.hasOwnProperty("code"))
                if (!$util.isString(message.code))
                    return "code: string expected";
            return null;
        };

        return GetCodeReward_Request;
    })();

    Protocol.GetCodeReward_Respond = (function() {

        /**
         * Properties of a GetCodeReward_Respond.
         * @memberof Protocol
         * @interface IGetCodeReward_Respond
         * @property {number|null} [ret] GetCodeReward_Respond ret
         */

        /**
         * Constructs a new GetCodeReward_Respond.
         * @memberof Protocol
         * @classdesc Represents a GetCodeReward_Respond.
         * @implements IGetCodeReward_Respond
         * @constructor
         * @param {Protocol.IGetCodeReward_Respond=} [properties] Properties to set
         */
        function GetCodeReward_Respond(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetCodeReward_Respond ret.
         * @member {number} ret
         * @memberof Protocol.GetCodeReward_Respond
         * @instance
         */
        GetCodeReward_Respond.prototype.ret = 0;

        /**
         * Creates a new GetCodeReward_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.GetCodeReward_Respond
         * @static
         * @param {Protocol.IGetCodeReward_Respond=} [properties] Properties to set
         * @returns {Protocol.GetCodeReward_Respond} GetCodeReward_Respond instance
         */
        GetCodeReward_Respond.create = function create(properties) {
            return new GetCodeReward_Respond(properties);
        };

        /**
         * Encodes the specified GetCodeReward_Respond message. Does not implicitly {@link Protocol.GetCodeReward_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetCodeReward_Respond
         * @static
         * @param {Protocol.IGetCodeReward_Respond} message GetCodeReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCodeReward_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.ret != null && message.hasOwnProperty("ret"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ret);
            return writer;
        };

        /**
         * Encodes the specified GetCodeReward_Respond message, length delimited. Does not implicitly {@link Protocol.GetCodeReward_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetCodeReward_Respond
         * @static
         * @param {Protocol.IGetCodeReward_Respond} message GetCodeReward_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetCodeReward_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetCodeReward_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetCodeReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetCodeReward_Respond} GetCodeReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCodeReward_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetCodeReward_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.ret = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetCodeReward_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetCodeReward_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetCodeReward_Respond} GetCodeReward_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetCodeReward_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetCodeReward_Respond message.
         * @function verify
         * @memberof Protocol.GetCodeReward_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetCodeReward_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.ret != null && message.hasOwnProperty("ret"))
                if (!$util.isInteger(message.ret))
                    return "ret: integer expected";
            return null;
        };

        return GetCodeReward_Respond;
    })();

    Protocol.GetServerNotice_Request = (function() {

        /**
         * Properties of a GetServerNotice_Request.
         * @memberof Protocol
         * @interface IGetServerNotice_Request
         */

        /**
         * Constructs a new GetServerNotice_Request.
         * @memberof Protocol
         * @classdesc Represents a GetServerNotice_Request.
         * @implements IGetServerNotice_Request
         * @constructor
         * @param {Protocol.IGetServerNotice_Request=} [properties] Properties to set
         */
        function GetServerNotice_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Creates a new GetServerNotice_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.GetServerNotice_Request
         * @static
         * @param {Protocol.IGetServerNotice_Request=} [properties] Properties to set
         * @returns {Protocol.GetServerNotice_Request} GetServerNotice_Request instance
         */
        GetServerNotice_Request.create = function create(properties) {
            return new GetServerNotice_Request(properties);
        };

        /**
         * Encodes the specified GetServerNotice_Request message. Does not implicitly {@link Protocol.GetServerNotice_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetServerNotice_Request
         * @static
         * @param {Protocol.IGetServerNotice_Request} message GetServerNotice_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerNotice_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            return writer;
        };

        /**
         * Encodes the specified GetServerNotice_Request message, length delimited. Does not implicitly {@link Protocol.GetServerNotice_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetServerNotice_Request
         * @static
         * @param {Protocol.IGetServerNotice_Request} message GetServerNotice_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerNotice_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetServerNotice_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetServerNotice_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetServerNotice_Request} GetServerNotice_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerNotice_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetServerNotice_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetServerNotice_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetServerNotice_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetServerNotice_Request} GetServerNotice_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerNotice_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetServerNotice_Request message.
         * @function verify
         * @memberof Protocol.GetServerNotice_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetServerNotice_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            return null;
        };

        return GetServerNotice_Request;
    })();

    Protocol.GetServerNotice_Respond = (function() {

        /**
         * Properties of a GetServerNotice_Respond.
         * @memberof Protocol
         * @interface IGetServerNotice_Respond
         * @property {Array.<string>|null} [notices] GetServerNotice_Respond notices
         */

        /**
         * Constructs a new GetServerNotice_Respond.
         * @memberof Protocol
         * @classdesc Represents a GetServerNotice_Respond.
         * @implements IGetServerNotice_Respond
         * @constructor
         * @param {Protocol.IGetServerNotice_Respond=} [properties] Properties to set
         */
        function GetServerNotice_Respond(properties) {
            this.notices = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * GetServerNotice_Respond notices.
         * @member {Array.<string>} notices
         * @memberof Protocol.GetServerNotice_Respond
         * @instance
         */
        GetServerNotice_Respond.prototype.notices = $util.emptyArray;

        /**
         * Creates a new GetServerNotice_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.GetServerNotice_Respond
         * @static
         * @param {Protocol.IGetServerNotice_Respond=} [properties] Properties to set
         * @returns {Protocol.GetServerNotice_Respond} GetServerNotice_Respond instance
         */
        GetServerNotice_Respond.create = function create(properties) {
            return new GetServerNotice_Respond(properties);
        };

        /**
         * Encodes the specified GetServerNotice_Respond message. Does not implicitly {@link Protocol.GetServerNotice_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.GetServerNotice_Respond
         * @static
         * @param {Protocol.IGetServerNotice_Respond} message GetServerNotice_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerNotice_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.notices != null && message.notices.length)
                for (var i = 0; i < message.notices.length; ++i)
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.notices[i]);
            return writer;
        };

        /**
         * Encodes the specified GetServerNotice_Respond message, length delimited. Does not implicitly {@link Protocol.GetServerNotice_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.GetServerNotice_Respond
         * @static
         * @param {Protocol.IGetServerNotice_Respond} message GetServerNotice_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        GetServerNotice_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a GetServerNotice_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.GetServerNotice_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.GetServerNotice_Respond} GetServerNotice_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerNotice_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.GetServerNotice_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.notices && message.notices.length))
                        message.notices = [];
                    message.notices.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a GetServerNotice_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.GetServerNotice_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.GetServerNotice_Respond} GetServerNotice_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        GetServerNotice_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a GetServerNotice_Respond message.
         * @function verify
         * @memberof Protocol.GetServerNotice_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        GetServerNotice_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.notices != null && message.hasOwnProperty("notices")) {
                if (!Array.isArray(message.notices))
                    return "notices: array expected";
                for (var i = 0; i < message.notices.length; ++i)
                    if (!$util.isString(message.notices[i]))
                        return "notices: string[] expected";
            }
            return null;
        };

        return GetServerNotice_Respond;
    })();

    Protocol.MatchInfo = (function() {

        /**
         * Properties of a MatchInfo.
         * @memberof Protocol
         * @interface IMatchInfo
         * @property {number|Long|null} [roleId] MatchInfo roleId
         * @property {string|null} [name] MatchInfo name
         * @property {number|null} [level] MatchInfo level
         * @property {number|null} [serverId] MatchInfo serverId
         * @property {number|null} [pos] MatchInfo pos
         * @property {Array.<Protocol.IHero>|null} [heros] MatchInfo heros
         * @property {number|null} [type] MatchInfo type
         * @property {boolean|null} [isRobot] MatchInfo isRobot
         * @property {Array.<number>|null} [lineUp] MatchInfo lineUp
         * @property {string|null} [familyName] MatchInfo familyName
         * @property {string|null} [iconName] MatchInfo iconName
         * @property {number|null} [edgeId] MatchInfo edgeId
         * @property {number|null} [cups] MatchInfo cups
         * @property {number|null} [classLevel] MatchInfo classLevel
         * @property {number|null} [rolePic] MatchInfo rolePic
         */

        /**
         * Constructs a new MatchInfo.
         * @memberof Protocol
         * @classdesc Represents a MatchInfo.
         * @implements IMatchInfo
         * @constructor
         * @param {Protocol.IMatchInfo=} [properties] Properties to set
         */
        function MatchInfo(properties) {
            this.heros = [];
            this.lineUp = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MatchInfo roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * MatchInfo name.
         * @member {string} name
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.name = "";

        /**
         * MatchInfo level.
         * @member {number} level
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.level = 0;

        /**
         * MatchInfo serverId.
         * @member {number} serverId
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.serverId = 0;

        /**
         * MatchInfo pos.
         * @member {number} pos
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.pos = 0;

        /**
         * MatchInfo heros.
         * @member {Array.<Protocol.IHero>} heros
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.heros = $util.emptyArray;

        /**
         * MatchInfo type.
         * @member {number} type
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.type = 0;

        /**
         * MatchInfo isRobot.
         * @member {boolean} isRobot
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.isRobot = false;

        /**
         * MatchInfo lineUp.
         * @member {Array.<number>} lineUp
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.lineUp = $util.emptyArray;

        /**
         * MatchInfo familyName.
         * @member {string} familyName
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.familyName = "";

        /**
         * MatchInfo iconName.
         * @member {string} iconName
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.iconName = "";

        /**
         * MatchInfo edgeId.
         * @member {number} edgeId
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.edgeId = 0;

        /**
         * MatchInfo cups.
         * @member {number} cups
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.cups = 0;

        /**
         * MatchInfo classLevel.
         * @member {number} classLevel
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.classLevel = 0;

        /**
         * MatchInfo rolePic.
         * @member {number} rolePic
         * @memberof Protocol.MatchInfo
         * @instance
         */
        MatchInfo.prototype.rolePic = 0;

        /**
         * Creates a new MatchInfo instance using the specified properties.
         * @function create
         * @memberof Protocol.MatchInfo
         * @static
         * @param {Protocol.IMatchInfo=} [properties] Properties to set
         * @returns {Protocol.MatchInfo} MatchInfo instance
         */
        MatchInfo.create = function create(properties) {
            return new MatchInfo(properties);
        };

        /**
         * Encodes the specified MatchInfo message. Does not implicitly {@link Protocol.MatchInfo.verify|verify} messages.
         * @function encode
         * @memberof Protocol.MatchInfo
         * @static
         * @param {Protocol.IMatchInfo} message MatchInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.serverId);
            if (message.pos != null && message.hasOwnProperty("pos"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.pos);
            if (message.heros != null && message.heros.length)
                for (var i = 0; i < message.heros.length; ++i)
                    $root.Protocol.Hero.encode(message.heros[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.type);
            if (message.isRobot != null && message.hasOwnProperty("isRobot"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.isRobot);
            if (message.lineUp != null && message.lineUp.length) {
                writer.uint32(/* id 9, wireType 2 =*/74).fork();
                for (var i = 0; i < message.lineUp.length; ++i)
                    writer.int32(message.lineUp[i]);
                writer.ldelim();
            }
            if (message.familyName != null && message.hasOwnProperty("familyName"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.familyName);
            if (message.iconName != null && message.hasOwnProperty("iconName"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.iconName);
            if (message.edgeId != null && message.hasOwnProperty("edgeId"))
                writer.uint32(/* id 12, wireType 0 =*/96).int32(message.edgeId);
            if (message.cups != null && message.hasOwnProperty("cups"))
                writer.uint32(/* id 13, wireType 0 =*/104).int32(message.cups);
            if (message.classLevel != null && message.hasOwnProperty("classLevel"))
                writer.uint32(/* id 14, wireType 0 =*/112).int32(message.classLevel);
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                writer.uint32(/* id 15, wireType 0 =*/120).int32(message.rolePic);
            return writer;
        };

        /**
         * Encodes the specified MatchInfo message, length delimited. Does not implicitly {@link Protocol.MatchInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.MatchInfo
         * @static
         * @param {Protocol.IMatchInfo} message MatchInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MatchInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MatchInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.MatchInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.MatchInfo} MatchInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.MatchInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.level = reader.int32();
                    break;
                case 4:
                    message.serverId = reader.int32();
                    break;
                case 5:
                    message.pos = reader.int32();
                    break;
                case 6:
                    if (!(message.heros && message.heros.length))
                        message.heros = [];
                    message.heros.push($root.Protocol.Hero.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.type = reader.int32();
                    break;
                case 8:
                    message.isRobot = reader.bool();
                    break;
                case 9:
                    if (!(message.lineUp && message.lineUp.length))
                        message.lineUp = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.lineUp.push(reader.int32());
                    } else
                        message.lineUp.push(reader.int32());
                    break;
                case 10:
                    message.familyName = reader.string();
                    break;
                case 11:
                    message.iconName = reader.string();
                    break;
                case 12:
                    message.edgeId = reader.int32();
                    break;
                case 13:
                    message.cups = reader.int32();
                    break;
                case 14:
                    message.classLevel = reader.int32();
                    break;
                case 15:
                    message.rolePic = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MatchInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.MatchInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.MatchInfo} MatchInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MatchInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MatchInfo message.
         * @function verify
         * @memberof Protocol.MatchInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MatchInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            if (message.pos != null && message.hasOwnProperty("pos"))
                if (!$util.isInteger(message.pos))
                    return "pos: integer expected";
            if (message.heros != null && message.hasOwnProperty("heros")) {
                if (!Array.isArray(message.heros))
                    return "heros: array expected";
                for (var i = 0; i < message.heros.length; ++i) {
                    var error = $root.Protocol.Hero.verify(message.heros[i]);
                    if (error)
                        return "heros." + error;
                }
            }
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.isRobot != null && message.hasOwnProperty("isRobot"))
                if (typeof message.isRobot !== "boolean")
                    return "isRobot: boolean expected";
            if (message.lineUp != null && message.hasOwnProperty("lineUp")) {
                if (!Array.isArray(message.lineUp))
                    return "lineUp: array expected";
                for (var i = 0; i < message.lineUp.length; ++i)
                    if (!$util.isInteger(message.lineUp[i]))
                        return "lineUp: integer[] expected";
            }
            if (message.familyName != null && message.hasOwnProperty("familyName"))
                if (!$util.isString(message.familyName))
                    return "familyName: string expected";
            if (message.iconName != null && message.hasOwnProperty("iconName"))
                if (!$util.isString(message.iconName))
                    return "iconName: string expected";
            if (message.edgeId != null && message.hasOwnProperty("edgeId"))
                if (!$util.isInteger(message.edgeId))
                    return "edgeId: integer expected";
            if (message.cups != null && message.hasOwnProperty("cups"))
                if (!$util.isInteger(message.cups))
                    return "cups: integer expected";
            if (message.classLevel != null && message.hasOwnProperty("classLevel"))
                if (!$util.isInteger(message.classLevel))
                    return "classLevel: integer expected";
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                if (!$util.isInteger(message.rolePic))
                    return "rolePic: integer expected";
            return null;
        };

        return MatchInfo;
    })();

    Protocol.Hero = (function() {

        /**
         * Properties of a Hero.
         * @memberof Protocol
         * @interface IHero
         * @property {number|null} [index] Hero index
         * @property {number|null} [level] Hero level
         * @property {number|null} [goldLevel] Hero goldLevel
         * @property {number|null} [count] Hero count
         */

        /**
         * Constructs a new Hero.
         * @memberof Protocol
         * @classdesc Represents a Hero.
         * @implements IHero
         * @constructor
         * @param {Protocol.IHero=} [properties] Properties to set
         */
        function Hero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Hero index.
         * @member {number} index
         * @memberof Protocol.Hero
         * @instance
         */
        Hero.prototype.index = 0;

        /**
         * Hero level.
         * @member {number} level
         * @memberof Protocol.Hero
         * @instance
         */
        Hero.prototype.level = 0;

        /**
         * Hero goldLevel.
         * @member {number} goldLevel
         * @memberof Protocol.Hero
         * @instance
         */
        Hero.prototype.goldLevel = 0;

        /**
         * Hero count.
         * @member {number} count
         * @memberof Protocol.Hero
         * @instance
         */
        Hero.prototype.count = 0;

        /**
         * Creates a new Hero instance using the specified properties.
         * @function create
         * @memberof Protocol.Hero
         * @static
         * @param {Protocol.IHero=} [properties] Properties to set
         * @returns {Protocol.Hero} Hero instance
         */
        Hero.create = function create(properties) {
            return new Hero(properties);
        };

        /**
         * Encodes the specified Hero message. Does not implicitly {@link Protocol.Hero.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Hero
         * @static
         * @param {Protocol.IHero} message Hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);
            if (message.goldLevel != null && message.hasOwnProperty("goldLevel"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.goldLevel);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified Hero message, length delimited. Does not implicitly {@link Protocol.Hero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Hero
         * @static
         * @param {Protocol.IHero} message Hero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Hero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Hero message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Hero} Hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Hero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2:
                    message.index = reader.int32();
                    break;
                case 3:
                    message.level = reader.int32();
                    break;
                case 4:
                    message.goldLevel = reader.int32();
                    break;
                case 6:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Hero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Hero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Hero} Hero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Hero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Hero message.
         * @function verify
         * @memberof Protocol.Hero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Hero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.goldLevel != null && message.hasOwnProperty("goldLevel"))
                if (!$util.isInteger(message.goldLevel))
                    return "goldLevel: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        return Hero;
    })();

    Protocol.FightRoomInfo_Respond = (function() {

        /**
         * Properties of a FightRoomInfo_Respond.
         * @memberof Protocol
         * @interface IFightRoomInfo_Respond
         * @property {Array.<Protocol.IMatchInfo>|null} [infos] FightRoomInfo_Respond infos
         * @property {string|null} [fightIp] FightRoomInfo_Respond fightIp
         * @property {string|null} [secrete] FightRoomInfo_Respond secrete
         * @property {string|null} [roomId] FightRoomInfo_Respond roomId
         * @property {number|null} [type] FightRoomInfo_Respond type
         * @property {number|null} [mapID] FightRoomInfo_Respond mapID
         * @property {number|null} [classLevel] FightRoomInfo_Respond classLevel
         */

        /**
         * Constructs a new FightRoomInfo_Respond.
         * @memberof Protocol
         * @classdesc Represents a FightRoomInfo_Respond.
         * @implements IFightRoomInfo_Respond
         * @constructor
         * @param {Protocol.IFightRoomInfo_Respond=} [properties] Properties to set
         */
        function FightRoomInfo_Respond(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightRoomInfo_Respond infos.
         * @member {Array.<Protocol.IMatchInfo>} infos
         * @memberof Protocol.FightRoomInfo_Respond
         * @instance
         */
        FightRoomInfo_Respond.prototype.infos = $util.emptyArray;

        /**
         * FightRoomInfo_Respond fightIp.
         * @member {string} fightIp
         * @memberof Protocol.FightRoomInfo_Respond
         * @instance
         */
        FightRoomInfo_Respond.prototype.fightIp = "";

        /**
         * FightRoomInfo_Respond secrete.
         * @member {string} secrete
         * @memberof Protocol.FightRoomInfo_Respond
         * @instance
         */
        FightRoomInfo_Respond.prototype.secrete = "";

        /**
         * FightRoomInfo_Respond roomId.
         * @member {string} roomId
         * @memberof Protocol.FightRoomInfo_Respond
         * @instance
         */
        FightRoomInfo_Respond.prototype.roomId = "";

        /**
         * FightRoomInfo_Respond type.
         * @member {number} type
         * @memberof Protocol.FightRoomInfo_Respond
         * @instance
         */
        FightRoomInfo_Respond.prototype.type = 0;

        /**
         * FightRoomInfo_Respond mapID.
         * @member {number} mapID
         * @memberof Protocol.FightRoomInfo_Respond
         * @instance
         */
        FightRoomInfo_Respond.prototype.mapID = 0;

        /**
         * FightRoomInfo_Respond classLevel.
         * @member {number} classLevel
         * @memberof Protocol.FightRoomInfo_Respond
         * @instance
         */
        FightRoomInfo_Respond.prototype.classLevel = 0;

        /**
         * Creates a new FightRoomInfo_Respond instance using the specified properties.
         * @function create
         * @memberof Protocol.FightRoomInfo_Respond
         * @static
         * @param {Protocol.IFightRoomInfo_Respond=} [properties] Properties to set
         * @returns {Protocol.FightRoomInfo_Respond} FightRoomInfo_Respond instance
         */
        FightRoomInfo_Respond.create = function create(properties) {
            return new FightRoomInfo_Respond(properties);
        };

        /**
         * Encodes the specified FightRoomInfo_Respond message. Does not implicitly {@link Protocol.FightRoomInfo_Respond.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FightRoomInfo_Respond
         * @static
         * @param {Protocol.IFightRoomInfo_Respond} message FightRoomInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightRoomInfo_Respond.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.Protocol.MatchInfo.encode(message.infos[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.fightIp != null && message.hasOwnProperty("fightIp"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.fightIp);
            if (message.secrete != null && message.hasOwnProperty("secrete"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.secrete);
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.roomId);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            if (message.mapID != null && message.hasOwnProperty("mapID"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.mapID);
            if (message.classLevel != null && message.hasOwnProperty("classLevel"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.classLevel);
            return writer;
        };

        /**
         * Encodes the specified FightRoomInfo_Respond message, length delimited. Does not implicitly {@link Protocol.FightRoomInfo_Respond.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FightRoomInfo_Respond
         * @static
         * @param {Protocol.IFightRoomInfo_Respond} message FightRoomInfo_Respond message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightRoomInfo_Respond.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightRoomInfo_Respond message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FightRoomInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FightRoomInfo_Respond} FightRoomInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightRoomInfo_Respond.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FightRoomInfo_Respond();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.Protocol.MatchInfo.decode(reader, reader.uint32()));
                    break;
                case 2:
                    message.fightIp = reader.string();
                    break;
                case 3:
                    message.secrete = reader.string();
                    break;
                case 4:
                    message.roomId = reader.string();
                    break;
                case 5:
                    message.type = reader.int32();
                    break;
                case 6:
                    message.mapID = reader.int32();
                    break;
                case 7:
                    message.classLevel = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightRoomInfo_Respond message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FightRoomInfo_Respond
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FightRoomInfo_Respond} FightRoomInfo_Respond
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightRoomInfo_Respond.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightRoomInfo_Respond message.
         * @function verify
         * @memberof Protocol.FightRoomInfo_Respond
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightRoomInfo_Respond.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.Protocol.MatchInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            if (message.fightIp != null && message.hasOwnProperty("fightIp"))
                if (!$util.isString(message.fightIp))
                    return "fightIp: string expected";
            if (message.secrete != null && message.hasOwnProperty("secrete"))
                if (!$util.isString(message.secrete))
                    return "secrete: string expected";
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (!$util.isString(message.roomId))
                    return "roomId: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.mapID != null && message.hasOwnProperty("mapID"))
                if (!$util.isInteger(message.mapID))
                    return "mapID: integer expected";
            if (message.classLevel != null && message.hasOwnProperty("classLevel"))
                if (!$util.isInteger(message.classLevel))
                    return "classLevel: integer expected";
            return null;
        };

        return FightRoomInfo_Respond;
    })();

    Protocol.SimpleHero = (function() {

        /**
         * Properties of a SimpleHero.
         * @memberof Protocol
         * @interface ISimpleHero
         * @property {number|null} [index] SimpleHero index
         * @property {number|null} [level] SimpleHero level
         */

        /**
         * Constructs a new SimpleHero.
         * @memberof Protocol
         * @classdesc Represents a SimpleHero.
         * @implements ISimpleHero
         * @constructor
         * @param {Protocol.ISimpleHero=} [properties] Properties to set
         */
        function SimpleHero(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimpleHero index.
         * @member {number} index
         * @memberof Protocol.SimpleHero
         * @instance
         */
        SimpleHero.prototype.index = 0;

        /**
         * SimpleHero level.
         * @member {number} level
         * @memberof Protocol.SimpleHero
         * @instance
         */
        SimpleHero.prototype.level = 0;

        /**
         * Creates a new SimpleHero instance using the specified properties.
         * @function create
         * @memberof Protocol.SimpleHero
         * @static
         * @param {Protocol.ISimpleHero=} [properties] Properties to set
         * @returns {Protocol.SimpleHero} SimpleHero instance
         */
        SimpleHero.create = function create(properties) {
            return new SimpleHero(properties);
        };

        /**
         * Encodes the specified SimpleHero message. Does not implicitly {@link Protocol.SimpleHero.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SimpleHero
         * @static
         * @param {Protocol.ISimpleHero} message SimpleHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleHero.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.level);
            return writer;
        };

        /**
         * Encodes the specified SimpleHero message, length delimited. Does not implicitly {@link Protocol.SimpleHero.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SimpleHero
         * @static
         * @param {Protocol.ISimpleHero} message SimpleHero message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleHero.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimpleHero message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SimpleHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SimpleHero} SimpleHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleHero.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SimpleHero();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.level = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimpleHero message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SimpleHero
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SimpleHero} SimpleHero
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleHero.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimpleHero message.
         * @function verify
         * @memberof Protocol.SimpleHero
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimpleHero.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            return null;
        };

        return SimpleHero;
    })();

    Protocol.RankInfo = (function() {

        /**
         * Properties of a RankInfo.
         * @memberof Protocol
         * @interface IRankInfo
         * @property {string|null} [roleName] RankInfo roleName
         * @property {number|Long|null} [roleId] RankInfo roleId
         * @property {number|null} [serverId] RankInfo serverId
         * @property {number|null} [cups] RankInfo cups
         * @property {string|null} [familyName] RankInfo familyName
         * @property {number|null} [rolePic] RankInfo rolePic
         * @property {number|null} [rank] RankInfo rank
         * @property {number|null} [level] RankInfo level
         * @property {number|null} [classLevel] RankInfo classLevel
         * @property {Array.<Protocol.ISimpleHero>|null} [heros] RankInfo heros
         * @property {string|null} [familyId] RankInfo familyId
         */

        /**
         * Constructs a new RankInfo.
         * @memberof Protocol
         * @classdesc Represents a RankInfo.
         * @implements IRankInfo
         * @constructor
         * @param {Protocol.IRankInfo=} [properties] Properties to set
         */
        function RankInfo(properties) {
            this.heros = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RankInfo roleName.
         * @member {string} roleName
         * @memberof Protocol.RankInfo
         * @instance
         */
        RankInfo.prototype.roleName = "";

        /**
         * RankInfo roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.RankInfo
         * @instance
         */
        RankInfo.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * RankInfo serverId.
         * @member {number} serverId
         * @memberof Protocol.RankInfo
         * @instance
         */
        RankInfo.prototype.serverId = 0;

        /**
         * RankInfo cups.
         * @member {number} cups
         * @memberof Protocol.RankInfo
         * @instance
         */
        RankInfo.prototype.cups = 0;

        /**
         * RankInfo familyName.
         * @member {string} familyName
         * @memberof Protocol.RankInfo
         * @instance
         */
        RankInfo.prototype.familyName = "";

        /**
         * RankInfo rolePic.
         * @member {number} rolePic
         * @memberof Protocol.RankInfo
         * @instance
         */
        RankInfo.prototype.rolePic = 0;

        /**
         * RankInfo rank.
         * @member {number} rank
         * @memberof Protocol.RankInfo
         * @instance
         */
        RankInfo.prototype.rank = 0;

        /**
         * RankInfo level.
         * @member {number} level
         * @memberof Protocol.RankInfo
         * @instance
         */
        RankInfo.prototype.level = 0;

        /**
         * RankInfo classLevel.
         * @member {number} classLevel
         * @memberof Protocol.RankInfo
         * @instance
         */
        RankInfo.prototype.classLevel = 0;

        /**
         * RankInfo heros.
         * @member {Array.<Protocol.ISimpleHero>} heros
         * @memberof Protocol.RankInfo
         * @instance
         */
        RankInfo.prototype.heros = $util.emptyArray;

        /**
         * RankInfo familyId.
         * @member {string} familyId
         * @memberof Protocol.RankInfo
         * @instance
         */
        RankInfo.prototype.familyId = "";

        /**
         * Creates a new RankInfo instance using the specified properties.
         * @function create
         * @memberof Protocol.RankInfo
         * @static
         * @param {Protocol.IRankInfo=} [properties] Properties to set
         * @returns {Protocol.RankInfo} RankInfo instance
         */
        RankInfo.create = function create(properties) {
            return new RankInfo(properties);
        };

        /**
         * Encodes the specified RankInfo message. Does not implicitly {@link Protocol.RankInfo.verify|verify} messages.
         * @function encode
         * @memberof Protocol.RankInfo
         * @static
         * @param {Protocol.IRankInfo} message RankInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleName != null && message.hasOwnProperty("roleName"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.roleName);
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.roleId);
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.serverId);
            if (message.cups != null && message.hasOwnProperty("cups"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cups);
            if (message.familyName != null && message.hasOwnProperty("familyName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.familyName);
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.rolePic);
            if (message.rank != null && message.hasOwnProperty("rank"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.rank);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.level);
            if (message.classLevel != null && message.hasOwnProperty("classLevel"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.classLevel);
            if (message.heros != null && message.heros.length)
                for (var i = 0; i < message.heros.length; ++i)
                    $root.Protocol.SimpleHero.encode(message.heros[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                writer.uint32(/* id 11, wireType 2 =*/90).string(message.familyId);
            return writer;
        };

        /**
         * Encodes the specified RankInfo message, length delimited. Does not implicitly {@link Protocol.RankInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.RankInfo
         * @static
         * @param {Protocol.IRankInfo} message RankInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RankInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RankInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.RankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.RankInfo} RankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.RankInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleName = reader.string();
                    break;
                case 2:
                    message.roleId = reader.int64();
                    break;
                case 3:
                    message.serverId = reader.int32();
                    break;
                case 4:
                    message.cups = reader.int32();
                    break;
                case 5:
                    message.familyName = reader.string();
                    break;
                case 6:
                    message.rolePic = reader.int32();
                    break;
                case 7:
                    message.rank = reader.int32();
                    break;
                case 8:
                    message.level = reader.int32();
                    break;
                case 9:
                    message.classLevel = reader.int32();
                    break;
                case 10:
                    if (!(message.heros && message.heros.length))
                        message.heros = [];
                    message.heros.push($root.Protocol.SimpleHero.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.familyId = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RankInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.RankInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.RankInfo} RankInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RankInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RankInfo message.
         * @function verify
         * @memberof Protocol.RankInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RankInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleName != null && message.hasOwnProperty("roleName"))
                if (!$util.isString(message.roleName))
                    return "roleName: string expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            if (message.cups != null && message.hasOwnProperty("cups"))
                if (!$util.isInteger(message.cups))
                    return "cups: integer expected";
            if (message.familyName != null && message.hasOwnProperty("familyName"))
                if (!$util.isString(message.familyName))
                    return "familyName: string expected";
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                if (!$util.isInteger(message.rolePic))
                    return "rolePic: integer expected";
            if (message.rank != null && message.hasOwnProperty("rank"))
                if (!$util.isInteger(message.rank))
                    return "rank: integer expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.classLevel != null && message.hasOwnProperty("classLevel"))
                if (!$util.isInteger(message.classLevel))
                    return "classLevel: integer expected";
            if (message.heros != null && message.hasOwnProperty("heros")) {
                if (!Array.isArray(message.heros))
                    return "heros: array expected";
                for (var i = 0; i < message.heros.length; ++i) {
                    var error = $root.Protocol.SimpleHero.verify(message.heros[i]);
                    if (error)
                        return "heros." + error;
                }
            }
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                if (!$util.isString(message.familyId))
                    return "familyId: string expected";
            return null;
        };

        return RankInfo;
    })();

    Protocol.Task = (function() {

        /**
         * Properties of a Task.
         * @memberof Protocol
         * @interface ITask
         * @property {number|null} [taskId] Task taskId
         * @property {number|null} [finishCount] Task finishCount
         * @property {boolean|null} [isFinish] Task isFinish
         * @property {number|Long|null} [finishTime] Task finishTime
         * @property {number|null} [grid] Task grid
         * @property {Array.<Protocol.IReward>|null} [rewards] Task rewards
         */

        /**
         * Constructs a new Task.
         * @memberof Protocol
         * @classdesc Represents a Task.
         * @implements ITask
         * @constructor
         * @param {Protocol.ITask=} [properties] Properties to set
         */
        function Task(properties) {
            this.rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Task taskId.
         * @member {number} taskId
         * @memberof Protocol.Task
         * @instance
         */
        Task.prototype.taskId = 0;

        /**
         * Task finishCount.
         * @member {number} finishCount
         * @memberof Protocol.Task
         * @instance
         */
        Task.prototype.finishCount = 0;

        /**
         * Task isFinish.
         * @member {boolean} isFinish
         * @memberof Protocol.Task
         * @instance
         */
        Task.prototype.isFinish = false;

        /**
         * Task finishTime.
         * @member {number|Long} finishTime
         * @memberof Protocol.Task
         * @instance
         */
        Task.prototype.finishTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Task grid.
         * @member {number} grid
         * @memberof Protocol.Task
         * @instance
         */
        Task.prototype.grid = 0;

        /**
         * Task rewards.
         * @member {Array.<Protocol.IReward>} rewards
         * @memberof Protocol.Task
         * @instance
         */
        Task.prototype.rewards = $util.emptyArray;

        /**
         * Creates a new Task instance using the specified properties.
         * @function create
         * @memberof Protocol.Task
         * @static
         * @param {Protocol.ITask=} [properties] Properties to set
         * @returns {Protocol.Task} Task instance
         */
        Task.create = function create(properties) {
            return new Task(properties);
        };

        /**
         * Encodes the specified Task message. Does not implicitly {@link Protocol.Task.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Task
         * @static
         * @param {Protocol.ITask} message Task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Task.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.taskId);
            if (message.finishCount != null && message.hasOwnProperty("finishCount"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.finishCount);
            if (message.isFinish != null && message.hasOwnProperty("isFinish"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isFinish);
            if (message.finishTime != null && message.hasOwnProperty("finishTime"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.finishTime);
            if (message.grid != null && message.hasOwnProperty("grid"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.grid);
            if (message.rewards != null && message.rewards.length)
                for (var i = 0; i < message.rewards.length; ++i)
                    $root.Protocol.Reward.encode(message.rewards[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Task message, length delimited. Does not implicitly {@link Protocol.Task.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Task
         * @static
         * @param {Protocol.ITask} message Task message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Task.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Task message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Task} Task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Task.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Task();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.taskId = reader.int32();
                    break;
                case 2:
                    message.finishCount = reader.int32();
                    break;
                case 3:
                    message.isFinish = reader.bool();
                    break;
                case 4:
                    message.finishTime = reader.int64();
                    break;
                case 5:
                    message.grid = reader.int32();
                    break;
                case 6:
                    if (!(message.rewards && message.rewards.length))
                        message.rewards = [];
                    message.rewards.push($root.Protocol.Reward.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Task message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Task
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Task} Task
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Task.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Task message.
         * @function verify
         * @memberof Protocol.Task
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Task.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.taskId != null && message.hasOwnProperty("taskId"))
                if (!$util.isInteger(message.taskId))
                    return "taskId: integer expected";
            if (message.finishCount != null && message.hasOwnProperty("finishCount"))
                if (!$util.isInteger(message.finishCount))
                    return "finishCount: integer expected";
            if (message.isFinish != null && message.hasOwnProperty("isFinish"))
                if (typeof message.isFinish !== "boolean")
                    return "isFinish: boolean expected";
            if (message.finishTime != null && message.hasOwnProperty("finishTime"))
                if (!$util.isInteger(message.finishTime) && !(message.finishTime && $util.isInteger(message.finishTime.low) && $util.isInteger(message.finishTime.high)))
                    return "finishTime: integer|Long expected";
            if (message.grid != null && message.hasOwnProperty("grid"))
                if (!$util.isInteger(message.grid))
                    return "grid: integer expected";
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                if (!Array.isArray(message.rewards))
                    return "rewards: array expected";
                for (var i = 0; i < message.rewards.length; ++i) {
                    var error = $root.Protocol.Reward.verify(message.rewards[i]);
                    if (error)
                        return "rewards." + error;
                }
            }
            return null;
        };

        return Task;
    })();

    Protocol.Reward = (function() {

        /**
         * Properties of a Reward.
         * @memberof Protocol
         * @interface IReward
         * @property {number|null} [type] Reward type
         * @property {number|null} [index] Reward index
         * @property {number|null} [count] Reward count
         */

        /**
         * Constructs a new Reward.
         * @memberof Protocol
         * @classdesc Represents a Reward.
         * @implements IReward
         * @constructor
         * @param {Protocol.IReward=} [properties] Properties to set
         */
        function Reward(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Reward type.
         * @member {number} type
         * @memberof Protocol.Reward
         * @instance
         */
        Reward.prototype.type = 0;

        /**
         * Reward index.
         * @member {number} index
         * @memberof Protocol.Reward
         * @instance
         */
        Reward.prototype.index = 0;

        /**
         * Reward count.
         * @member {number} count
         * @memberof Protocol.Reward
         * @instance
         */
        Reward.prototype.count = 0;

        /**
         * Creates a new Reward instance using the specified properties.
         * @function create
         * @memberof Protocol.Reward
         * @static
         * @param {Protocol.IReward=} [properties] Properties to set
         * @returns {Protocol.Reward} Reward instance
         */
        Reward.create = function create(properties) {
            return new Reward(properties);
        };

        /**
         * Encodes the specified Reward message. Does not implicitly {@link Protocol.Reward.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Reward
         * @static
         * @param {Protocol.IReward} message Reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Reward.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.index);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.count);
            return writer;
        };

        /**
         * Encodes the specified Reward message, length delimited. Does not implicitly {@link Protocol.Reward.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Reward
         * @static
         * @param {Protocol.IReward} message Reward message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Reward.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Reward message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Reward} Reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Reward.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Reward();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.index = reader.int32();
                    break;
                case 3:
                    message.count = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Reward message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Reward
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Reward} Reward
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Reward.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Reward message.
         * @function verify
         * @memberof Protocol.Reward
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Reward.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            return null;
        };

        return Reward;
    })();

    Protocol.Friend = (function() {

        /**
         * Properties of a Friend.
         * @memberof Protocol
         * @interface IFriend
         * @property {number|Long|null} [roleId] Friend roleId
         * @property {string|null} [name] Friend name
         * @property {number|null} [level] Friend level
         * @property {number|null} [cups] Friend cups
         * @property {number|null} [serverId] Friend serverId
         * @property {string|null} [iconName] Friend iconName
         * @property {number|null} [edgeId] Friend edgeId
         * @property {boolean|null} [state] Friend state
         * @property {number|null} [rolePic] Friend rolePic
         * @property {string|null} [familyName] Friend familyName
         */

        /**
         * Constructs a new Friend.
         * @memberof Protocol
         * @classdesc Represents a Friend.
         * @implements IFriend
         * @constructor
         * @param {Protocol.IFriend=} [properties] Properties to set
         */
        function Friend(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Friend roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.Friend
         * @instance
         */
        Friend.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Friend name.
         * @member {string} name
         * @memberof Protocol.Friend
         * @instance
         */
        Friend.prototype.name = "";

        /**
         * Friend level.
         * @member {number} level
         * @memberof Protocol.Friend
         * @instance
         */
        Friend.prototype.level = 0;

        /**
         * Friend cups.
         * @member {number} cups
         * @memberof Protocol.Friend
         * @instance
         */
        Friend.prototype.cups = 0;

        /**
         * Friend serverId.
         * @member {number} serverId
         * @memberof Protocol.Friend
         * @instance
         */
        Friend.prototype.serverId = 0;

        /**
         * Friend iconName.
         * @member {string} iconName
         * @memberof Protocol.Friend
         * @instance
         */
        Friend.prototype.iconName = "";

        /**
         * Friend edgeId.
         * @member {number} edgeId
         * @memberof Protocol.Friend
         * @instance
         */
        Friend.prototype.edgeId = 0;

        /**
         * Friend state.
         * @member {boolean} state
         * @memberof Protocol.Friend
         * @instance
         */
        Friend.prototype.state = false;

        /**
         * Friend rolePic.
         * @member {number} rolePic
         * @memberof Protocol.Friend
         * @instance
         */
        Friend.prototype.rolePic = 0;

        /**
         * Friend familyName.
         * @member {string} familyName
         * @memberof Protocol.Friend
         * @instance
         */
        Friend.prototype.familyName = "";

        /**
         * Creates a new Friend instance using the specified properties.
         * @function create
         * @memberof Protocol.Friend
         * @static
         * @param {Protocol.IFriend=} [properties] Properties to set
         * @returns {Protocol.Friend} Friend instance
         */
        Friend.create = function create(properties) {
            return new Friend(properties);
        };

        /**
         * Encodes the specified Friend message. Does not implicitly {@link Protocol.Friend.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Friend
         * @static
         * @param {Protocol.IFriend} message Friend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Friend.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);
            if (message.cups != null && message.hasOwnProperty("cups"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.cups);
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.serverId);
            if (message.iconName != null && message.hasOwnProperty("iconName"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.iconName);
            if (message.edgeId != null && message.hasOwnProperty("edgeId"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.edgeId);
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 8, wireType 0 =*/64).bool(message.state);
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.rolePic);
            if (message.familyName != null && message.hasOwnProperty("familyName"))
                writer.uint32(/* id 10, wireType 2 =*/82).string(message.familyName);
            return writer;
        };

        /**
         * Encodes the specified Friend message, length delimited. Does not implicitly {@link Protocol.Friend.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Friend
         * @static
         * @param {Protocol.IFriend} message Friend message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Friend.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Friend message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Friend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Friend} Friend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Friend.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Friend();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.level = reader.int32();
                    break;
                case 4:
                    message.cups = reader.int32();
                    break;
                case 5:
                    message.serverId = reader.int32();
                    break;
                case 6:
                    message.iconName = reader.string();
                    break;
                case 7:
                    message.edgeId = reader.int32();
                    break;
                case 8:
                    message.state = reader.bool();
                    break;
                case 9:
                    message.rolePic = reader.int32();
                    break;
                case 10:
                    message.familyName = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Friend message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Friend
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Friend} Friend
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Friend.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Friend message.
         * @function verify
         * @memberof Protocol.Friend
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Friend.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.cups != null && message.hasOwnProperty("cups"))
                if (!$util.isInteger(message.cups))
                    return "cups: integer expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            if (message.iconName != null && message.hasOwnProperty("iconName"))
                if (!$util.isString(message.iconName))
                    return "iconName: string expected";
            if (message.edgeId != null && message.hasOwnProperty("edgeId"))
                if (!$util.isInteger(message.edgeId))
                    return "edgeId: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (typeof message.state !== "boolean")
                    return "state: boolean expected";
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                if (!$util.isInteger(message.rolePic))
                    return "rolePic: integer expected";
            if (message.familyName != null && message.hasOwnProperty("familyName"))
                if (!$util.isString(message.familyName))
                    return "familyName: string expected";
            return null;
        };

        return Friend;
    })();

    Protocol.Invite = (function() {

        /**
         * Properties of an Invite.
         * @memberof Protocol
         * @interface IInvite
         * @property {Protocol.IFriend|null} [from] Invite from
         * @property {number|Long|null} [time] Invite time
         */

        /**
         * Constructs a new Invite.
         * @memberof Protocol
         * @classdesc Represents an Invite.
         * @implements IInvite
         * @constructor
         * @param {Protocol.IInvite=} [properties] Properties to set
         */
        function Invite(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Invite from.
         * @member {Protocol.IFriend|null|undefined} from
         * @memberof Protocol.Invite
         * @instance
         */
        Invite.prototype.from = null;

        /**
         * Invite time.
         * @member {number|Long} time
         * @memberof Protocol.Invite
         * @instance
         */
        Invite.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new Invite instance using the specified properties.
         * @function create
         * @memberof Protocol.Invite
         * @static
         * @param {Protocol.IInvite=} [properties] Properties to set
         * @returns {Protocol.Invite} Invite instance
         */
        Invite.create = function create(properties) {
            return new Invite(properties);
        };

        /**
         * Encodes the specified Invite message. Does not implicitly {@link Protocol.Invite.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Invite
         * @static
         * @param {Protocol.IInvite} message Invite message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invite.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.from != null && message.hasOwnProperty("from"))
                $root.Protocol.Friend.encode(message.from, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.time);
            return writer;
        };

        /**
         * Encodes the specified Invite message, length delimited. Does not implicitly {@link Protocol.Invite.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Invite
         * @static
         * @param {Protocol.IInvite} message Invite message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Invite.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Invite message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Invite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Invite} Invite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invite.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Invite();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.from = $root.Protocol.Friend.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.time = reader.int64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Invite message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Invite
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Invite} Invite
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Invite.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Invite message.
         * @function verify
         * @memberof Protocol.Invite
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Invite.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.from != null && message.hasOwnProperty("from")) {
                var error = $root.Protocol.Friend.verify(message.from);
                if (error)
                    return "from." + error;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            return null;
        };

        return Invite;
    })();

    Protocol.Chat = (function() {

        /**
         * Properties of a Chat.
         * @memberof Protocol
         * @interface IChat
         * @property {string|null} [content] Chat content
         * @property {number|Long|null} [senderId] Chat senderId
         * @property {number|Long|null} [time] Chat time
         * @property {number|Long|null} [friendId] Chat friendId
         * @property {number|null} [type] Chat type
         */

        /**
         * Constructs a new Chat.
         * @memberof Protocol
         * @classdesc Represents a Chat.
         * @implements IChat
         * @constructor
         * @param {Protocol.IChat=} [properties] Properties to set
         */
        function Chat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Chat content.
         * @member {string} content
         * @memberof Protocol.Chat
         * @instance
         */
        Chat.prototype.content = "";

        /**
         * Chat senderId.
         * @member {number|Long} senderId
         * @memberof Protocol.Chat
         * @instance
         */
        Chat.prototype.senderId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Chat time.
         * @member {number|Long} time
         * @memberof Protocol.Chat
         * @instance
         */
        Chat.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Chat friendId.
         * @member {number|Long} friendId
         * @memberof Protocol.Chat
         * @instance
         */
        Chat.prototype.friendId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Chat type.
         * @member {number} type
         * @memberof Protocol.Chat
         * @instance
         */
        Chat.prototype.type = 0;

        /**
         * Creates a new Chat instance using the specified properties.
         * @function create
         * @memberof Protocol.Chat
         * @static
         * @param {Protocol.IChat=} [properties] Properties to set
         * @returns {Protocol.Chat} Chat instance
         */
        Chat.create = function create(properties) {
            return new Chat(properties);
        };

        /**
         * Encodes the specified Chat message. Does not implicitly {@link Protocol.Chat.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Chat
         * @static
         * @param {Protocol.IChat} message Chat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.senderId);
            if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.time);
            if (message.friendId != null && message.hasOwnProperty("friendId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.friendId);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified Chat message, length delimited. Does not implicitly {@link Protocol.Chat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Chat
         * @static
         * @param {Protocol.IChat} message Chat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Chat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Chat message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Chat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Chat} Chat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Chat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.content = reader.string();
                    break;
                case 2:
                    message.senderId = reader.int64();
                    break;
                case 3:
                    message.time = reader.int64();
                    break;
                case 4:
                    message.friendId = reader.int64();
                    break;
                case 5:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Chat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Chat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Chat} Chat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Chat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Chat message.
         * @function verify
         * @memberof Protocol.Chat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Chat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.senderId != null && message.hasOwnProperty("senderId"))
                if (!$util.isInteger(message.senderId) && !(message.senderId && $util.isInteger(message.senderId.low) && $util.isInteger(message.senderId.high)))
                    return "senderId: integer|Long expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.friendId != null && message.hasOwnProperty("friendId"))
                if (!$util.isInteger(message.friendId) && !(message.friendId && $util.isInteger(message.friendId.low) && $util.isInteger(message.friendId.high)))
                    return "friendId: integer|Long expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        return Chat;
    })();

    Protocol.FamilyInfo = (function() {

        /**
         * Properties of a FamilyInfo.
         * @memberof Protocol
         * @interface IFamilyInfo
         * @property {string|null} [familyId] FamilyInfo familyId
         * @property {string|null} [familyName] FamilyInfo familyName
         * @property {number|null} [familyPic] FamilyInfo familyPic
         * @property {string|null} [introduce] FamilyInfo introduce
         * @property {number|null} [count] FamilyInfo count
         * @property {number|null} [autoCup] FamilyInfo autoCup
         * @property {number|null} [power] FamilyInfo power
         * @property {number|null} [rolePic] FamilyInfo rolePic
         */

        /**
         * Constructs a new FamilyInfo.
         * @memberof Protocol
         * @classdesc Represents a FamilyInfo.
         * @implements IFamilyInfo
         * @constructor
         * @param {Protocol.IFamilyInfo=} [properties] Properties to set
         */
        function FamilyInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FamilyInfo familyId.
         * @member {string} familyId
         * @memberof Protocol.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.familyId = "";

        /**
         * FamilyInfo familyName.
         * @member {string} familyName
         * @memberof Protocol.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.familyName = "";

        /**
         * FamilyInfo familyPic.
         * @member {number} familyPic
         * @memberof Protocol.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.familyPic = 0;

        /**
         * FamilyInfo introduce.
         * @member {string} introduce
         * @memberof Protocol.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.introduce = "";

        /**
         * FamilyInfo count.
         * @member {number} count
         * @memberof Protocol.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.count = 0;

        /**
         * FamilyInfo autoCup.
         * @member {number} autoCup
         * @memberof Protocol.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.autoCup = 0;

        /**
         * FamilyInfo power.
         * @member {number} power
         * @memberof Protocol.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.power = 0;

        /**
         * FamilyInfo rolePic.
         * @member {number} rolePic
         * @memberof Protocol.FamilyInfo
         * @instance
         */
        FamilyInfo.prototype.rolePic = 0;

        /**
         * Creates a new FamilyInfo instance using the specified properties.
         * @function create
         * @memberof Protocol.FamilyInfo
         * @static
         * @param {Protocol.IFamilyInfo=} [properties] Properties to set
         * @returns {Protocol.FamilyInfo} FamilyInfo instance
         */
        FamilyInfo.create = function create(properties) {
            return new FamilyInfo(properties);
        };

        /**
         * Encodes the specified FamilyInfo message. Does not implicitly {@link Protocol.FamilyInfo.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FamilyInfo
         * @static
         * @param {Protocol.IFamilyInfo} message FamilyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.familyId);
            if (message.familyName != null && message.hasOwnProperty("familyName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.familyName);
            if (message.familyPic != null && message.hasOwnProperty("familyPic"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.familyPic);
            if (message.introduce != null && message.hasOwnProperty("introduce"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.introduce);
            if (message.count != null && message.hasOwnProperty("count"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.count);
            if (message.autoCup != null && message.hasOwnProperty("autoCup"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.autoCup);
            if (message.power != null && message.hasOwnProperty("power"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.power);
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.rolePic);
            return writer;
        };

        /**
         * Encodes the specified FamilyInfo message, length delimited. Does not implicitly {@link Protocol.FamilyInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FamilyInfo
         * @static
         * @param {Protocol.IFamilyInfo} message FamilyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FamilyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FamilyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FamilyInfo} FamilyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FamilyInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.familyId = reader.string();
                    break;
                case 2:
                    message.familyName = reader.string();
                    break;
                case 3:
                    message.familyPic = reader.int32();
                    break;
                case 4:
                    message.introduce = reader.string();
                    break;
                case 5:
                    message.count = reader.int32();
                    break;
                case 6:
                    message.autoCup = reader.int32();
                    break;
                case 8:
                    message.power = reader.int32();
                    break;
                case 9:
                    message.rolePic = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FamilyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FamilyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FamilyInfo} FamilyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FamilyInfo message.
         * @function verify
         * @memberof Protocol.FamilyInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FamilyInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.familyId != null && message.hasOwnProperty("familyId"))
                if (!$util.isString(message.familyId))
                    return "familyId: string expected";
            if (message.familyName != null && message.hasOwnProperty("familyName"))
                if (!$util.isString(message.familyName))
                    return "familyName: string expected";
            if (message.familyPic != null && message.hasOwnProperty("familyPic"))
                if (!$util.isInteger(message.familyPic))
                    return "familyPic: integer expected";
            if (message.introduce != null && message.hasOwnProperty("introduce"))
                if (!$util.isString(message.introduce))
                    return "introduce: string expected";
            if (message.count != null && message.hasOwnProperty("count"))
                if (!$util.isInteger(message.count))
                    return "count: integer expected";
            if (message.autoCup != null && message.hasOwnProperty("autoCup"))
                if (!$util.isInteger(message.autoCup))
                    return "autoCup: integer expected";
            if (message.power != null && message.hasOwnProperty("power"))
                if (!$util.isInteger(message.power))
                    return "power: integer expected";
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                if (!$util.isInteger(message.rolePic))
                    return "rolePic: integer expected";
            return null;
        };

        return FamilyInfo;
    })();

    Protocol.FamilyMember = (function() {

        /**
         * Properties of a FamilyMember.
         * @memberof Protocol
         * @interface IFamilyMember
         * @property {number|Long|null} [roleId] FamilyMember roleId
         * @property {string|null} [name] FamilyMember name
         * @property {number|null} [level] FamilyMember level
         * @property {number|null} [serverId] FamilyMember serverId
         * @property {number|null} [cups] FamilyMember cups
         * @property {boolean|null} [state] FamilyMember state
         * @property {number|null} [rolePic] FamilyMember rolePic
         * @property {number|null} [jobber] FamilyMember jobber
         * @property {number|null} [classLv] FamilyMember classLv
         */

        /**
         * Constructs a new FamilyMember.
         * @memberof Protocol
         * @classdesc Represents a FamilyMember.
         * @implements IFamilyMember
         * @constructor
         * @param {Protocol.IFamilyMember=} [properties] Properties to set
         */
        function FamilyMember(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FamilyMember roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.FamilyMember
         * @instance
         */
        FamilyMember.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FamilyMember name.
         * @member {string} name
         * @memberof Protocol.FamilyMember
         * @instance
         */
        FamilyMember.prototype.name = "";

        /**
         * FamilyMember level.
         * @member {number} level
         * @memberof Protocol.FamilyMember
         * @instance
         */
        FamilyMember.prototype.level = 0;

        /**
         * FamilyMember serverId.
         * @member {number} serverId
         * @memberof Protocol.FamilyMember
         * @instance
         */
        FamilyMember.prototype.serverId = 0;

        /**
         * FamilyMember cups.
         * @member {number} cups
         * @memberof Protocol.FamilyMember
         * @instance
         */
        FamilyMember.prototype.cups = 0;

        /**
         * FamilyMember state.
         * @member {boolean} state
         * @memberof Protocol.FamilyMember
         * @instance
         */
        FamilyMember.prototype.state = false;

        /**
         * FamilyMember rolePic.
         * @member {number} rolePic
         * @memberof Protocol.FamilyMember
         * @instance
         */
        FamilyMember.prototype.rolePic = 0;

        /**
         * FamilyMember jobber.
         * @member {number} jobber
         * @memberof Protocol.FamilyMember
         * @instance
         */
        FamilyMember.prototype.jobber = 0;

        /**
         * FamilyMember classLv.
         * @member {number} classLv
         * @memberof Protocol.FamilyMember
         * @instance
         */
        FamilyMember.prototype.classLv = 0;

        /**
         * Creates a new FamilyMember instance using the specified properties.
         * @function create
         * @memberof Protocol.FamilyMember
         * @static
         * @param {Protocol.IFamilyMember=} [properties] Properties to set
         * @returns {Protocol.FamilyMember} FamilyMember instance
         */
        FamilyMember.create = function create(properties) {
            return new FamilyMember(properties);
        };

        /**
         * Encodes the specified FamilyMember message. Does not implicitly {@link Protocol.FamilyMember.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FamilyMember
         * @static
         * @param {Protocol.IFamilyMember} message FamilyMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyMember.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.name != null && message.hasOwnProperty("name"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
            if (message.level != null && message.hasOwnProperty("level"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.level);
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.serverId);
            if (message.cups != null && message.hasOwnProperty("cups"))
                writer.uint32(/* id 5, wireType 0 =*/40).int32(message.cups);
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.state);
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.rolePic);
            if (message.jobber != null && message.hasOwnProperty("jobber"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.jobber);
            if (message.classLv != null && message.hasOwnProperty("classLv"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.classLv);
            return writer;
        };

        /**
         * Encodes the specified FamilyMember message, length delimited. Does not implicitly {@link Protocol.FamilyMember.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FamilyMember
         * @static
         * @param {Protocol.IFamilyMember} message FamilyMember message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyMember.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FamilyMember message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FamilyMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FamilyMember} FamilyMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyMember.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FamilyMember();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.name = reader.string();
                    break;
                case 3:
                    message.level = reader.int32();
                    break;
                case 4:
                    message.serverId = reader.int32();
                    break;
                case 5:
                    message.cups = reader.int32();
                    break;
                case 6:
                    message.state = reader.bool();
                    break;
                case 7:
                    message.rolePic = reader.int32();
                    break;
                case 8:
                    message.jobber = reader.int32();
                    break;
                case 9:
                    message.classLv = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FamilyMember message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FamilyMember
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FamilyMember} FamilyMember
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyMember.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FamilyMember message.
         * @function verify
         * @memberof Protocol.FamilyMember
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FamilyMember.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.level != null && message.hasOwnProperty("level"))
                if (!$util.isInteger(message.level))
                    return "level: integer expected";
            if (message.serverId != null && message.hasOwnProperty("serverId"))
                if (!$util.isInteger(message.serverId))
                    return "serverId: integer expected";
            if (message.cups != null && message.hasOwnProperty("cups"))
                if (!$util.isInteger(message.cups))
                    return "cups: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (typeof message.state !== "boolean")
                    return "state: boolean expected";
            if (message.rolePic != null && message.hasOwnProperty("rolePic"))
                if (!$util.isInteger(message.rolePic))
                    return "rolePic: integer expected";
            if (message.jobber != null && message.hasOwnProperty("jobber"))
                if (!$util.isInteger(message.jobber))
                    return "jobber: integer expected";
            if (message.classLv != null && message.hasOwnProperty("classLv"))
                if (!$util.isInteger(message.classLv))
                    return "classLv: integer expected";
            return null;
        };

        return FamilyMember;
    })();

    Protocol.FamilyChat = (function() {

        /**
         * Properties of a FamilyChat.
         * @memberof Protocol
         * @interface IFamilyChat
         * @property {string|null} [content] FamilyChat content
         * @property {number|null} [type] FamilyChat type
         * @property {number|Long|null} [sendTime] FamilyChat sendTime
         * @property {Protocol.IFamilyMember|null} [sender] FamilyChat sender
         */

        /**
         * Constructs a new FamilyChat.
         * @memberof Protocol
         * @classdesc Represents a FamilyChat.
         * @implements IFamilyChat
         * @constructor
         * @param {Protocol.IFamilyChat=} [properties] Properties to set
         */
        function FamilyChat(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FamilyChat content.
         * @member {string} content
         * @memberof Protocol.FamilyChat
         * @instance
         */
        FamilyChat.prototype.content = "";

        /**
         * FamilyChat type.
         * @member {number} type
         * @memberof Protocol.FamilyChat
         * @instance
         */
        FamilyChat.prototype.type = 0;

        /**
         * FamilyChat sendTime.
         * @member {number|Long} sendTime
         * @memberof Protocol.FamilyChat
         * @instance
         */
        FamilyChat.prototype.sendTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FamilyChat sender.
         * @member {Protocol.IFamilyMember|null|undefined} sender
         * @memberof Protocol.FamilyChat
         * @instance
         */
        FamilyChat.prototype.sender = null;

        /**
         * Creates a new FamilyChat instance using the specified properties.
         * @function create
         * @memberof Protocol.FamilyChat
         * @static
         * @param {Protocol.IFamilyChat=} [properties] Properties to set
         * @returns {Protocol.FamilyChat} FamilyChat instance
         */
        FamilyChat.create = function create(properties) {
            return new FamilyChat(properties);
        };

        /**
         * Encodes the specified FamilyChat message. Does not implicitly {@link Protocol.FamilyChat.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FamilyChat
         * @static
         * @param {Protocol.IFamilyChat} message FamilyChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyChat.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.content);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
            if (message.sendTime != null && message.hasOwnProperty("sendTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.sendTime);
            if (message.sender != null && message.hasOwnProperty("sender"))
                $root.Protocol.FamilyMember.encode(message.sender, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FamilyChat message, length delimited. Does not implicitly {@link Protocol.FamilyChat.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FamilyChat
         * @static
         * @param {Protocol.IFamilyChat} message FamilyChat message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FamilyChat.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FamilyChat message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FamilyChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FamilyChat} FamilyChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyChat.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FamilyChat();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.content = reader.string();
                    break;
                case 2:
                    message.type = reader.int32();
                    break;
                case 3:
                    message.sendTime = reader.int64();
                    break;
                case 4:
                    message.sender = $root.Protocol.FamilyMember.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FamilyChat message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FamilyChat
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FamilyChat} FamilyChat
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FamilyChat.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FamilyChat message.
         * @function verify
         * @memberof Protocol.FamilyChat
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FamilyChat.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.sendTime != null && message.hasOwnProperty("sendTime"))
                if (!$util.isInteger(message.sendTime) && !(message.sendTime && $util.isInteger(message.sendTime.low) && $util.isInteger(message.sendTime.high)))
                    return "sendTime: integer|Long expected";
            if (message.sender != null && message.hasOwnProperty("sender")) {
                var error = $root.Protocol.FamilyMember.verify(message.sender);
                if (error)
                    return "sender." + error;
            }
            return null;
        };

        return FamilyChat;
    })();

    Protocol.BuyInfo = (function() {

        /**
         * Properties of a BuyInfo.
         * @memberof Protocol
         * @interface IBuyInfo
         * @property {number|null} [hasBuyCount] BuyInfo hasBuyCount
         * @property {number|null} [treasureId] BuyInfo treasureId
         */

        /**
         * Constructs a new BuyInfo.
         * @memberof Protocol
         * @classdesc Represents a BuyInfo.
         * @implements IBuyInfo
         * @constructor
         * @param {Protocol.IBuyInfo=} [properties] Properties to set
         */
        function BuyInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BuyInfo hasBuyCount.
         * @member {number} hasBuyCount
         * @memberof Protocol.BuyInfo
         * @instance
         */
        BuyInfo.prototype.hasBuyCount = 0;

        /**
         * BuyInfo treasureId.
         * @member {number} treasureId
         * @memberof Protocol.BuyInfo
         * @instance
         */
        BuyInfo.prototype.treasureId = 0;

        /**
         * Creates a new BuyInfo instance using the specified properties.
         * @function create
         * @memberof Protocol.BuyInfo
         * @static
         * @param {Protocol.IBuyInfo=} [properties] Properties to set
         * @returns {Protocol.BuyInfo} BuyInfo instance
         */
        BuyInfo.create = function create(properties) {
            return new BuyInfo(properties);
        };

        /**
         * Encodes the specified BuyInfo message. Does not implicitly {@link Protocol.BuyInfo.verify|verify} messages.
         * @function encode
         * @memberof Protocol.BuyInfo
         * @static
         * @param {Protocol.IBuyInfo} message BuyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.hasBuyCount != null && message.hasOwnProperty("hasBuyCount"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.hasBuyCount);
            if (message.treasureId != null && message.hasOwnProperty("treasureId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.treasureId);
            return writer;
        };

        /**
         * Encodes the specified BuyInfo message, length delimited. Does not implicitly {@link Protocol.BuyInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.BuyInfo
         * @static
         * @param {Protocol.IBuyInfo} message BuyInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        BuyInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a BuyInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.BuyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.BuyInfo} BuyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.BuyInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.hasBuyCount = reader.int32();
                    break;
                case 2:
                    message.treasureId = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a BuyInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.BuyInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.BuyInfo} BuyInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        BuyInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a BuyInfo message.
         * @function verify
         * @memberof Protocol.BuyInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BuyInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.hasBuyCount != null && message.hasOwnProperty("hasBuyCount"))
                if (!$util.isInteger(message.hasBuyCount))
                    return "hasBuyCount: integer expected";
            if (message.treasureId != null && message.hasOwnProperty("treasureId"))
                if (!$util.isInteger(message.treasureId))
                    return "treasureId: integer expected";
            return null;
        };

        return BuyInfo;
    })();

    Protocol.Action_Request = (function() {

        /**
         * Properties of an Action_Request.
         * @memberof Protocol
         * @interface IAction_Request
         * @property {string|null} [roomId] Action_Request roomId
         * @property {Uint8Array|null} [actionArray] Action_Request actionArray
         */

        /**
         * Constructs a new Action_Request.
         * @memberof Protocol
         * @classdesc Represents an Action_Request.
         * @implements IAction_Request
         * @constructor
         * @param {Protocol.IAction_Request=} [properties] Properties to set
         */
        function Action_Request(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Action_Request roomId.
         * @member {string} roomId
         * @memberof Protocol.Action_Request
         * @instance
         */
        Action_Request.prototype.roomId = "";

        /**
         * Action_Request actionArray.
         * @member {Uint8Array} actionArray
         * @memberof Protocol.Action_Request
         * @instance
         */
        Action_Request.prototype.actionArray = $util.newBuffer([]);

        /**
         * Creates a new Action_Request instance using the specified properties.
         * @function create
         * @memberof Protocol.Action_Request
         * @static
         * @param {Protocol.IAction_Request=} [properties] Properties to set
         * @returns {Protocol.Action_Request} Action_Request instance
         */
        Action_Request.create = function create(properties) {
            return new Action_Request(properties);
        };

        /**
         * Encodes the specified Action_Request message. Does not implicitly {@link Protocol.Action_Request.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Action_Request
         * @static
         * @param {Protocol.IAction_Request} message Action_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Action_Request.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.roomId);
            if (message.actionArray != null && message.hasOwnProperty("actionArray"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.actionArray);
            return writer;
        };

        /**
         * Encodes the specified Action_Request message, length delimited. Does not implicitly {@link Protocol.Action_Request.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Action_Request
         * @static
         * @param {Protocol.IAction_Request} message Action_Request message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Action_Request.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Action_Request message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Action_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Action_Request} Action_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Action_Request.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Action_Request();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roomId = reader.string();
                    break;
                case 2:
                    message.actionArray = reader.bytes();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Action_Request message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Action_Request
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Action_Request} Action_Request
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Action_Request.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Action_Request message.
         * @function verify
         * @memberof Protocol.Action_Request
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Action_Request.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roomId != null && message.hasOwnProperty("roomId"))
                if (!$util.isString(message.roomId))
                    return "roomId: string expected";
            if (message.actionArray != null && message.hasOwnProperty("actionArray"))
                if (!(message.actionArray && typeof message.actionArray.length === "number" || $util.isString(message.actionArray)))
                    return "actionArray: buffer expected";
            return null;
        };

        return Action_Request;
    })();

    Protocol.Action_Response = (function() {

        /**
         * Properties of an Action_Response.
         * @memberof Protocol
         * @interface IAction_Response
         * @property {number|null} [frame] Action_Response frame
         * @property {Array.<Uint8Array>|null} [actionArray] Action_Response actionArray
         */

        /**
         * Constructs a new Action_Response.
         * @memberof Protocol
         * @classdesc Represents an Action_Response.
         * @implements IAction_Response
         * @constructor
         * @param {Protocol.IAction_Response=} [properties] Properties to set
         */
        function Action_Response(properties) {
            this.actionArray = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Action_Response frame.
         * @member {number} frame
         * @memberof Protocol.Action_Response
         * @instance
         */
        Action_Response.prototype.frame = 0;

        /**
         * Action_Response actionArray.
         * @member {Array.<Uint8Array>} actionArray
         * @memberof Protocol.Action_Response
         * @instance
         */
        Action_Response.prototype.actionArray = $util.emptyArray;

        /**
         * Creates a new Action_Response instance using the specified properties.
         * @function create
         * @memberof Protocol.Action_Response
         * @static
         * @param {Protocol.IAction_Response=} [properties] Properties to set
         * @returns {Protocol.Action_Response} Action_Response instance
         */
        Action_Response.create = function create(properties) {
            return new Action_Response(properties);
        };

        /**
         * Encodes the specified Action_Response message. Does not implicitly {@link Protocol.Action_Response.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Action_Response
         * @static
         * @param {Protocol.IAction_Response} message Action_Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Action_Response.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.frame != null && message.hasOwnProperty("frame"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.frame);
            if (message.actionArray != null && message.actionArray.length)
                for (var i = 0; i < message.actionArray.length; ++i)
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.actionArray[i]);
            return writer;
        };

        /**
         * Encodes the specified Action_Response message, length delimited. Does not implicitly {@link Protocol.Action_Response.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Action_Response
         * @static
         * @param {Protocol.IAction_Response} message Action_Response message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Action_Response.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Action_Response message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Action_Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Action_Response} Action_Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Action_Response.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Action_Response();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.frame = reader.int32();
                    break;
                case 2:
                    if (!(message.actionArray && message.actionArray.length))
                        message.actionArray = [];
                    message.actionArray.push(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Action_Response message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Action_Response
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Action_Response} Action_Response
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Action_Response.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Action_Response message.
         * @function verify
         * @memberof Protocol.Action_Response
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Action_Response.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.frame != null && message.hasOwnProperty("frame"))
                if (!$util.isInteger(message.frame))
                    return "frame: integer expected";
            if (message.actionArray != null && message.hasOwnProperty("actionArray")) {
                if (!Array.isArray(message.actionArray))
                    return "actionArray: array expected";
                for (var i = 0; i < message.actionArray.length; ++i)
                    if (!(message.actionArray[i] && typeof message.actionArray[i].length === "number" || $util.isString(message.actionArray[i])))
                        return "actionArray: buffer[] expected";
            }
            return null;
        };

        return Action_Response;
    })();

    Protocol.SimpleRecord = (function() {

        /**
         * Properties of a SimpleRecord.
         * @memberof Protocol
         * @interface ISimpleRecord
         * @property {number|null} [index] SimpleRecord index
         * @property {string|null} [srcName] SimpleRecord srcName
         * @property {number|null} [srcRolePic] SimpleRecord srcRolePic
         * @property {string|null} [srcFamilyName] SimpleRecord srcFamilyName
         * @property {string|null} [decName] SimpleRecord decName
         * @property {number|null} [decRolePic] SimpleRecord decRolePic
         * @property {string|null} [decFamilyName] SimpleRecord decFamilyName
         * @property {number|null} [winSide] SimpleRecord winSide
         * @property {Array.<Protocol.ISimpleHero>|null} [srcHeros] SimpleRecord srcHeros
         * @property {Array.<Protocol.ISimpleHero>|null} [decHeros] SimpleRecord decHeros
         * @property {number|Long|null} [srcRoleId] SimpleRecord srcRoleId
         * @property {number|Long|null} [decRoleId] SimpleRecord decRoleId
         * @property {number|Long|null} [time] SimpleRecord time
         * @property {Array.<number|Long>|null} [winIds] SimpleRecord winIds
         */

        /**
         * Constructs a new SimpleRecord.
         * @memberof Protocol
         * @classdesc Represents a SimpleRecord.
         * @implements ISimpleRecord
         * @constructor
         * @param {Protocol.ISimpleRecord=} [properties] Properties to set
         */
        function SimpleRecord(properties) {
            this.srcHeros = [];
            this.decHeros = [];
            this.winIds = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimpleRecord index.
         * @member {number} index
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.index = 0;

        /**
         * SimpleRecord srcName.
         * @member {string} srcName
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.srcName = "";

        /**
         * SimpleRecord srcRolePic.
         * @member {number} srcRolePic
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.srcRolePic = 0;

        /**
         * SimpleRecord srcFamilyName.
         * @member {string} srcFamilyName
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.srcFamilyName = "";

        /**
         * SimpleRecord decName.
         * @member {string} decName
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.decName = "";

        /**
         * SimpleRecord decRolePic.
         * @member {number} decRolePic
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.decRolePic = 0;

        /**
         * SimpleRecord decFamilyName.
         * @member {string} decFamilyName
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.decFamilyName = "";

        /**
         * SimpleRecord winSide.
         * @member {number} winSide
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.winSide = 0;

        /**
         * SimpleRecord srcHeros.
         * @member {Array.<Protocol.ISimpleHero>} srcHeros
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.srcHeros = $util.emptyArray;

        /**
         * SimpleRecord decHeros.
         * @member {Array.<Protocol.ISimpleHero>} decHeros
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.decHeros = $util.emptyArray;

        /**
         * SimpleRecord srcRoleId.
         * @member {number|Long} srcRoleId
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.srcRoleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SimpleRecord decRoleId.
         * @member {number|Long} decRoleId
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.decRoleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SimpleRecord time.
         * @member {number|Long} time
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SimpleRecord winIds.
         * @member {Array.<number|Long>} winIds
         * @memberof Protocol.SimpleRecord
         * @instance
         */
        SimpleRecord.prototype.winIds = $util.emptyArray;

        /**
         * Creates a new SimpleRecord instance using the specified properties.
         * @function create
         * @memberof Protocol.SimpleRecord
         * @static
         * @param {Protocol.ISimpleRecord=} [properties] Properties to set
         * @returns {Protocol.SimpleRecord} SimpleRecord instance
         */
        SimpleRecord.create = function create(properties) {
            return new SimpleRecord(properties);
        };

        /**
         * Encodes the specified SimpleRecord message. Does not implicitly {@link Protocol.SimpleRecord.verify|verify} messages.
         * @function encode
         * @memberof Protocol.SimpleRecord
         * @static
         * @param {Protocol.ISimpleRecord} message SimpleRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.srcName != null && message.hasOwnProperty("srcName"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.srcName);
            if (message.srcRolePic != null && message.hasOwnProperty("srcRolePic"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.srcRolePic);
            if (message.srcFamilyName != null && message.hasOwnProperty("srcFamilyName"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.srcFamilyName);
            if (message.decName != null && message.hasOwnProperty("decName"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.decName);
            if (message.decRolePic != null && message.hasOwnProperty("decRolePic"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.decRolePic);
            if (message.decFamilyName != null && message.hasOwnProperty("decFamilyName"))
                writer.uint32(/* id 7, wireType 2 =*/58).string(message.decFamilyName);
            if (message.winSide != null && message.hasOwnProperty("winSide"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.winSide);
            if (message.srcHeros != null && message.srcHeros.length)
                for (var i = 0; i < message.srcHeros.length; ++i)
                    $root.Protocol.SimpleHero.encode(message.srcHeros[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.decHeros != null && message.decHeros.length)
                for (var i = 0; i < message.decHeros.length; ++i)
                    $root.Protocol.SimpleHero.encode(message.decHeros[i], writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.srcRoleId != null && message.hasOwnProperty("srcRoleId"))
                writer.uint32(/* id 11, wireType 0 =*/88).int64(message.srcRoleId);
            if (message.decRoleId != null && message.hasOwnProperty("decRoleId"))
                writer.uint32(/* id 12, wireType 0 =*/96).int64(message.decRoleId);
            if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(/* id 13, wireType 0 =*/104).int64(message.time);
            if (message.winIds != null && message.winIds.length) {
                writer.uint32(/* id 14, wireType 2 =*/114).fork();
                for (var i = 0; i < message.winIds.length; ++i)
                    writer.int64(message.winIds[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified SimpleRecord message, length delimited. Does not implicitly {@link Protocol.SimpleRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.SimpleRecord
         * @static
         * @param {Protocol.ISimpleRecord} message SimpleRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimpleRecord message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.SimpleRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.SimpleRecord} SimpleRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.SimpleRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    message.srcName = reader.string();
                    break;
                case 3:
                    message.srcRolePic = reader.int32();
                    break;
                case 4:
                    message.srcFamilyName = reader.string();
                    break;
                case 5:
                    message.decName = reader.string();
                    break;
                case 6:
                    message.decRolePic = reader.int32();
                    break;
                case 7:
                    message.decFamilyName = reader.string();
                    break;
                case 8:
                    message.winSide = reader.int32();
                    break;
                case 9:
                    if (!(message.srcHeros && message.srcHeros.length))
                        message.srcHeros = [];
                    message.srcHeros.push($root.Protocol.SimpleHero.decode(reader, reader.uint32()));
                    break;
                case 10:
                    if (!(message.decHeros && message.decHeros.length))
                        message.decHeros = [];
                    message.decHeros.push($root.Protocol.SimpleHero.decode(reader, reader.uint32()));
                    break;
                case 11:
                    message.srcRoleId = reader.int64();
                    break;
                case 12:
                    message.decRoleId = reader.int64();
                    break;
                case 13:
                    message.time = reader.int64();
                    break;
                case 14:
                    if (!(message.winIds && message.winIds.length))
                        message.winIds = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.winIds.push(reader.int64());
                    } else
                        message.winIds.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimpleRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.SimpleRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.SimpleRecord} SimpleRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimpleRecord message.
         * @function verify
         * @memberof Protocol.SimpleRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimpleRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.srcName != null && message.hasOwnProperty("srcName"))
                if (!$util.isString(message.srcName))
                    return "srcName: string expected";
            if (message.srcRolePic != null && message.hasOwnProperty("srcRolePic"))
                if (!$util.isInteger(message.srcRolePic))
                    return "srcRolePic: integer expected";
            if (message.srcFamilyName != null && message.hasOwnProperty("srcFamilyName"))
                if (!$util.isString(message.srcFamilyName))
                    return "srcFamilyName: string expected";
            if (message.decName != null && message.hasOwnProperty("decName"))
                if (!$util.isString(message.decName))
                    return "decName: string expected";
            if (message.decRolePic != null && message.hasOwnProperty("decRolePic"))
                if (!$util.isInteger(message.decRolePic))
                    return "decRolePic: integer expected";
            if (message.decFamilyName != null && message.hasOwnProperty("decFamilyName"))
                if (!$util.isString(message.decFamilyName))
                    return "decFamilyName: string expected";
            if (message.winSide != null && message.hasOwnProperty("winSide"))
                if (!$util.isInteger(message.winSide))
                    return "winSide: integer expected";
            if (message.srcHeros != null && message.hasOwnProperty("srcHeros")) {
                if (!Array.isArray(message.srcHeros))
                    return "srcHeros: array expected";
                for (var i = 0; i < message.srcHeros.length; ++i) {
                    var error = $root.Protocol.SimpleHero.verify(message.srcHeros[i]);
                    if (error)
                        return "srcHeros." + error;
                }
            }
            if (message.decHeros != null && message.hasOwnProperty("decHeros")) {
                if (!Array.isArray(message.decHeros))
                    return "decHeros: array expected";
                for (var i = 0; i < message.decHeros.length; ++i) {
                    var error = $root.Protocol.SimpleHero.verify(message.decHeros[i]);
                    if (error)
                        return "decHeros." + error;
                }
            }
            if (message.srcRoleId != null && message.hasOwnProperty("srcRoleId"))
                if (!$util.isInteger(message.srcRoleId) && !(message.srcRoleId && $util.isInteger(message.srcRoleId.low) && $util.isInteger(message.srcRoleId.high)))
                    return "srcRoleId: integer|Long expected";
            if (message.decRoleId != null && message.hasOwnProperty("decRoleId"))
                if (!$util.isInteger(message.decRoleId) && !(message.decRoleId && $util.isInteger(message.decRoleId.low) && $util.isInteger(message.decRoleId.high)))
                    return "decRoleId: integer|Long expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.winIds != null && message.hasOwnProperty("winIds")) {
                if (!Array.isArray(message.winIds))
                    return "winIds: array expected";
                for (var i = 0; i < message.winIds.length; ++i)
                    if (!$util.isInteger(message.winIds[i]) && !(message.winIds[i] && $util.isInteger(message.winIds[i].low) && $util.isInteger(message.winIds[i].high)))
                        return "winIds: integer|Long[] expected";
            }
            return null;
        };

        return SimpleRecord;
    })();

    Protocol.FightRecord = (function() {

        /**
         * Properties of a FightRecord.
         * @memberof Protocol
         * @interface IFightRecord
         * @property {Protocol.IFightRoomInfo_Respond|null} [info] FightRecord info
         * @property {number|Long|null} [time] FightRecord time
         * @property {number|null} [seed] FightRecord seed
         * @property {number|null} [maxframe] FightRecord maxframe
         * @property {Array.<Protocol.IAction_Response>|null} [actions] FightRecord actions
         * @property {number|Long|null} [roleId] FightRecord roleId
         * @property {Array.<number|Long>|null} [winId] FightRecord winId
         */

        /**
         * Constructs a new FightRecord.
         * @memberof Protocol
         * @classdesc Represents a FightRecord.
         * @implements IFightRecord
         * @constructor
         * @param {Protocol.IFightRecord=} [properties] Properties to set
         */
        function FightRecord(properties) {
            this.actions = [];
            this.winId = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FightRecord info.
         * @member {Protocol.IFightRoomInfo_Respond|null|undefined} info
         * @memberof Protocol.FightRecord
         * @instance
         */
        FightRecord.prototype.info = null;

        /**
         * FightRecord time.
         * @member {number|Long} time
         * @memberof Protocol.FightRecord
         * @instance
         */
        FightRecord.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FightRecord seed.
         * @member {number} seed
         * @memberof Protocol.FightRecord
         * @instance
         */
        FightRecord.prototype.seed = 0;

        /**
         * FightRecord maxframe.
         * @member {number} maxframe
         * @memberof Protocol.FightRecord
         * @instance
         */
        FightRecord.prototype.maxframe = 0;

        /**
         * FightRecord actions.
         * @member {Array.<Protocol.IAction_Response>} actions
         * @memberof Protocol.FightRecord
         * @instance
         */
        FightRecord.prototype.actions = $util.emptyArray;

        /**
         * FightRecord roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.FightRecord
         * @instance
         */
        FightRecord.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * FightRecord winId.
         * @member {Array.<number|Long>} winId
         * @memberof Protocol.FightRecord
         * @instance
         */
        FightRecord.prototype.winId = $util.emptyArray;

        /**
         * Creates a new FightRecord instance using the specified properties.
         * @function create
         * @memberof Protocol.FightRecord
         * @static
         * @param {Protocol.IFightRecord=} [properties] Properties to set
         * @returns {Protocol.FightRecord} FightRecord instance
         */
        FightRecord.create = function create(properties) {
            return new FightRecord(properties);
        };

        /**
         * Encodes the specified FightRecord message. Does not implicitly {@link Protocol.FightRecord.verify|verify} messages.
         * @function encode
         * @memberof Protocol.FightRecord
         * @static
         * @param {Protocol.IFightRecord} message FightRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightRecord.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.info != null && message.hasOwnProperty("info"))
                $root.Protocol.FightRoomInfo_Respond.encode(message.info, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.time);
            if (message.seed != null && message.hasOwnProperty("seed"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.seed);
            if (message.maxframe != null && message.hasOwnProperty("maxframe"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.maxframe);
            if (message.actions != null && message.actions.length)
                for (var i = 0; i < message.actions.length; ++i)
                    $root.Protocol.Action_Response.encode(message.actions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 6, wireType 0 =*/48).int64(message.roleId);
            if (message.winId != null && message.winId.length) {
                writer.uint32(/* id 7, wireType 2 =*/58).fork();
                for (var i = 0; i < message.winId.length; ++i)
                    writer.int64(message.winId[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified FightRecord message, length delimited. Does not implicitly {@link Protocol.FightRecord.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.FightRecord
         * @static
         * @param {Protocol.IFightRecord} message FightRecord message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FightRecord.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FightRecord message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.FightRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.FightRecord} FightRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightRecord.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.FightRecord();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.info = $root.Protocol.FightRoomInfo_Respond.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.time = reader.int64();
                    break;
                case 3:
                    message.seed = reader.int32();
                    break;
                case 4:
                    message.maxframe = reader.int32();
                    break;
                case 5:
                    if (!(message.actions && message.actions.length))
                        message.actions = [];
                    message.actions.push($root.Protocol.Action_Response.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.roleId = reader.int64();
                    break;
                case 7:
                    if (!(message.winId && message.winId.length))
                        message.winId = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.winId.push(reader.int64());
                    } else
                        message.winId.push(reader.int64());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FightRecord message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.FightRecord
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.FightRecord} FightRecord
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FightRecord.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FightRecord message.
         * @function verify
         * @memberof Protocol.FightRecord
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FightRecord.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.info != null && message.hasOwnProperty("info")) {
                var error = $root.Protocol.FightRoomInfo_Respond.verify(message.info);
                if (error)
                    return "info." + error;
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.seed != null && message.hasOwnProperty("seed"))
                if (!$util.isInteger(message.seed))
                    return "seed: integer expected";
            if (message.maxframe != null && message.hasOwnProperty("maxframe"))
                if (!$util.isInteger(message.maxframe))
                    return "maxframe: integer expected";
            if (message.actions != null && message.hasOwnProperty("actions")) {
                if (!Array.isArray(message.actions))
                    return "actions: array expected";
                for (var i = 0; i < message.actions.length; ++i) {
                    var error = $root.Protocol.Action_Response.verify(message.actions[i]);
                    if (error)
                        return "actions." + error;
                }
            }
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.winId != null && message.hasOwnProperty("winId")) {
                if (!Array.isArray(message.winId))
                    return "winId: array expected";
                for (var i = 0; i < message.winId.length; ++i)
                    if (!$util.isInteger(message.winId[i]) && !(message.winId[i] && $util.isInteger(message.winId[i].low) && $util.isInteger(message.winId[i].high)))
                        return "winId: integer|Long[] expected";
            }
            return null;
        };

        return FightRecord;
    })();

    Protocol.Mail = (function() {

        /**
         * Properties of a Mail.
         * @memberof Protocol
         * @interface IMail
         * @property {string|null} [header] Mail header
         * @property {string|null} [content] Mail content
         * @property {Array.<Protocol.IReward>|null} [rewards] Mail rewards
         * @property {number|Long|null} [time] Mail time
         * @property {string|null} [id] Mail id
         * @property {boolean|null} [hasGet] Mail hasGet
         * @property {boolean|null} [hasRead] Mail hasRead
         * @property {number|null} [type] Mail type
         */

        /**
         * Constructs a new Mail.
         * @memberof Protocol
         * @classdesc Represents a Mail.
         * @implements IMail
         * @constructor
         * @param {Protocol.IMail=} [properties] Properties to set
         */
        function Mail(properties) {
            this.rewards = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Mail header.
         * @member {string} header
         * @memberof Protocol.Mail
         * @instance
         */
        Mail.prototype.header = "";

        /**
         * Mail content.
         * @member {string} content
         * @memberof Protocol.Mail
         * @instance
         */
        Mail.prototype.content = "";

        /**
         * Mail rewards.
         * @member {Array.<Protocol.IReward>} rewards
         * @memberof Protocol.Mail
         * @instance
         */
        Mail.prototype.rewards = $util.emptyArray;

        /**
         * Mail time.
         * @member {number|Long} time
         * @memberof Protocol.Mail
         * @instance
         */
        Mail.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Mail id.
         * @member {string} id
         * @memberof Protocol.Mail
         * @instance
         */
        Mail.prototype.id = "";

        /**
         * Mail hasGet.
         * @member {boolean} hasGet
         * @memberof Protocol.Mail
         * @instance
         */
        Mail.prototype.hasGet = false;

        /**
         * Mail hasRead.
         * @member {boolean} hasRead
         * @memberof Protocol.Mail
         * @instance
         */
        Mail.prototype.hasRead = false;

        /**
         * Mail type.
         * @member {number} type
         * @memberof Protocol.Mail
         * @instance
         */
        Mail.prototype.type = 0;

        /**
         * Creates a new Mail instance using the specified properties.
         * @function create
         * @memberof Protocol.Mail
         * @static
         * @param {Protocol.IMail=} [properties] Properties to set
         * @returns {Protocol.Mail} Mail instance
         */
        Mail.create = function create(properties) {
            return new Mail(properties);
        };

        /**
         * Encodes the specified Mail message. Does not implicitly {@link Protocol.Mail.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Mail
         * @static
         * @param {Protocol.IMail} message Mail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mail.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.header != null && message.hasOwnProperty("header"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.header);
            if (message.content != null && message.hasOwnProperty("content"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.content);
            if (message.rewards != null && message.rewards.length)
                for (var i = 0; i < message.rewards.length; ++i)
                    $root.Protocol.Reward.encode(message.rewards[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(/* id 4, wireType 0 =*/32).int64(message.time);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.id);
            if (message.hasGet != null && message.hasOwnProperty("hasGet"))
                writer.uint32(/* id 6, wireType 0 =*/48).bool(message.hasGet);
            if (message.hasRead != null && message.hasOwnProperty("hasRead"))
                writer.uint32(/* id 7, wireType 0 =*/56).bool(message.hasRead);
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.type);
            return writer;
        };

        /**
         * Encodes the specified Mail message, length delimited. Does not implicitly {@link Protocol.Mail.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Mail
         * @static
         * @param {Protocol.IMail} message Mail message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Mail.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Mail message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Mail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Mail} Mail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mail.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Mail();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.header = reader.string();
                    break;
                case 2:
                    message.content = reader.string();
                    break;
                case 3:
                    if (!(message.rewards && message.rewards.length))
                        message.rewards = [];
                    message.rewards.push($root.Protocol.Reward.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.time = reader.int64();
                    break;
                case 5:
                    message.id = reader.string();
                    break;
                case 6:
                    message.hasGet = reader.bool();
                    break;
                case 7:
                    message.hasRead = reader.bool();
                    break;
                case 8:
                    message.type = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Mail message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Mail
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Mail} Mail
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Mail.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Mail message.
         * @function verify
         * @memberof Protocol.Mail
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Mail.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.header != null && message.hasOwnProperty("header"))
                if (!$util.isString(message.header))
                    return "header: string expected";
            if (message.content != null && message.hasOwnProperty("content"))
                if (!$util.isString(message.content))
                    return "content: string expected";
            if (message.rewards != null && message.hasOwnProperty("rewards")) {
                if (!Array.isArray(message.rewards))
                    return "rewards: array expected";
                for (var i = 0; i < message.rewards.length; ++i) {
                    var error = $root.Protocol.Reward.verify(message.rewards[i]);
                    if (error)
                        return "rewards." + error;
                }
            }
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.hasGet != null && message.hasOwnProperty("hasGet"))
                if (typeof message.hasGet !== "boolean")
                    return "hasGet: boolean expected";
            if (message.hasRead != null && message.hasOwnProperty("hasRead"))
                if (typeof message.hasRead !== "boolean")
                    return "hasRead: boolean expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            return null;
        };

        return Mail;
    })();

    Protocol.Box = (function() {

        /**
         * Properties of a Box.
         * @memberof Protocol
         * @interface IBox
         * @property {string|null} [id] Box id
         * @property {number|Long|null} [time] Box time
         * @property {number|null} [index] Box index
         * @property {number|null} [state] Box state
         */

        /**
         * Constructs a new Box.
         * @memberof Protocol
         * @classdesc Represents a Box.
         * @implements IBox
         * @constructor
         * @param {Protocol.IBox=} [properties] Properties to set
         */
        function Box(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Box id.
         * @member {string} id
         * @memberof Protocol.Box
         * @instance
         */
        Box.prototype.id = "";

        /**
         * Box time.
         * @member {number|Long} time
         * @memberof Protocol.Box
         * @instance
         */
        Box.prototype.time = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Box index.
         * @member {number} index
         * @memberof Protocol.Box
         * @instance
         */
        Box.prototype.index = 0;

        /**
         * Box state.
         * @member {number} state
         * @memberof Protocol.Box
         * @instance
         */
        Box.prototype.state = 0;

        /**
         * Creates a new Box instance using the specified properties.
         * @function create
         * @memberof Protocol.Box
         * @static
         * @param {Protocol.IBox=} [properties] Properties to set
         * @returns {Protocol.Box} Box instance
         */
        Box.create = function create(properties) {
            return new Box(properties);
        };

        /**
         * Encodes the specified Box message. Does not implicitly {@link Protocol.Box.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Box
         * @static
         * @param {Protocol.IBox} message Box message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Box.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.time != null && message.hasOwnProperty("time"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.time);
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.index);
            if (message.state != null && message.hasOwnProperty("state"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.state);
            return writer;
        };

        /**
         * Encodes the specified Box message, length delimited. Does not implicitly {@link Protocol.Box.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Box
         * @static
         * @param {Protocol.IBox} message Box message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Box.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Box message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Box
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Box} Box
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Box.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Box();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.id = reader.string();
                    break;
                case 2:
                    message.time = reader.int64();
                    break;
                case 3:
                    message.index = reader.int32();
                    break;
                case 4:
                    message.state = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Box message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Box
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Box} Box
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Box.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Box message.
         * @function verify
         * @memberof Protocol.Box
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Box.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.time != null && message.hasOwnProperty("time"))
                if (!$util.isInteger(message.time) && !(message.time && $util.isInteger(message.time.low) && $util.isInteger(message.time.high)))
                    return "time: integer|Long expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.state != null && message.hasOwnProperty("state"))
                if (!$util.isInteger(message.state))
                    return "state: integer expected";
            return null;
        };

        return Box;
    })();

    Protocol.CupsInfo = (function() {

        /**
         * Properties of a CupsInfo.
         * @memberof Protocol
         * @interface ICupsInfo
         * @property {number|Long|null} [roleId] CupsInfo roleId
         * @property {number|null} [cups] CupsInfo cups
         */

        /**
         * Constructs a new CupsInfo.
         * @memberof Protocol
         * @classdesc Represents a CupsInfo.
         * @implements ICupsInfo
         * @constructor
         * @param {Protocol.ICupsInfo=} [properties] Properties to set
         */
        function CupsInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CupsInfo roleId.
         * @member {number|Long} roleId
         * @memberof Protocol.CupsInfo
         * @instance
         */
        CupsInfo.prototype.roleId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * CupsInfo cups.
         * @member {number} cups
         * @memberof Protocol.CupsInfo
         * @instance
         */
        CupsInfo.prototype.cups = 0;

        /**
         * Creates a new CupsInfo instance using the specified properties.
         * @function create
         * @memberof Protocol.CupsInfo
         * @static
         * @param {Protocol.ICupsInfo=} [properties] Properties to set
         * @returns {Protocol.CupsInfo} CupsInfo instance
         */
        CupsInfo.create = function create(properties) {
            return new CupsInfo(properties);
        };

        /**
         * Encodes the specified CupsInfo message. Does not implicitly {@link Protocol.CupsInfo.verify|verify} messages.
         * @function encode
         * @memberof Protocol.CupsInfo
         * @static
         * @param {Protocol.ICupsInfo} message CupsInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CupsInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.roleId);
            if (message.cups != null && message.hasOwnProperty("cups"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.cups);
            return writer;
        };

        /**
         * Encodes the specified CupsInfo message, length delimited. Does not implicitly {@link Protocol.CupsInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.CupsInfo
         * @static
         * @param {Protocol.ICupsInfo} message CupsInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CupsInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CupsInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.CupsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.CupsInfo} CupsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CupsInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.CupsInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.roleId = reader.int64();
                    break;
                case 2:
                    message.cups = reader.int32();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CupsInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.CupsInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.CupsInfo} CupsInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CupsInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CupsInfo message.
         * @function verify
         * @memberof Protocol.CupsInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CupsInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.roleId != null && message.hasOwnProperty("roleId"))
                if (!$util.isInteger(message.roleId) && !(message.roleId && $util.isInteger(message.roleId.low) && $util.isInteger(message.roleId.high)))
                    return "roleId: integer|Long expected";
            if (message.cups != null && message.hasOwnProperty("cups"))
                if (!$util.isInteger(message.cups))
                    return "cups: integer expected";
            return null;
        };

        return CupsInfo;
    })();

    Protocol.WarGodGettedInfo = (function() {

        /**
         * Properties of a WarGodGettedInfo.
         * @memberof Protocol
         * @interface IWarGodGettedInfo
         * @property {number|null} [index] WarGodGettedInfo index
         * @property {Array.<boolean>|null} [gets] WarGodGettedInfo gets
         */

        /**
         * Constructs a new WarGodGettedInfo.
         * @memberof Protocol
         * @classdesc Represents a WarGodGettedInfo.
         * @implements IWarGodGettedInfo
         * @constructor
         * @param {Protocol.IWarGodGettedInfo=} [properties] Properties to set
         */
        function WarGodGettedInfo(properties) {
            this.gets = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * WarGodGettedInfo index.
         * @member {number} index
         * @memberof Protocol.WarGodGettedInfo
         * @instance
         */
        WarGodGettedInfo.prototype.index = 0;

        /**
         * WarGodGettedInfo gets.
         * @member {Array.<boolean>} gets
         * @memberof Protocol.WarGodGettedInfo
         * @instance
         */
        WarGodGettedInfo.prototype.gets = $util.emptyArray;

        /**
         * Creates a new WarGodGettedInfo instance using the specified properties.
         * @function create
         * @memberof Protocol.WarGodGettedInfo
         * @static
         * @param {Protocol.IWarGodGettedInfo=} [properties] Properties to set
         * @returns {Protocol.WarGodGettedInfo} WarGodGettedInfo instance
         */
        WarGodGettedInfo.create = function create(properties) {
            return new WarGodGettedInfo(properties);
        };

        /**
         * Encodes the specified WarGodGettedInfo message. Does not implicitly {@link Protocol.WarGodGettedInfo.verify|verify} messages.
         * @function encode
         * @memberof Protocol.WarGodGettedInfo
         * @static
         * @param {Protocol.IWarGodGettedInfo} message WarGodGettedInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarGodGettedInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.index != null && message.hasOwnProperty("index"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.index);
            if (message.gets != null && message.gets.length) {
                writer.uint32(/* id 2, wireType 2 =*/18).fork();
                for (var i = 0; i < message.gets.length; ++i)
                    writer.bool(message.gets[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified WarGodGettedInfo message, length delimited. Does not implicitly {@link Protocol.WarGodGettedInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.WarGodGettedInfo
         * @static
         * @param {Protocol.IWarGodGettedInfo} message WarGodGettedInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        WarGodGettedInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a WarGodGettedInfo message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.WarGodGettedInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.WarGodGettedInfo} WarGodGettedInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarGodGettedInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.WarGodGettedInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.index = reader.int32();
                    break;
                case 2:
                    if (!(message.gets && message.gets.length))
                        message.gets = [];
                    if ((tag & 7) === 2) {
                        var end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2)
                            message.gets.push(reader.bool());
                    } else
                        message.gets.push(reader.bool());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a WarGodGettedInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.WarGodGettedInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.WarGodGettedInfo} WarGodGettedInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        WarGodGettedInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a WarGodGettedInfo message.
         * @function verify
         * @memberof Protocol.WarGodGettedInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        WarGodGettedInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.index != null && message.hasOwnProperty("index"))
                if (!$util.isInteger(message.index))
                    return "index: integer expected";
            if (message.gets != null && message.hasOwnProperty("gets")) {
                if (!Array.isArray(message.gets))
                    return "gets: array expected";
                for (var i = 0; i < message.gets.length; ++i)
                    if (typeof message.gets[i] !== "boolean")
                        return "gets: boolean[] expected";
            }
            return null;
        };

        return WarGodGettedInfo;
    })();

    Protocol.Gift = (function() {

        /**
         * Properties of a Gift.
         * @memberof Protocol
         * @interface IGift
         * @property {number|null} [type] Gift type
         * @property {number|null} [id] Gift id
         * @property {number|Long|null} [finishTime] Gift finishTime
         * @property {Array.<Protocol.IBuyInfo>|null} [infos] Gift infos
         */

        /**
         * Constructs a new Gift.
         * @memberof Protocol
         * @classdesc Represents a Gift.
         * @implements IGift
         * @constructor
         * @param {Protocol.IGift=} [properties] Properties to set
         */
        function Gift(properties) {
            this.infos = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Gift type.
         * @member {number} type
         * @memberof Protocol.Gift
         * @instance
         */
        Gift.prototype.type = 0;

        /**
         * Gift id.
         * @member {number} id
         * @memberof Protocol.Gift
         * @instance
         */
        Gift.prototype.id = 0;

        /**
         * Gift finishTime.
         * @member {number|Long} finishTime
         * @memberof Protocol.Gift
         * @instance
         */
        Gift.prototype.finishTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Gift infos.
         * @member {Array.<Protocol.IBuyInfo>} infos
         * @memberof Protocol.Gift
         * @instance
         */
        Gift.prototype.infos = $util.emptyArray;

        /**
         * Creates a new Gift instance using the specified properties.
         * @function create
         * @memberof Protocol.Gift
         * @static
         * @param {Protocol.IGift=} [properties] Properties to set
         * @returns {Protocol.Gift} Gift instance
         */
        Gift.create = function create(properties) {
            return new Gift(properties);
        };

        /**
         * Encodes the specified Gift message. Does not implicitly {@link Protocol.Gift.verify|verify} messages.
         * @function encode
         * @memberof Protocol.Gift
         * @static
         * @param {Protocol.IGift} message Gift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Gift.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && message.hasOwnProperty("type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.id != null && message.hasOwnProperty("id"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.id);
            if (message.finishTime != null && message.hasOwnProperty("finishTime"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.finishTime);
            if (message.infos != null && message.infos.length)
                for (var i = 0; i < message.infos.length; ++i)
                    $root.Protocol.BuyInfo.encode(message.infos[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Gift message, length delimited. Does not implicitly {@link Protocol.Gift.verify|verify} messages.
         * @function encodeDelimited
         * @memberof Protocol.Gift
         * @static
         * @param {Protocol.IGift} message Gift message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Gift.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Gift message from the specified reader or buffer.
         * @function decode
         * @memberof Protocol.Gift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {Protocol.Gift} Gift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Gift.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.Protocol.Gift();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1:
                    message.type = reader.int32();
                    break;
                case 2:
                    message.id = reader.int32();
                    break;
                case 3:
                    message.finishTime = reader.int64();
                    break;
                case 4:
                    if (!(message.infos && message.infos.length))
                        message.infos = [];
                    message.infos.push($root.Protocol.BuyInfo.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Gift message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof Protocol.Gift
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {Protocol.Gift} Gift
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Gift.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Gift message.
         * @function verify
         * @memberof Protocol.Gift
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Gift.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                if (!$util.isInteger(message.type))
                    return "type: integer expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id))
                    return "id: integer expected";
            if (message.finishTime != null && message.hasOwnProperty("finishTime"))
                if (!$util.isInteger(message.finishTime) && !(message.finishTime && $util.isInteger(message.finishTime.low) && $util.isInteger(message.finishTime.high)))
                    return "finishTime: integer|Long expected";
            if (message.infos != null && message.hasOwnProperty("infos")) {
                if (!Array.isArray(message.infos))
                    return "infos: array expected";
                for (var i = 0; i < message.infos.length; ++i) {
                    var error = $root.Protocol.BuyInfo.verify(message.infos[i]);
                    if (error)
                        return "infos." + error;
                }
            }
            return null;
        };

        return Gift;
    })();

    /**
     * PropertyEnum enum.
     * @name Protocol.PropertyEnum
     * @enum {string}
     * @property {number} NONE=0 NONE value
     * @property {number} EXP=1 EXP value
     * @property {number} MONEY=2 MONEY value
     * @property {number} DIAMOND=3 DIAMOND value
     * @property {number} CUPS=4 CUPS value
     * @property {number} LEVEL=5 LEVEL value
     * @property {number} TASKSCOPE=6 TASKSCOPE value
     * @property {number} CLASSLEVEL=7 CLASSLEVEL value
     * @property {number} FAMILYSCOPE=8 FAMILYSCOPE value
     * @property {number} GRADE=9 GRADE value
     * @property {number} STAR=10 STAR value
     * @property {number} KEY=11 KEY value
     * @property {number} FRESH_TASK_TIME=12 FRESH_TASK_TIME value
     * @property {number} TASKSCOPE_MAX=13 TASKSCOPE_MAX value
     * @property {number} TASKSCOPE_BOX=14 TASKSCOPE_BOX value
     * @property {number} WAR_GOD_CUPS=15 WAR_GOD_CUPS value
     * @property {number} WAR_GOD_CODE=16 WAR_GOD_CODE value
     * @property {number} FIRST_RECHARGE=17 FIRST_RECHARGE value
     * @property {number} ROLE_PIC=18 ROLE_PIC value
     * @property {number} CHANGE_NAME=19 CHANGE_NAME value
     */
    Protocol.PropertyEnum = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "EXP"] = 1;
        values[valuesById[2] = "MONEY"] = 2;
        values[valuesById[3] = "DIAMOND"] = 3;
        values[valuesById[4] = "CUPS"] = 4;
        values[valuesById[5] = "LEVEL"] = 5;
        values[valuesById[6] = "TASKSCOPE"] = 6;
        values[valuesById[7] = "CLASSLEVEL"] = 7;
        values[valuesById[8] = "FAMILYSCOPE"] = 8;
        values[valuesById[9] = "GRADE"] = 9;
        values[valuesById[10] = "STAR"] = 10;
        values[valuesById[11] = "KEY"] = 11;
        values[valuesById[12] = "FRESH_TASK_TIME"] = 12;
        values[valuesById[13] = "TASKSCOPE_MAX"] = 13;
        values[valuesById[14] = "TASKSCOPE_BOX"] = 14;
        values[valuesById[15] = "WAR_GOD_CUPS"] = 15;
        values[valuesById[16] = "WAR_GOD_CODE"] = 16;
        values[valuesById[17] = "FIRST_RECHARGE"] = 17;
        values[valuesById[18] = "ROLE_PIC"] = 18;
        values[valuesById[19] = "CHANGE_NAME"] = 19;
        return values;
    })();

    /**
     * JobberEnum enum.
     * @name Protocol.JobberEnum
     * @enum {string}
     * @property {number} NOMEAN=0 NOMEAN value
     * @property {number} LEADER=1 LEADER value
     * @property {number} VICE=2 VICE value
     * @property {number} MEMBER=3 MEMBER value
     */
    Protocol.JobberEnum = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NOMEAN"] = 0;
        values[valuesById[1] = "LEADER"] = 1;
        values[valuesById[2] = "VICE"] = 2;
        values[valuesById[3] = "MEMBER"] = 3;
        return values;
    })();

    /**
     * ErrorEnum enum.
     * @name Protocol.ErrorEnum
     * @enum {string}
     * @property {number} INVALID=0 INVALID value
     * @property {number} NO_MONEY=1 NO_MONEY value
     * @property {number} NO_ITEM=2 NO_ITEM value
     * @property {number} NO_SKILL=3 NO_SKILL value
     * @property {number} NO_HERO_SKILL=4 NO_HERO_SKILL value
     * @property {number} NO_HERO=5 NO_HERO value
     * @property {number} NO_BANGGONG=6 NO_BANGGONG value
     * @property {number} NO_DAY_COUNT=7 NO_DAY_COUNT value
     * @property {number} NO_LIMIT_COUNT=8 NO_LIMIT_COUNT value
     * @property {number} NO_LIMIT_DATE=9 NO_LIMIT_DATE value
     * @property {number} FRIEND_MINE_FULL=100 FRIEND_MINE_FULL value
     * @property {number} FRIEND_TARGET_FULLL=101 FRIEND_TARGET_FULLL value
     * @property {number} FRIEND_OFFLINE=102 FRIEND_OFFLINE value
     * @property {number} HAS_FAMILY=203 HAS_FAMILY value
     */
    Protocol.ErrorEnum = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "INVALID"] = 0;
        values[valuesById[1] = "NO_MONEY"] = 1;
        values[valuesById[2] = "NO_ITEM"] = 2;
        values[valuesById[3] = "NO_SKILL"] = 3;
        values[valuesById[4] = "NO_HERO_SKILL"] = 4;
        values[valuesById[5] = "NO_HERO"] = 5;
        values[valuesById[6] = "NO_BANGGONG"] = 6;
        values[valuesById[7] = "NO_DAY_COUNT"] = 7;
        values[valuesById[8] = "NO_LIMIT_COUNT"] = 8;
        values[valuesById[9] = "NO_LIMIT_DATE"] = 9;
        values[valuesById[100] = "FRIEND_MINE_FULL"] = 100;
        values[valuesById[101] = "FRIEND_TARGET_FULLL"] = 101;
        values[valuesById[102] = "FRIEND_OFFLINE"] = 102;
        values[valuesById[203] = "HAS_FAMILY"] = 203;
        return values;
    })();

    /**
     * MessageID enum.
     * @name Protocol.MessageID
     * @enum {string}
     * @property {number} INVAILED=0 INVAILED value
     * @property {number} LOGIN_GAME_REQ=2 LOGIN_GAME_REQ value
     * @property {number} LOGIN_GAME_RES=3 LOGIN_GAME_RES value
     * @property {number} HEARBEAT_RES=101 HEARBEAT_RES value
     * @property {number} HEARBEAT_REQ=102 HEARBEAT_REQ value
     * @property {number} BEGIN_MATCH_REQ=104 BEGIN_MATCH_REQ value
     * @property {number} BEGIN_MATCH_RES=105 BEGIN_MATCH_RES value
     * @property {number} FIGHT_ROOM_INFO_RES=106 FIGHT_ROOM_INFO_RES value
     * @property {number} CANCLE_MATCH_REQ=107 CANCLE_MATCH_REQ value
     * @property {number} CANCLE_MATCH_RES=108 CANCLE_MATCH_RES value
     * @property {number} GM_COMMAND_REQ=109 GM_COMMAND_REQ value
     * @property {number} GM_COMMAND_RES=110 GM_COMMAND_RES value
     * @property {number} SET_LINEUP_REQ=111 SET_LINEUP_REQ value
     * @property {number} SET_LINEUP_RES=112 SET_LINEUP_RES value
     * @property {number} SET_FIGHT_LINEUP_REQ=113 SET_FIGHT_LINEUP_REQ value
     * @property {number} SET_FIGHT_LINEUP_RES=114 SET_FIGHT_LINEUP_RES value
     * @property {number} GET_RANK_RANGE_REQ=115 GET_RANK_RANGE_REQ value
     * @property {number} GET_RANK_RANGE_RES=116 GET_RANK_RANGE_RES value
     * @property {number} QUIT_WAR_REQ=117 QUIT_WAR_REQ value
     * @property {number} QUIT_WAR_RES=118 QUIT_WAR_RES value
     * @property {number} TASK_CHANGE_RES=119 TASK_CHANGE_RES value
     * @property {number} FINISH_TASK_REQ=120 FINISH_TASK_REQ value
     * @property {number} REFRESH_TASK_REQ=121 REFRESH_TASK_REQ value
     * @property {number} GET_LOGIC_TIME_REQ=122 GET_LOGIC_TIME_REQ value
     * @property {number} GET_LOGIC_TIME_RES=123 GET_LOGIC_TIME_RES value
     * @property {number} PROPERTY_CHANGE_RES=124 PROPERTY_CHANGE_RES value
     * @property {number} TASK_SCOPE_BOX_OPEN_REQ=125 TASK_SCOPE_BOX_OPEN_REQ value
     * @property {number} REWARD_RES=126 REWARD_RES value
     * @property {number} ITEM_CHANGE_RES=127 ITEM_CHANGE_RES value
     * @property {number} HERO_LEVEL_UP_REQ=128 HERO_LEVEL_UP_REQ value
     * @property {number} HERO_LEVEL_UP_RES=129 HERO_LEVEL_UP_RES value
     * @property {number} ERROR_NOTICE_RES=130 ERROR_NOTICE_RES value
     * @property {number} SKILL_LEVEL_UP_REQ=131 SKILL_LEVEL_UP_REQ value
     * @property {number} SKILL_LEVEL_UP_RES=132 SKILL_LEVEL_UP_RES value
     * @property {number} ADD_HERO_RES=133 ADD_HERO_RES value
     * @property {number} FRIEND_CHAT_REQ=134 FRIEND_CHAT_REQ value
     * @property {number} FRIEND_CHAT_RES=135 FRIEND_CHAT_RES value
     * @property {number} INVITE_FRIEND_REQ=136 INVITE_FRIEND_REQ value
     * @property {number} INVITE_FRIEND_RES=137 INVITE_FRIEND_RES value
     * @property {number} ACCEPT_FRIEND_REQ=139 ACCEPT_FRIEND_REQ value
     * @property {number} ADD_FRIEND_RES=140 ADD_FRIEND_RES value
     * @property {number} ASK_FRIEND_LIST_REQ=141 ASK_FRIEND_LIST_REQ value
     * @property {number} ASK_FRIEND_LIST_RES=142 ASK_FRIEND_LIST_RES value
     * @property {number} ALL_FRIENDS_REQ=143 ALL_FRIENDS_REQ value
     * @property {number} ALL_FRIENDS_RES=144 ALL_FRIENDS_RES value
     * @property {number} ALL_INVITES_REQ=145 ALL_INVITES_REQ value
     * @property {number} ALL_INVITES_RES=146 ALL_INVITES_RES value
     * @property {number} ALL_CHAT_REQ=147 ALL_CHAT_REQ value
     * @property {number} ALL_CHAT_RES=148 ALL_CHAT_RES value
     * @property {number} FRIEND_STATE_RES=149 FRIEND_STATE_RES value
     * @property {number} DELETE_INVITE_RES=150 DELETE_INVITE_RES value
     * @property {number} NOTICE_LAST_READ_TIME_REQ=151 NOTICE_LAST_READ_TIME_REQ value
     * @property {number} DELETE_FRINED_REQ=152 DELETE_FRINED_REQ value
     * @property {number} DELETE_FRIEND_RES=153 DELETE_FRIEND_RES value
     * @property {number} ASK_FAMILY_REQ=170 ASK_FAMILY_REQ value
     * @property {number} ASK_FAMILY_RES=171 ASK_FAMILY_RES value
     * @property {number} JOIN_FAMILY_REQ=172 JOIN_FAMILY_REQ value
     * @property {number} JOIN_FAMILY_RES=173 JOIN_FAMILY_RES value
     * @property {number} JOIN_FAMILY_SUCEED_RES=190 JOIN_FAMILY_SUCEED_RES value
     * @property {number} JOIN_FAMILY_APPLYS_REQ=191 JOIN_FAMILY_APPLYS_REQ value
     * @property {number} JOIN_FAMILY_APPLYS_RES=192 JOIN_FAMILY_APPLYS_RES value
     * @property {number} CREATE_FAMILY_REQ=174 CREATE_FAMILY_REQ value
     * @property {number} CREATE_FAMILY_RES=175 CREATE_FAMILY_RES value
     * @property {number} LEAVE_FAMILY_REQ=176 LEAVE_FAMILY_REQ value
     * @property {number} LEAVE_FAMILY_RES=177 LEAVE_FAMILY_RES value
     * @property {number} ASK_FAMILY_APPLY_REQ=178 ASK_FAMILY_APPLY_REQ value
     * @property {number} ASK_FAMILY_APPLY_RES=179 ASK_FAMILY_APPLY_RES value
     * @property {number} ACCEPT_FAMILY_APPLY_REQ=180 ACCEPT_FAMILY_APPLY_REQ value
     * @property {number} ACCEPT_FAMILY_APPLY_RES=196 ACCEPT_FAMILY_APPLY_RES value
     * @property {number} FAMILY_INFO_REQ=181 FAMILY_INFO_REQ value
     * @property {number} FAMILY_INFO_RES=182 FAMILY_INFO_RES value
     * @property {number} FAMILY_CHATS_REQ=185 FAMILY_CHATS_REQ value
     * @property {number} FAMILY_CHATS_RES=186 FAMILY_CHATS_RES value
     * @property {number} SEND_FAMILY_CHAT_REQ=187 SEND_FAMILY_CHAT_REQ value
     * @property {number} SEND_FAMILY_CHAT_RES=188 SEND_FAMILY_CHAT_RES value
     * @property {number} SEARCH_FAMILY_REQ=189 SEARCH_FAMILY_REQ value
     * @property {number} NOTICE_MEMBER_CHANGE_RES=200 NOTICE_MEMBER_CHANGE_RES value
     * @property {number} SET_FAMILY_JOB_REQ=201 SET_FAMILY_JOB_REQ value
     * @property {number} SET_FAMILY_JOB_RES=202 SET_FAMILY_JOB_RES value
     * @property {number} TICK_FAMILY_MEMBER_REQ=500 TICK_FAMILY_MEMBER_REQ value
     * @property {number} TICK_FAMILY_MEMBER_RES=501 TICK_FAMILY_MEMBER_RES value
     * @property {number} SET_FAMILY_INFO_REQ=502 SET_FAMILY_INFO_REQ value
     * @property {number} SET_FAMILY_INFO_RES=503 SET_FAMILY_INFO_RES value
     * @property {number} BUY_TREASURE_REQ=203 BUY_TREASURE_REQ value
     * @property {number} BUY_TREASURE_RES=204 BUY_TREASURE_RES value
     * @property {number} BUY_TREASURE_INFO_REQ=205 BUY_TREASURE_INFO_REQ value
     * @property {number} BUY_TREASURE_INFO_RES=206 BUY_TREASURE_INFO_RES value
     * @property {number} BATTLE_REWARD_RES=207 BATTLE_REWARD_RES value
     * @property {number} SIMPLE_RECORD_REQ=208 SIMPLE_RECORD_REQ value
     * @property {number} SIMPLE_RECORD_RES=209 SIMPLE_RECORD_RES value
     * @property {number} FIGHT_RECORD_REQ=210 FIGHT_RECORD_REQ value
     * @property {number} FIGHT_RECORD_RES=211 FIGHT_RECORD_RES value
     * @property {number} ALL_MAILS_REQ=230 ALL_MAILS_REQ value
     * @property {number} ALL_MAILS_RES=231 ALL_MAILS_RES value
     * @property {number} NOTICE_MAIL_RES=232 NOTICE_MAIL_RES value
     * @property {number} READ_MAIL_REQ=233 READ_MAIL_REQ value
     * @property {number} READ_MAIL_RES=234 READ_MAIL_RES value
     * @property {number} GET_MAIL_REQ=235 GET_MAIL_REQ value
     * @property {number} GET_MAIL_RES=236 GET_MAIL_RES value
     * @property {number} DEL_MAIL_REQ=237 DEL_MAIL_REQ value
     * @property {number} DEL_MAIL_RES=238 DEL_MAIL_RES value
     * @property {number} FIGHT_MONSTER_REQ=239 FIGHT_MONSTER_REQ value
     * @property {number} FIGHT_MONSTER_RES=240 FIGHT_MONSTER_RES value
     * @property {number} FIGHT_MONSTER_RESULT_REQ=241 FIGHT_MONSTER_RESULT_REQ value
     * @property {number} FIGHT_MONSTER_RESULT_RES=242 FIGHT_MONSTER_RESULT_RES value
     * @property {number} QUERY_ROLE_LINEUP_REQ=243 QUERY_ROLE_LINEUP_REQ value
     * @property {number} QUERY_ROLE_LINEUP_RES=244 QUERY_ROLE_LINEUP_RES value
     * @property {number} ALL_BOX_REQ=245 ALL_BOX_REQ value
     * @property {number} ALL_BOX_RES=246 ALL_BOX_RES value
     * @property {number} SINGLE_BOX_RES=247 SINGLE_BOX_RES value
     * @property {number} OPEN_BOX_REQ=248 OPEN_BOX_REQ value
     * @property {number} OPEN_BOX_RES=249 OPEN_BOX_RES value
     * @property {number} GET_BOX_REQ=250 GET_BOX_REQ value
     * @property {number} GET_BOX_RES=251 GET_BOX_RES value
     * @property {number} DELETE_BOX_RES=252 DELETE_BOX_RES value
     * @property {number} BOX_REWARD_RES=253 BOX_REWARD_RES value
     * @property {number} COST_KEY_REQ=254 COST_KEY_REQ value
     * @property {number} COST_KEY_RES=255 COST_KEY_RES value
     * @property {number} BUY_KEY_REQ=256 BUY_KEY_REQ value
     * @property {number} BUY_KEY_RES=257 BUY_KEY_RES value
     * @property {number} BUY_TASK_TIME_REQ=258 BUY_TASK_TIME_REQ value
     * @property {number} BUY_TASK_TIME_RES=259 BUY_TASK_TIME_RES value
     * @property {number} CHANGE_NAME_REQ=260 CHANGE_NAME_REQ value
     * @property {number} CHANGE_NAME_RES=261 CHANGE_NAME_RES value
     * @property {number} WAR_GOD_INFO_REQ=262 WAR_GOD_INFO_REQ value
     * @property {number} WAR_GOD_INFO_RES=263 WAR_GOD_INFO_RES value
     * @property {number} WAR_GOD_REWARD_REQ=264 WAR_GOD_REWARD_REQ value
     * @property {number} WAR_GOD_REWARD_RES=265 WAR_GOD_REWARD_RES value
     * @property {number} GET_LOGIN_REWARD_REQ=266 GET_LOGIN_REWARD_REQ value
     * @property {number} GET_LOGIN_REWARD_RES=267 GET_LOGIN_REWARD_RES value
     * @property {number} PASS_DAY_RES=268 PASS_DAY_RES value
     * @property {number} ASK_LOGIN_REWARD_GETTED_REQ=269 ASK_LOGIN_REWARD_GETTED_REQ value
     * @property {number} ASK_LOGIN_REWARD_GETTED_RES=270 ASK_LOGIN_REWARD_GETTED_RES value
     * @property {number} GIFT_INFO_RES=271 GIFT_INFO_RES value
     * @property {number} GIFT_BUY_REQ=272 GIFT_BUY_REQ value
     * @property {number} GIFT_BUY_RES=273 GIFT_BUY_RES value
     * @property {number} REWARDS_RES=274 REWARDS_RES value
     * @property {number} GUIDE_REQ=275 GUIDE_REQ value
     * @property {number} GUIDE_RES=276 GUIDE_RES value
     * @property {number} FINISH_RECHARGE_RES=277 FINISH_RECHARGE_RES value
     * @property {number} GET_FIRST_RECHARGE_REWARD_REQ=278 GET_FIRST_RECHARGE_REWARD_REQ value
     * @property {number} TIANTI_REWARD_INFO_RES=280 TIANTI_REWARD_INFO_RES value
     * @property {number} GET_TIANTI_REWARD_REQ=290 GET_TIANTI_REWARD_REQ value
     * @property {number} GET_TIANTI_REWARD_RES=291 GET_TIANTI_REWARD_RES value
     * @property {number} NOTICE_WAR_EVENT_REQ=292 NOTICE_WAR_EVENT_REQ value
     * @property {number} GET_FAMILY_RANK_REQ=293 GET_FAMILY_RANK_REQ value
     * @property {number} GET_FAMILY_RANK_RES=294 GET_FAMILY_RANK_RES value
     * @property {number} KICK_OUT_RES=295 KICK_OUT_RES value
     * @property {number} CHANGE_ROLEPIC_REQ=296 CHANGE_ROLEPIC_REQ value
     * @property {number} CHANGE_ROLEPIC_RES=297 CHANGE_ROLEPIC_RES value
     * @property {number} GET_CODE_REWARD_REQ=298 GET_CODE_REWARD_REQ value
     * @property {number} GET_CODE_REWARD_RES=299 GET_CODE_REWARD_RES value
     * @property {number} GET_SERVER_NOTICE_REQ=300 GET_SERVER_NOTICE_REQ value
     * @property {number} GET_SERVER_NOTICE_RES=301 GET_SERVER_NOTICE_RES value
     * @property {number} LOGIN_FIGHT=1001 LOGIN_FIGHT value
     * @property {number} LOGIN_FIGHT_RET=1002 LOGIN_FIGHT_RET value
     * @property {number} CREATE_MATCH_ROOM=1003 CREATE_MATCH_ROOM value
     * @property {number} FIGHT_2_LOGIC_PACK=1004 FIGHT_2_LOGIC_PACK value
     * @property {number} F2L_BATTLE_TIME_END=1005 F2L_BATTLE_TIME_END value
     * @property {number} F2L_BATTLE_END=1006 F2L_BATTLE_END value
     * @property {number} F2L_FIGHT_RECORD=1007 F2L_FIGHT_RECORD value
     * @property {number} LOGIC_LOGIN_MATCH=2001 LOGIC_LOGIN_MATCH value
     * @property {number} LOGIC_LOGIN_MATCH_RET=2002 LOGIC_LOGIN_MATCH_RET value
     * @property {number} GO_MATCH=2003 GO_MATCH value
     * @property {number} GO_MATCH_RET=2004 GO_MATCH_RET value
     * @property {number} L2M_CANCLE_MATCH=2006 L2M_CANCLE_MATCH value
     * @property {number} M2L_CANCLE_MATCH=2007 M2L_CANCLE_MATCH value
     * @property {number} M2L_SELECT_ONLINE_ROLE=2008 M2L_SELECT_ONLINE_ROLE value
     * @property {number} L2M_SELECT_ONLINE_ROLE=2009 L2M_SELECT_ONLINE_ROLE value
     * @property {number} L2M_GET_RANDOM_FRIEND=2010 L2M_GET_RANDOM_FRIEND value
     * @property {number} M2L_GET_RANDOM_FRIEND_RET=2011 M2L_GET_RANDOM_FRIEND_RET value
     * @property {number} L2M_INVITE_FRIEND=2012 L2M_INVITE_FRIEND value
     * @property {number} M2L_INVITE_FRIEND=2013 M2L_INVITE_FRIEND value
     * @property {number} L2M_FRIEND_CHAT=2014 L2M_FRIEND_CHAT value
     * @property {number} M2L_FRIEND_CHAT=2015 M2L_FRIEND_CHAT value
     * @property {number} L2M_ADD_FRIEND=2016 L2M_ADD_FRIEND value
     * @property {number} M2L_ADD_FRIEND=2017 M2L_ADD_FRIEND value
     * @property {number} L2M_DELETE_FRIEND=2018 L2M_DELETE_FRIEND value
     * @property {number} M2L_DELETE_FRIEND=2019 M2L_DELETE_FRIEND value
     * @property {number} L2M_CREATE_FAMILY=2020 L2M_CREATE_FAMILY value
     * @property {number} M2L_CREATE_FAMILY_RET=2021 M2L_CREATE_FAMILY_RET value
     * @property {number} L2M_JOIN_FAMILY=2022 L2M_JOIN_FAMILY value
     * @property {number} L2M_ASK_FAMILY=2023 L2M_ASK_FAMILY value
     * @property {number} M2L_ASK_FAMILY=2024 M2L_ASK_FAMILY value
     * @property {number} L2M_ASK_FAMILY_APPLY=2025 L2M_ASK_FAMILY_APPLY value
     * @property {number} M2L_ASK_FAMILY_APPLY=2026 M2L_ASK_FAMILY_APPLY value
     * @property {number} L2M_SELF_FAMILY_INFO=2027 L2M_SELF_FAMILY_INFO value
     * @property {number} M2L_SELF_FAMILY_INFO=2028 M2L_SELF_FAMILY_INFO value
     * @property {number} L2M_FAMILY_CHATS=2029 L2M_FAMILY_CHATS value
     * @property {number} M2L_FAMILY_CHATS=2030 M2L_FAMILY_CHATS value
     * @property {number} L2M_SEND_FAMILY_CHAT=2031 L2M_SEND_FAMILY_CHAT value
     * @property {number} M2L_SEND_FAMILY_CHAT=2032 M2L_SEND_FAMILY_CHAT value
     * @property {number} M2L_JOIN_FAMILY_SUCEED=2033 M2L_JOIN_FAMILY_SUCEED value
     * @property {number} L2M_SEARCH_FAMILY=2034 L2M_SEARCH_FAMILY value
     * @property {number} L2M_LEAVE_FAMILY=2035 L2M_LEAVE_FAMILY value
     * @property {number} M2L_LEAVE_FAMILY=2501 M2L_LEAVE_FAMILY value
     * @property {number} L2M_ACCEPT_FAMILY_APPLY=2036 L2M_ACCEPT_FAMILY_APPLY value
     * @property {number} M2L_FAMILY_MEMBER_CHANGE=2037 M2L_FAMILY_MEMBER_CHANGE value
     * @property {number} L2M_SET_FAMILY_JOB=2038 L2M_SET_FAMILY_JOB value
     * @property {number} M2L_SET_FAMILY_JOB=2039 M2L_SET_FAMILY_JOB value
     * @property {number} L2M_TICK_FAMILY_MEMBER=2040 L2M_TICK_FAMILY_MEMBER value
     * @property {number} M2L_TICK_FAMILY_MEMBER=2041 M2L_TICK_FAMILY_MEMBER value
     * @property {number} L2M_SET_FAMILY_INFO=2042 L2M_SET_FAMILY_INFO value
     * @property {number} M2L_SET_FAMILY_INFO=2043 M2L_SET_FAMILY_INFO value
     * @property {number} L2M_FAMILY_RANK=2044 L2M_FAMILY_RANK value
     * @property {number} M2L_FAMILY_RANK=2045 M2L_FAMILY_RANK value
     * @property {number} L2M_MEMBER_DATA_CHANGE=2046 L2M_MEMBER_DATA_CHANGE value
     * @property {number} L2M_GET_FAMILY_RANK=2047 L2M_GET_FAMILY_RANK value
     * @property {number} M2L_GET_FAMILY_RANK=2048 M2L_GET_FAMILY_RANK value
     * @property {number} FIGHT_LOGIN_MATCH=3001 FIGHT_LOGIN_MATCH value
     * @property {number} FIGHT_LOGIN_MATCH_RET=3002 FIGHT_LOGIN_MATCH_RET value
     * @property {number} ENTER_ROOM_REQ=4001 ENTER_ROOM_REQ value
     * @property {number} ENTER_ROOM_RES=4002 ENTER_ROOM_RES value
     * @property {number} WAR_READY_REQ=4003 WAR_READY_REQ value
     * @property {number} WAR_READY_RES=4004 WAR_READY_RES value
     * @property {number} START_WAR_RES=4005 START_WAR_RES value
     * @property {number} ACTION_REQ=4006 ACTION_REQ value
     * @property {number} ACTION_RES=4007 ACTION_RES value
     * @property {number} SERVER_TIME_REQ=4008 SERVER_TIME_REQ value
     * @property {number} SERVER_TIME_RES=4009 SERVER_TIME_RES value
     * @property {number} SYN_ROOM_STATE_RES=4010 SYN_ROOM_STATE_RES value
     * @property {number} BATTLE_END_REQ=4011 BATTLE_END_REQ value
     * @property {number} BATTLE_RET_RES=4012 BATTLE_RET_RES value
     * @property {number} ACTIONFRAME_REQ=4013 ACTIONFRAME_REQ value
     * @property {number} ACTIONFRAME_RES=4014 ACTIONFRAME_RES value
     * @property {number} FIGHT_RECONNECT_REQ=4015 FIGHT_RECONNECT_REQ value
     * @property {number} FIGHT_RECONNECT_ROOM_RES=4016 FIGHT_RECONNECT_ROOM_RES value
     * @property {number} FIGHT_RECONNECT_ACTION_RES=4017 FIGHT_RECONNECT_ACTION_RES value
     * @property {number} FRAME_RECORD_REQ=4018 FRAME_RECORD_REQ value
     * @property {number} FRAME_RECORD_RES=4019 FRAME_RECORD_RES value
     * @property {number} LOGIC_LOGIN_CENTER=5001 LOGIC_LOGIN_CENTER value
     * @property {number} LOGIC_LOGIN_CENTER_RET=5002 LOGIC_LOGIN_CENTER_RET value
     * @property {number} COMMITE_INFO=5003 COMMITE_INFO value
     * @property {number} NOTICE_CUPS=5004 NOTICE_CUPS value
     * @property {number} GET_RANK_INFO=5005 GET_RANK_INFO value
     * @property {number} GET_RANK_INFO_BACK=5006 GET_RANK_INFO_BACK value
     * @property {number} L2C_QUERY_LINEUP=5007 L2C_QUERY_LINEUP value
     * @property {number} C2L_QUERY_LINEUP=5008 C2L_QUERY_LINEUP value
     * @property {number} L2C_NAME_EXIST=5009 L2C_NAME_EXIST value
     * @property {number} C2L_NAME_EXIST=5010 C2L_NAME_EXIST value
     * @property {number} L2C_INSERT_NAME=5011 L2C_INSERT_NAME value
     * @property {number} L2C_CHECK_FAMILY_NAME=5012 L2C_CHECK_FAMILY_NAME value
     * @property {number} C2L_CHECK_FAMILY_NAME=5013 C2L_CHECK_FAMILY_NAME value
     * @property {number} L2C_INSERT_FAMILY_NAME=5014 L2C_INSERT_FAMILY_NAME value
     * @property {number} MATCH_LOGIN_CENTER=6001 MATCH_LOGIN_CENTER value
     * @property {number} MATCH_LOGIN_CENTER_RET=6002 MATCH_LOGIN_CENTER_RET value
     * @property {number} SELECT_LINEUP_DATA=6003 SELECT_LINEUP_DATA value
     * @property {number} SELECT_LINEUP_DATA_RET=6004 SELECT_LINEUP_DATA_RET value
     * @property {number} CHECK_LOGIN_FIGHT_REQUEST=7001 CHECK_LOGIN_FIGHT_REQUEST value
     * @property {number} CHECK_LOGIN_FIGHT_RESPOND=7002 CHECK_LOGIN_FIGHT_RESPOND value
     * @property {number} FIGHT_ROOM_INFO_RESPOND=7003 FIGHT_ROOM_INFO_RESPOND value
     * @property {number} CHCEK_CAL_RESULT_REQUEST=7004 CHCEK_CAL_RESULT_REQUEST value
     */
    Protocol.MessageID = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "INVAILED"] = 0;
        values[valuesById[2] = "LOGIN_GAME_REQ"] = 2;
        values[valuesById[3] = "LOGIN_GAME_RES"] = 3;
        values[valuesById[101] = "HEARBEAT_RES"] = 101;
        values[valuesById[102] = "HEARBEAT_REQ"] = 102;
        values[valuesById[104] = "BEGIN_MATCH_REQ"] = 104;
        values[valuesById[105] = "BEGIN_MATCH_RES"] = 105;
        values[valuesById[106] = "FIGHT_ROOM_INFO_RES"] = 106;
        values[valuesById[107] = "CANCLE_MATCH_REQ"] = 107;
        values[valuesById[108] = "CANCLE_MATCH_RES"] = 108;
        values[valuesById[109] = "GM_COMMAND_REQ"] = 109;
        values[valuesById[110] = "GM_COMMAND_RES"] = 110;
        values[valuesById[111] = "SET_LINEUP_REQ"] = 111;
        values[valuesById[112] = "SET_LINEUP_RES"] = 112;
        values[valuesById[113] = "SET_FIGHT_LINEUP_REQ"] = 113;
        values[valuesById[114] = "SET_FIGHT_LINEUP_RES"] = 114;
        values[valuesById[115] = "GET_RANK_RANGE_REQ"] = 115;
        values[valuesById[116] = "GET_RANK_RANGE_RES"] = 116;
        values[valuesById[117] = "QUIT_WAR_REQ"] = 117;
        values[valuesById[118] = "QUIT_WAR_RES"] = 118;
        values[valuesById[119] = "TASK_CHANGE_RES"] = 119;
        values[valuesById[120] = "FINISH_TASK_REQ"] = 120;
        values[valuesById[121] = "REFRESH_TASK_REQ"] = 121;
        values[valuesById[122] = "GET_LOGIC_TIME_REQ"] = 122;
        values[valuesById[123] = "GET_LOGIC_TIME_RES"] = 123;
        values[valuesById[124] = "PROPERTY_CHANGE_RES"] = 124;
        values[valuesById[125] = "TASK_SCOPE_BOX_OPEN_REQ"] = 125;
        values[valuesById[126] = "REWARD_RES"] = 126;
        values[valuesById[127] = "ITEM_CHANGE_RES"] = 127;
        values[valuesById[128] = "HERO_LEVEL_UP_REQ"] = 128;
        values[valuesById[129] = "HERO_LEVEL_UP_RES"] = 129;
        values[valuesById[130] = "ERROR_NOTICE_RES"] = 130;
        values[valuesById[131] = "SKILL_LEVEL_UP_REQ"] = 131;
        values[valuesById[132] = "SKILL_LEVEL_UP_RES"] = 132;
        values[valuesById[133] = "ADD_HERO_RES"] = 133;
        values[valuesById[134] = "FRIEND_CHAT_REQ"] = 134;
        values[valuesById[135] = "FRIEND_CHAT_RES"] = 135;
        values[valuesById[136] = "INVITE_FRIEND_REQ"] = 136;
        values[valuesById[137] = "INVITE_FRIEND_RES"] = 137;
        values[valuesById[139] = "ACCEPT_FRIEND_REQ"] = 139;
        values[valuesById[140] = "ADD_FRIEND_RES"] = 140;
        values[valuesById[141] = "ASK_FRIEND_LIST_REQ"] = 141;
        values[valuesById[142] = "ASK_FRIEND_LIST_RES"] = 142;
        values[valuesById[143] = "ALL_FRIENDS_REQ"] = 143;
        values[valuesById[144] = "ALL_FRIENDS_RES"] = 144;
        values[valuesById[145] = "ALL_INVITES_REQ"] = 145;
        values[valuesById[146] = "ALL_INVITES_RES"] = 146;
        values[valuesById[147] = "ALL_CHAT_REQ"] = 147;
        values[valuesById[148] = "ALL_CHAT_RES"] = 148;
        values[valuesById[149] = "FRIEND_STATE_RES"] = 149;
        values[valuesById[150] = "DELETE_INVITE_RES"] = 150;
        values[valuesById[151] = "NOTICE_LAST_READ_TIME_REQ"] = 151;
        values[valuesById[152] = "DELETE_FRINED_REQ"] = 152;
        values[valuesById[153] = "DELETE_FRIEND_RES"] = 153;
        values[valuesById[170] = "ASK_FAMILY_REQ"] = 170;
        values[valuesById[171] = "ASK_FAMILY_RES"] = 171;
        values[valuesById[172] = "JOIN_FAMILY_REQ"] = 172;
        values[valuesById[173] = "JOIN_FAMILY_RES"] = 173;
        values[valuesById[190] = "JOIN_FAMILY_SUCEED_RES"] = 190;
        values[valuesById[191] = "JOIN_FAMILY_APPLYS_REQ"] = 191;
        values[valuesById[192] = "JOIN_FAMILY_APPLYS_RES"] = 192;
        values[valuesById[174] = "CREATE_FAMILY_REQ"] = 174;
        values[valuesById[175] = "CREATE_FAMILY_RES"] = 175;
        values[valuesById[176] = "LEAVE_FAMILY_REQ"] = 176;
        values[valuesById[177] = "LEAVE_FAMILY_RES"] = 177;
        values[valuesById[178] = "ASK_FAMILY_APPLY_REQ"] = 178;
        values[valuesById[179] = "ASK_FAMILY_APPLY_RES"] = 179;
        values[valuesById[180] = "ACCEPT_FAMILY_APPLY_REQ"] = 180;
        values[valuesById[196] = "ACCEPT_FAMILY_APPLY_RES"] = 196;
        values[valuesById[181] = "FAMILY_INFO_REQ"] = 181;
        values[valuesById[182] = "FAMILY_INFO_RES"] = 182;
        values[valuesById[185] = "FAMILY_CHATS_REQ"] = 185;
        values[valuesById[186] = "FAMILY_CHATS_RES"] = 186;
        values[valuesById[187] = "SEND_FAMILY_CHAT_REQ"] = 187;
        values[valuesById[188] = "SEND_FAMILY_CHAT_RES"] = 188;
        values[valuesById[189] = "SEARCH_FAMILY_REQ"] = 189;
        values[valuesById[200] = "NOTICE_MEMBER_CHANGE_RES"] = 200;
        values[valuesById[201] = "SET_FAMILY_JOB_REQ"] = 201;
        values[valuesById[202] = "SET_FAMILY_JOB_RES"] = 202;
        values[valuesById[500] = "TICK_FAMILY_MEMBER_REQ"] = 500;
        values[valuesById[501] = "TICK_FAMILY_MEMBER_RES"] = 501;
        values[valuesById[502] = "SET_FAMILY_INFO_REQ"] = 502;
        values[valuesById[503] = "SET_FAMILY_INFO_RES"] = 503;
        values[valuesById[203] = "BUY_TREASURE_REQ"] = 203;
        values[valuesById[204] = "BUY_TREASURE_RES"] = 204;
        values[valuesById[205] = "BUY_TREASURE_INFO_REQ"] = 205;
        values[valuesById[206] = "BUY_TREASURE_INFO_RES"] = 206;
        values[valuesById[207] = "BATTLE_REWARD_RES"] = 207;
        values[valuesById[208] = "SIMPLE_RECORD_REQ"] = 208;
        values[valuesById[209] = "SIMPLE_RECORD_RES"] = 209;
        values[valuesById[210] = "FIGHT_RECORD_REQ"] = 210;
        values[valuesById[211] = "FIGHT_RECORD_RES"] = 211;
        values[valuesById[230] = "ALL_MAILS_REQ"] = 230;
        values[valuesById[231] = "ALL_MAILS_RES"] = 231;
        values[valuesById[232] = "NOTICE_MAIL_RES"] = 232;
        values[valuesById[233] = "READ_MAIL_REQ"] = 233;
        values[valuesById[234] = "READ_MAIL_RES"] = 234;
        values[valuesById[235] = "GET_MAIL_REQ"] = 235;
        values[valuesById[236] = "GET_MAIL_RES"] = 236;
        values[valuesById[237] = "DEL_MAIL_REQ"] = 237;
        values[valuesById[238] = "DEL_MAIL_RES"] = 238;
        values[valuesById[239] = "FIGHT_MONSTER_REQ"] = 239;
        values[valuesById[240] = "FIGHT_MONSTER_RES"] = 240;
        values[valuesById[241] = "FIGHT_MONSTER_RESULT_REQ"] = 241;
        values[valuesById[242] = "FIGHT_MONSTER_RESULT_RES"] = 242;
        values[valuesById[243] = "QUERY_ROLE_LINEUP_REQ"] = 243;
        values[valuesById[244] = "QUERY_ROLE_LINEUP_RES"] = 244;
        values[valuesById[245] = "ALL_BOX_REQ"] = 245;
        values[valuesById[246] = "ALL_BOX_RES"] = 246;
        values[valuesById[247] = "SINGLE_BOX_RES"] = 247;
        values[valuesById[248] = "OPEN_BOX_REQ"] = 248;
        values[valuesById[249] = "OPEN_BOX_RES"] = 249;
        values[valuesById[250] = "GET_BOX_REQ"] = 250;
        values[valuesById[251] = "GET_BOX_RES"] = 251;
        values[valuesById[252] = "DELETE_BOX_RES"] = 252;
        values[valuesById[253] = "BOX_REWARD_RES"] = 253;
        values[valuesById[254] = "COST_KEY_REQ"] = 254;
        values[valuesById[255] = "COST_KEY_RES"] = 255;
        values[valuesById[256] = "BUY_KEY_REQ"] = 256;
        values[valuesById[257] = "BUY_KEY_RES"] = 257;
        values[valuesById[258] = "BUY_TASK_TIME_REQ"] = 258;
        values[valuesById[259] = "BUY_TASK_TIME_RES"] = 259;
        values[valuesById[260] = "CHANGE_NAME_REQ"] = 260;
        values[valuesById[261] = "CHANGE_NAME_RES"] = 261;
        values[valuesById[262] = "WAR_GOD_INFO_REQ"] = 262;
        values[valuesById[263] = "WAR_GOD_INFO_RES"] = 263;
        values[valuesById[264] = "WAR_GOD_REWARD_REQ"] = 264;
        values[valuesById[265] = "WAR_GOD_REWARD_RES"] = 265;
        values[valuesById[266] = "GET_LOGIN_REWARD_REQ"] = 266;
        values[valuesById[267] = "GET_LOGIN_REWARD_RES"] = 267;
        values[valuesById[268] = "PASS_DAY_RES"] = 268;
        values[valuesById[269] = "ASK_LOGIN_REWARD_GETTED_REQ"] = 269;
        values[valuesById[270] = "ASK_LOGIN_REWARD_GETTED_RES"] = 270;
        values[valuesById[271] = "GIFT_INFO_RES"] = 271;
        values[valuesById[272] = "GIFT_BUY_REQ"] = 272;
        values[valuesById[273] = "GIFT_BUY_RES"] = 273;
        values[valuesById[274] = "REWARDS_RES"] = 274;
        values[valuesById[275] = "GUIDE_REQ"] = 275;
        values[valuesById[276] = "GUIDE_RES"] = 276;
        values[valuesById[277] = "FINISH_RECHARGE_RES"] = 277;
        values[valuesById[278] = "GET_FIRST_RECHARGE_REWARD_REQ"] = 278;
        values[valuesById[280] = "TIANTI_REWARD_INFO_RES"] = 280;
        values[valuesById[290] = "GET_TIANTI_REWARD_REQ"] = 290;
        values[valuesById[291] = "GET_TIANTI_REWARD_RES"] = 291;
        values[valuesById[292] = "NOTICE_WAR_EVENT_REQ"] = 292;
        values[valuesById[293] = "GET_FAMILY_RANK_REQ"] = 293;
        values[valuesById[294] = "GET_FAMILY_RANK_RES"] = 294;
        values[valuesById[295] = "KICK_OUT_RES"] = 295;
        values[valuesById[296] = "CHANGE_ROLEPIC_REQ"] = 296;
        values[valuesById[297] = "CHANGE_ROLEPIC_RES"] = 297;
        values[valuesById[298] = "GET_CODE_REWARD_REQ"] = 298;
        values[valuesById[299] = "GET_CODE_REWARD_RES"] = 299;
        values[valuesById[300] = "GET_SERVER_NOTICE_REQ"] = 300;
        values[valuesById[301] = "GET_SERVER_NOTICE_RES"] = 301;
        values[valuesById[1001] = "LOGIN_FIGHT"] = 1001;
        values[valuesById[1002] = "LOGIN_FIGHT_RET"] = 1002;
        values[valuesById[1003] = "CREATE_MATCH_ROOM"] = 1003;
        values[valuesById[1004] = "FIGHT_2_LOGIC_PACK"] = 1004;
        values[valuesById[1005] = "F2L_BATTLE_TIME_END"] = 1005;
        values[valuesById[1006] = "F2L_BATTLE_END"] = 1006;
        values[valuesById[1007] = "F2L_FIGHT_RECORD"] = 1007;
        values[valuesById[2001] = "LOGIC_LOGIN_MATCH"] = 2001;
        values[valuesById[2002] = "LOGIC_LOGIN_MATCH_RET"] = 2002;
        values[valuesById[2003] = "GO_MATCH"] = 2003;
        values[valuesById[2004] = "GO_MATCH_RET"] = 2004;
        values[valuesById[2006] = "L2M_CANCLE_MATCH"] = 2006;
        values[valuesById[2007] = "M2L_CANCLE_MATCH"] = 2007;
        values[valuesById[2008] = "M2L_SELECT_ONLINE_ROLE"] = 2008;
        values[valuesById[2009] = "L2M_SELECT_ONLINE_ROLE"] = 2009;
        values[valuesById[2010] = "L2M_GET_RANDOM_FRIEND"] = 2010;
        values[valuesById[2011] = "M2L_GET_RANDOM_FRIEND_RET"] = 2011;
        values[valuesById[2012] = "L2M_INVITE_FRIEND"] = 2012;
        values[valuesById[2013] = "M2L_INVITE_FRIEND"] = 2013;
        values[valuesById[2014] = "L2M_FRIEND_CHAT"] = 2014;
        values[valuesById[2015] = "M2L_FRIEND_CHAT"] = 2015;
        values[valuesById[2016] = "L2M_ADD_FRIEND"] = 2016;
        values[valuesById[2017] = "M2L_ADD_FRIEND"] = 2017;
        values[valuesById[2018] = "L2M_DELETE_FRIEND"] = 2018;
        values[valuesById[2019] = "M2L_DELETE_FRIEND"] = 2019;
        values[valuesById[2020] = "L2M_CREATE_FAMILY"] = 2020;
        values[valuesById[2021] = "M2L_CREATE_FAMILY_RET"] = 2021;
        values[valuesById[2022] = "L2M_JOIN_FAMILY"] = 2022;
        values[valuesById[2023] = "L2M_ASK_FAMILY"] = 2023;
        values[valuesById[2024] = "M2L_ASK_FAMILY"] = 2024;
        values[valuesById[2025] = "L2M_ASK_FAMILY_APPLY"] = 2025;
        values[valuesById[2026] = "M2L_ASK_FAMILY_APPLY"] = 2026;
        values[valuesById[2027] = "L2M_SELF_FAMILY_INFO"] = 2027;
        values[valuesById[2028] = "M2L_SELF_FAMILY_INFO"] = 2028;
        values[valuesById[2029] = "L2M_FAMILY_CHATS"] = 2029;
        values[valuesById[2030] = "M2L_FAMILY_CHATS"] = 2030;
        values[valuesById[2031] = "L2M_SEND_FAMILY_CHAT"] = 2031;
        values[valuesById[2032] = "M2L_SEND_FAMILY_CHAT"] = 2032;
        values[valuesById[2033] = "M2L_JOIN_FAMILY_SUCEED"] = 2033;
        values[valuesById[2034] = "L2M_SEARCH_FAMILY"] = 2034;
        values[valuesById[2035] = "L2M_LEAVE_FAMILY"] = 2035;
        values[valuesById[2501] = "M2L_LEAVE_FAMILY"] = 2501;
        values[valuesById[2036] = "L2M_ACCEPT_FAMILY_APPLY"] = 2036;
        values[valuesById[2037] = "M2L_FAMILY_MEMBER_CHANGE"] = 2037;
        values[valuesById[2038] = "L2M_SET_FAMILY_JOB"] = 2038;
        values[valuesById[2039] = "M2L_SET_FAMILY_JOB"] = 2039;
        values[valuesById[2040] = "L2M_TICK_FAMILY_MEMBER"] = 2040;
        values[valuesById[2041] = "M2L_TICK_FAMILY_MEMBER"] = 2041;
        values[valuesById[2042] = "L2M_SET_FAMILY_INFO"] = 2042;
        values[valuesById[2043] = "M2L_SET_FAMILY_INFO"] = 2043;
        values[valuesById[2044] = "L2M_FAMILY_RANK"] = 2044;
        values[valuesById[2045] = "M2L_FAMILY_RANK"] = 2045;
        values[valuesById[2046] = "L2M_MEMBER_DATA_CHANGE"] = 2046;
        values[valuesById[2047] = "L2M_GET_FAMILY_RANK"] = 2047;
        values[valuesById[2048] = "M2L_GET_FAMILY_RANK"] = 2048;
        values[valuesById[3001] = "FIGHT_LOGIN_MATCH"] = 3001;
        values[valuesById[3002] = "FIGHT_LOGIN_MATCH_RET"] = 3002;
        values[valuesById[4001] = "ENTER_ROOM_REQ"] = 4001;
        values[valuesById[4002] = "ENTER_ROOM_RES"] = 4002;
        values[valuesById[4003] = "WAR_READY_REQ"] = 4003;
        values[valuesById[4004] = "WAR_READY_RES"] = 4004;
        values[valuesById[4005] = "START_WAR_RES"] = 4005;
        values[valuesById[4006] = "ACTION_REQ"] = 4006;
        values[valuesById[4007] = "ACTION_RES"] = 4007;
        values[valuesById[4008] = "SERVER_TIME_REQ"] = 4008;
        values[valuesById[4009] = "SERVER_TIME_RES"] = 4009;
        values[valuesById[4010] = "SYN_ROOM_STATE_RES"] = 4010;
        values[valuesById[4011] = "BATTLE_END_REQ"] = 4011;
        values[valuesById[4012] = "BATTLE_RET_RES"] = 4012;
        values[valuesById[4013] = "ACTIONFRAME_REQ"] = 4013;
        values[valuesById[4014] = "ACTIONFRAME_RES"] = 4014;
        values[valuesById[4015] = "FIGHT_RECONNECT_REQ"] = 4015;
        values[valuesById[4016] = "FIGHT_RECONNECT_ROOM_RES"] = 4016;
        values[valuesById[4017] = "FIGHT_RECONNECT_ACTION_RES"] = 4017;
        values[valuesById[4018] = "FRAME_RECORD_REQ"] = 4018;
        values[valuesById[4019] = "FRAME_RECORD_RES"] = 4019;
        values[valuesById[5001] = "LOGIC_LOGIN_CENTER"] = 5001;
        values[valuesById[5002] = "LOGIC_LOGIN_CENTER_RET"] = 5002;
        values[valuesById[5003] = "COMMITE_INFO"] = 5003;
        values[valuesById[5004] = "NOTICE_CUPS"] = 5004;
        values[valuesById[5005] = "GET_RANK_INFO"] = 5005;
        values[valuesById[5006] = "GET_RANK_INFO_BACK"] = 5006;
        values[valuesById[5007] = "L2C_QUERY_LINEUP"] = 5007;
        values[valuesById[5008] = "C2L_QUERY_LINEUP"] = 5008;
        values[valuesById[5009] = "L2C_NAME_EXIST"] = 5009;
        values[valuesById[5010] = "C2L_NAME_EXIST"] = 5010;
        values[valuesById[5011] = "L2C_INSERT_NAME"] = 5011;
        values[valuesById[5012] = "L2C_CHECK_FAMILY_NAME"] = 5012;
        values[valuesById[5013] = "C2L_CHECK_FAMILY_NAME"] = 5013;
        values[valuesById[5014] = "L2C_INSERT_FAMILY_NAME"] = 5014;
        values[valuesById[6001] = "MATCH_LOGIN_CENTER"] = 6001;
        values[valuesById[6002] = "MATCH_LOGIN_CENTER_RET"] = 6002;
        values[valuesById[6003] = "SELECT_LINEUP_DATA"] = 6003;
        values[valuesById[6004] = "SELECT_LINEUP_DATA_RET"] = 6004;
        values[valuesById[7001] = "CHECK_LOGIN_FIGHT_REQUEST"] = 7001;
        values[valuesById[7002] = "CHECK_LOGIN_FIGHT_RESPOND"] = 7002;
        values[valuesById[7003] = "FIGHT_ROOM_INFO_RESPOND"] = 7003;
        values[valuesById[7004] = "CHCEK_CAL_RESULT_REQUEST"] = 7004;
        return values;
    })();

    return Protocol;
})();